---
title: 算法-面试题
date: 2021-11-11
tags:
 - 面试题
categories:
 - 面经
---
# 动态规划

## 概念

**动态规划问题的一般形式就是求最值**，如**最长**递增子序列，**最小**编辑距离等。

**求解也就是求最值的核心问题是穷举**，把所有可行的答案穷举出来，然后在其中找最值。

**动态规划三要素**：

1. **存在重叠子问题**，**解决方案**：备忘录 / [DP table] 优化穷举过程，避免不必要的计算
2. 需要具备**最优子结构**，才能通过子问题的最值得到原问题的最值
3. 列出正确的**状态转移方程**，才能正确的穷举



## 举例

### 斐波那契数列

#### 1. 暴力递归

```js
function fib(n) {
    if(n == 1 || n == 2) return 1;
    return fib(n - 1) + fib(n - 2);
}
```

暴力递归虽然简单易懂，但是十分低效。因为它重复计算已经计算过的问题，这也就是**重叠子问题**。使得该算法时间复杂度高达 O(2^n)



#### 2. 带备忘录的递归解法

```js
function fib(n) {
    if(n<1) return 0;
    let memo = Array(n+1).fill(0)	// 备忘录全初始化为0
	return helper(memo, n)			// 初始化最简情况
}

function helper(memo, n) {
    if(n == 1 || n == 2) return 1;		// base case
    if(memo[n] != 0) return memo[n];	// 已经计算过
    memo[n] = helper(memo, n-1) + helper(memo, n-2);
    return memo[n];
}
```

<img src="https://gitee.com/dadadaxyx/my-images/raw/master/image-20210917224843211.png" alt="image-20210917224843211" style="zoom:50%;" />

<img src="https://gitee.com/dadadaxyx/my-images/raw/master/image-20210917224910371.png" alt="image-20210917224910371" style="zoom:50%;" />

该算法是利用**备忘录**，每次进入到一个子问题，先查看备忘录中是否已经存在答案，是则返回结果【避免重复计算】，否的话则继续下一步计算。

备忘录的递归算法，把一棵存在巨量冗余的递归树通过**剪枝**，改造成了一副不存在冗余的递归图，极大减少了子问题的个数。该算法时间复杂度为O(n)



#### 3. dp 数组的迭代解法

```js
function fib(n) {
    let dp = Array(n+1).fill(0)
    // base case
    dp[1] = dp[2] = 1;
	for(let i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

<img src="https://gitee.com/dadadaxyx/my-images/raw/master/image-20210917224930454.png" alt="image-20210917224930454" style="zoom:50%;" />

👆上图为 DP table

前两种是**自顶向下**的做法，该算法则是**自底向上**，直接从最底下，最简单，问题规模最小的 `f(1)` 和 `f(2)` 开始往上推，这就是动态规划的思路。**动态规划一般都脱离了递归，由循环迭代完成计算**。

这里就引出了**状态转移方程**这个名词，实际上就是描述问题结构的数学形式：

![image-20210917225641153](https://gitee.com/dadadaxyx/my-images/raw/master/image-20210917225641153.png)



#### 4. 细节优化——降低空间复杂度

```js
function fib(n) {
    if(n==2||n==1) return 1;
    let prev = 1, curr = 1;
    for(let i = 3; i <= n; i++) {
        let sum = prev + curr;
        prev = curr;
        curr = sum;
    }
    return curr;
}
```

该斐波那契列算法没有涉及到**最优子结构**。



### 凑零钱问题

题目：给你 k 种面值的硬币，面值分别为 c1，c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1。

#### 1. 暴力递归

要符合**最优子结构**，子问题间必须互相独立。

**什么叫相互独立？**如总成绩要考最高就等于每科成绩都要考最高，这些子问题是互相独立的，互不干扰。



**思考如何列出正确的状态转移方程。**

1. **先确定状态**，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额 amount。
2. **确定 dp 函数的定义**，函数 dp(n) 标识，当前的目标金额是 n，至少需要 dp(n) 个硬币凑出该金额。
3. **确定选择并择优**，也就是对于每个状态，可以做出什么选择改变当前状态。
4. **最后明确 base case**，显然目标金额为0时，所需硬币数量为0；当目标金额小于0时，无解，返回-1。

```js
function coinChange(coins, amount) {
    // base case
    if(n==0)return 0;
    if(n<0)return -1;
    let res = Number.MAX_VALUE;
    for(let coin of coins) {
        // 计算子问题的结果
        let subproblem = coinChange(coins, amount - coin)
        // 子问题无解则跳过
        if(subproblem==-1) continue;
        // 在子问题中选择最优解，然后加一
        res = min(res, 1+subproblem)
    }
    return res == Number.MAX_VALUE ? -1 : res;
}
```

![image-20210918011807620](https://gitee.com/dadadaxyx/my-images/raw/master/image-20210918011807620.png)

**递归树如下：**

<img src="https://gitee.com/dadadaxyx/my-images/raw/master/image-20210918011838449.png" alt="image-20210918011838449" style="zoom:50%;" />

#### 2. 带备忘录的递归

```js
let memo;
function coinChange(coins, amount) {
    memo = Array(amount + 1).fill(-666)
	return dp(coins, amount)
}

function dp(coins, amount) {
    if(amount==0) return 0;
    if(amount<0) return -1;
    // 查看备忘录，防止重复计算
    if(memo[amount] != -666) return memo[amount]
    
    let res = Number.MAX_VALUE;
    for(let coin of coins) {
        let subProblem = dp(coins, amount-coin)// 计算子问题的结果
        if(subProblem==-1) continue; // 子问题无解则跳过
        res = Math.min(res, subProblem + 1)// 在子问题中选择最优解，然后加一
    }
    memo[amount] = (res == Number.MAX_VALUE) ? -1 : res; // 把结果存入备忘录
    return memo[amount];
}
```



#### 3. dp 数组的迭代解法

```js
function coinChange(coins, amount) {
    let dp = Array(amount+1).fill(amount+1)
    dp[0] = 0; // base case
    for(let i = 0; i < dp.length; i++) {// 外层 for 循环在遍历所有状态的所有取值
       	for(let coin of coins) { // 内层 for 循环在求所有选择的最小值
            if(i-coin<0) continue; // 子问题无解，跳过
            dp[i] = Math.min(dp[i], 1+dp[i-coin]) // 状态转移
        }
    }
    return (dp(amount==amount+1) ? -1 : dp[amount]) // 看看金额 amount 能不能凑出来
}
```

自底向上使用 dp table 来消除重叠子问题。`dp[i] = x` 表示，当目标金额为 i 时，至少需要 x 枚硬币。

<img src="https://gitee.com/dadadaxyx/my-images/raw/master/image-20210918134941870.png" alt="image-20210918134941870" style="zoom:50%;" />



## 总结

斐波那契数列问题，解释了如何通过备忘录或者 dp table 的方法来优化递归树，并明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。

凑零钱问题展示了如何流程化确定状态转移方程，只要通过状态转移方程写暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。

计算机解决问题其实就是穷举。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。列出状态转移方程其实就是在解决“如何穷举“的问题。而备忘录、dp table 就是在追求如何聪明地穷举。用空间换时间的思路，是降低时间复杂度的不二法门。



# 回溯算法

## 概念

**解决一个回溯问题，实际上就是一个决策树的遍历过程。**你需要思考三个问题：

1. **路径**，也就是已经做出的选择
2. **选择列表**，也就是你当前可以做的选择
3. **结束条件**，也就是到达决策树底层，无法再做选择的条件。

**回溯算法的框架**：

```txt
result = []
def backtrack(路径, 选择列表):
	if 满足结束条件:
		result.add(路径)
		return
    for 选择 in 选择列表:
    	做选择
    	backtrack(路径, 选择列表)
    	撤销选择
```

**其核心就是 for 循环里面的递归，在递归调用之前【做选择】，在递归调用之后【撤销选择】**



## 举例

### 全排列问题

穷举全排列，一般是一次选择一个记录，后面依此选择还没被选择的记录。

把每一次选择过程记为一条路径，即可把这次选择过程变化为一棵**决策树**。

![image-20210928184631418](https://gitee.com/dadadaxyx/my-images/raw/master/image-20210928184631418.png)

只要从根遍历这颗树，记录路径上的数字，其实就是所有的全排列。可把这棵树称为回溯算法的**决策树**——**在每个节点上其实都是在决策**。

在这其中，

**路径** 就是你已经做过的选择；
**选择列表** 就是你当前可以做出的选择；
**结束条件** 就是遍历到树的底层，即选择列表为空的时候。

这时候，可以把路径和选择列表作为决策树上**每个节点的属性**。

#### 如何遍历一棵树

```js
function traverse(root) {
    for(let child of root.children) {
        // 前序遍历需要的操作
        traverse(child)
        // 后序遍历需要的操作
    }
}
```

**注**：
**前序遍历**在代码**进入某一个节点之前**的那个时间点执行；
**后序遍历**在代码**离开某一个节点之后**的那个时间点执行。

回溯算法的核心思想也是如此：👇

```txt
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
```

我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确得到每个节点的选择列表和路径。



#### 代码

```js
let res = []

/* 主函数，输入一组不重复的数字，返回它们的全排列 */
function permute(nums) {
    // 记录「路径」
    let track = []
    backtrack(nums, track)
    return res
}

// 路径：记录在 track 中
// 选择列表：nums 中不存在于 track 的那些元素
// 结束条件：nums 中的元素全都在 track 中出现
function backtrack(nums, track) {
    // 触发结束条件
    if(track.length === nums.length) {
        res.push([...track])
        return
    }
    for(let i = 0; i < nums.length; i++) {
        // 排除不合法的选择
        if(track.includes(nums[i])) continue;
        // 做选择
        track.push(nums[i])
        // 进入下一层决策树
        backtrack(nums, track)
        // 取消选择
        track.pop()
    }
}
```

**穷举整棵决策树**是无法避免的，这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，**回溯算法就是纯暴力穷举**，复杂度一般都很高。



### N 皇后问题

给你一个 N*N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。

ps：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。

这个问题**本质**上跟全排列问题差不多，决策树的每一层表示棋盘的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。

```js
let res = []

/* 输入棋盘边长 n，返回所有合法的放置 */
function solveNQueens(int n) {
     // '.' 表示空，'Q' 表示皇后，初始化空棋盘。
    let board = []
    initBoard(board, n)
    backtrack(board, 0)
    return res
}

function initBoard(board, n) {
    let row = ['.','.','.','.','.','.','.','.']
    for(let i = 0; i < n; i++) {
        board[i] = []
    }
    for(let i = 0; i < n; i++) {
        board[i].push(...row)
    }
}

// 路径：board 中小于 row 的那些行都已经成功放置了皇后
// 选择列表：第 row 行的所有列都是放置皇后的选择
// 结束条件：row 超过 board 的最后一行
function backtrack(board, row) {
    // 触发结束条件
    if (row == board.length) {
        res.push([...board]);
        return;
    }

    int n = board[row].length;
    for (let col = 0; col < n; col++) {
        // 排除不合法选择
        if (!isValid(board, row, col)) 
            continue;
        // 做选择
        board[row][col] = 'Q';
        // 进入下一行决策
        backtrack(board, row + 1);
        // 撤销选择
        board[row][col] = '.';
    }
}

/* 是否可以在 board[row][col] 放置皇后？ */
function isValid(board, row, col) {
    let n = board.length
    // 检查列是否有皇后互相冲突
    for (let i = 0; i < n; i++) {
        if (board[i][col] == 'Q')
            return false;
    }
    // 检查右上方是否有皇后互相冲突
    for (let i = row - 1, j = col + 1; 
            i >= 0 && j < n; i--, j++) {
        if (board[i][j] == 'Q')
            return false;
    }
    // 检查左上方是否有皇后互相冲突
    for (let i = row - 1, j = col - 1;
            i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 'Q')
            return false;
    }
    return true;
}
```



## 总结

回溯算法其实就是多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作。

**写`backtrack`函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集**。

其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？

某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。



# BFS 算法

**DFS 算法其实就是回溯算法**。

BFS 的**核心思想**就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，BFS 算法都是用**【队列】**这种数据结构，每次将一个节点周围的所有节点加入队列。

BFS 相对 DFS 的最主要区别是：**BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多**。



## 算法框架

**问题的本质就是让你在一副图中找到起点 start 到终点 target 的最近距离，这个例子听起来很枯燥，但是 BFS 算法问题其实都是在干这个事**儿。

> 这个问题广义描述可以有各种变体：比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带【传送门】可以瞬间传送呢？
>
> 比如说两个单词，要求你通过替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？
>
> 比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。玩连连看，点击两个坐标，游戏如何判断它两的最短连线有几个拐点？

```js
const BFS = function(start, target) {
    let q = []; // 核心数据结构
    let visited = new Set(); // 避免走回头路，set 中的值是唯一的。
    
    q.push(start) // 将起点加入队列
    visited.add(start)
    let step = 0 // 记录扩散的步数
    
    while(q.length != 0) {
        let sz = q.length;
        // 将当前队列中的所有节点向四周扩散
        for(let i = 0; i < sz; i++) {
            let cur = q.shift();
            // 划重点：这里判断是否到达终点
            if(cur === target) return step;
            // 将 cur 的相邻节点加入队列
            for(let x of cur.adj) {
                if(!visited.has(x)) {
                    q.push(x)
                    visited.add(x)
                }
            }
        }
        // 划重点：更新步数在这里
        step++;
    }
}
```

队列`q`就不说了，BFS 的**核心数据结构**；`cur.adj()`泛指`cur`相邻的节点，比如说二维数组中，`cur`上下左右四面的位置就是相邻节点；`visited`的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要`visited`。



## 举例

### 二叉树的最小高度

判断一颗二叉树的最小高度，**最小高度**是从根节点到最近叶子节点的最短路径上的节点数量。

首先明确**起点** start 和**终点** target 是什么？怎么判断到达了终点？

起点是 root 根节点，终点就是靠近根节点的那个叶子节点。叶子节点就是两个子节点都是 null 的节点：

```js
if(cur.left == null && cur.right == null) // 到达叶子节点
```

改造上述框架：

```js
const minDepth(root) {
    if(root == null) return 0
    let q = []
    q.push(root)
    // root 本身就是一层，depth 初始化为 1
    let depth = 1
    while(q.length != 0) {
        // 将当前队列中的所有节点向四周扩散
        for(let i = 0; i < sz; i++) {
            let cur = q.shift()
            // 判断是否到达终点
            if(cur.left == null && cur.right == null)
                return depth;
            // 将 cur 的相邻节点加入队列
            if(cur.left != null)
                q.push(cur.left)
            if(cur.right != null)
                q.push(cur.right)
        }
        // 这里增加步数
        depth++;
    }
    return depth;
}
```

其他复杂问题都是这个框架的变形，在探讨复杂问题之前，我们解答两个问题：

1. 为什么 BFS 可以找到最短距离，DFS 不行吗？

   > 首先，你看 BFS 的逻辑，depth 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。
   >
   > DFS 不能找到最短路径吗？其实也是可以的，但是时间复杂度相对高很多。
   >
   > 你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有都探索完才能对比出最短路径有多长对不对？
   >
   > 而 BFS 借助队列做到一次一步【齐头并进】，是可以在不遍历完整棵树的条件下找到最短距离的。
   >
   > 形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。

2. 既然 BFS 那么好，为什么 DFS 还要存在？

   > **BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。**
   >
   > 还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点总数为`N`，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是`O(logN)`。
   >
   > 但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是`N/2`，用 Big O 表示的话也就是`O(N)`。
   >
   > 由此观之，BFS 还是有代价的，**一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些**（主要是递归代码好写）。



### 解开密码锁的最少次数

![image-20211011220618788](https://gitee.com/dadadaxyx/my-images/raw/master/image-20211011220618788.png)

**第一步，不管 deadends 和 target 的限制，就思考一个问题：如果让你设计一个算法，穷举所有可能的密码组合，你怎么做？**

穷举呗，再简单一点，如果你只转一下锁，有几种可能？总共有4个位置，每个位置可以向上转，也可以向下转，也就是有8种可能。

**仔细想想，这就可以抽象成一幅图，每个节点有8个相邻的节点**，又让你求最短距离，这不就是典型的 BFS 嘛。先写出一个 简陋 的 BFS 框架代码。

```js
// 将 s[j] 向上拨动一次
function plusOne(s, j) {
    let ch = s.split("")
    if(ch[j] == "9") ch[j] = "0"
    else ch[j] += 1
    return ch.join("")
}
// 将 s[j] 向下拨动一次
function minusOne(s, j) {
    let ch = s.split("")
    if(ch[j] == "0") ch[j] = "9"
    else ch[j] -= 1
    return ch.join("")
}
// BFS 框架，打印出所有可能的密码
const BFS = function(target) {
    let q = []
    q.push("0000")
    while(q.length != 0) {
        let sz = q.length;
        // 将当前队列中的所有节点向周围扩散
        for(let i = 0; i < sz; i++) {
            let cur = q.shift()
            // 判断是否到达终点
            console.log(cur)
            // 将一个节点的相邻节点加入队列
            for(let j = 0; j < 4; j++) {
                let up = plusOne(cur, j)
                let down = minusOne(cur, j)
                q.push(up)
                q.push(down)
            }
        }
        // 在这里增加步数
    }
    return;
}
```

**这段 BFS 代码已经能够穷举所有可能的密码组合了，但是显然不能完成题目，有如下问题需要解决**：

1、会走回头路。比如说我们从`"0000"`拨到`"1000"`，但是等从队列拿出`"1000"`时，还会拨出一个`"0000"`，这样的话会产生死循环。

2、没有终止条件，按照题目要求，我们找到`target`就应该结束并返回拨动的次数。

3、没有对`deadends`的处理，按道理这些「死亡密码」是不能出现的，也就是说你遇到这些密码的时候需要跳过。

接下来只要按照 BFS 框架在对应的位置稍作修改即可修复这些问题：

```js
const openLook(deadends, target) {
    // 记录需要跳过的死亡密码
    let deads = new Set()
    for(let s of deadends) deads.add(s)
    // 记录已经穷举过的密码，防止走回头路
    let visited = new Set()
    let q = []
    // 从起点开始启动广度优先搜索
    let step = 0
    q.push("0000")
    visited.add("0000")
    while(q.length != 0) {
        let sz = q.length
        // 将当前队列中的所有节点向周围扩散
        for(let i = 0; i < sz; i++) {
            let cur = q.shift()
            // 判断是否到达终点
            if(deads.has(cur)) continue
            if(cur === target) return step
            //  将一个节点的未遍历相邻节点加入队列
            for(let j = 0; j < 4; j++) {
                let up = plusOne(cur, j)
                if(!visited.has(up)) {
                    q.push(up)
                    visited.add(up)
                }
                let down = minusOne(cur, j)
                if(!visited.has(down)) {
                    q.push(down)
                    visited.add(down)
                }
            }
        }
        // 在这里增加步数
        step++;
    }
    // 如果穷举完都没有找到目标密码，那就是找不到了
    return -1
}
```



### 双向 BFS 优化

BFS 算法还有一种稍微高级一点的优化思路：**双向 BFS**，可以进一步提高算法的效率。

传统 BFS 与双向 BFS 的**区别**：<u>传统 BFS 框架就是从起点向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。</u>

为什么这样能够提高效率呢？其实从 Big O 表示法分析算法复杂度的话，它俩的最坏复杂度都是 O(N)，但是实际上双向 BFS 确实会快一些。

![image-20211012104050471](https://gitee.com/dadadaxyx/my-images/raw/master/image-20211012104050471.png)

![image-20211012104101459](https://gitee.com/dadadaxyx/my-images/raw/master/image-20211012104101459.png)

图示中的树形结构，如果终点在最底部，按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到`target`；而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。从这个例子可以直观地感受到，双向 BFS 是要比传统 BFS 高效的。

**不过，双向 BFS 也有局限，因为你必须知道终点在哪里**。比如我们刚才讨论的二叉树最小高度的问题，你一开始根本就不知道终点在哪里，也就无法使用双向 BFS；但是第二个密码锁的问题，是可以使用双向 BFS 算法来提高效率的，代码稍加修改即可：

```js
function openLock(deadends, target) {
    let deads = new Set()
    for(let s of deads) deads.add(s)
    // 用集合不用队列，可以快速判断元素是否存在
    let q1 = new Set()
    let q2 = new Set()
    let visited = new Set()
    
    let step = 0
    q1.add("0000")
    q2.add(target)
    
    while(q1.size != 0 && q2.size != 0) {
        // 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果
        let temp = new Set()
        // 将 q1 中的所有节点向周围扩散
        for(let cur of q1) {
            // 判断是否到达终点
            if(deads.has(cur)) continue;
            if(q2.has(cur)) return step;
            visited.add(cur)
            // 将一个节点的未遍历相邻节点加入集合
            for(let j = 0; j < 4; j++) {
                let up = plusOne(cur, j)
                if(!visited.has(up)) temp.add(up)
                let down = minusOne(cur, j)
                if(!visited.has(down)) temp.add(down)
            }
        }
        // 在这里增加步数
        step++
        // temp 相当于 q1
        // 这里交换 q1，q2，下一轮 while 就是 扩散 q2
        q1 = q2
        q2 = temp
    }
    return -1
}
```

双向 BFS 还是遵循 BFS 算法框架的，只是**不再使用队列，而是使用 HashSet 方便快速判断两个集合是否有交集**。

另外的一个技巧点就是 **while 循环的最后交换`q1`和`q2`的内容**，所以只要默认扩散`q1`就相当于轮流扩散`q1`和`q2`。

其实双向 BFS 还有一个优化，就是在 while 循环开始时做一个判断：

```js
// ...
while(q1.size != 0 && q2.size != 0) {
    if(q1.size > q2.size) {
        // 交换 q1 和 q2
        temp = q1
        q1 = q2
        q2 = temp
    }
    // ...
}
```

为什么这是一个优化呢？

因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。

不过话说回来，**无论传统 BFS 还是双向 BFS，无论做不做优化，从 Big O 衡量标准来看，空间复杂度都是一样的**，只能说双向 BFS 是一种 trick 吧，掌握不掌握其实都无所谓。最关键的是把 BFS 通用框架记下来，反正所有 BFS 算法都可以用它套出解法。
