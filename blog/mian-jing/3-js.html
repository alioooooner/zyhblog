<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS面试题 | zyhblog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/zyhblog/favicon.ico">
    <meta name="description" content="小白博客">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/zyhblog/assets/css/0.styles.4093e82c.css" as="style"><link rel="preload" href="/zyhblog/assets/js/app.f03e268b.js" as="script"><link rel="preload" href="/zyhblog/assets/js/3.bb78181b.js" as="script"><link rel="preload" href="/zyhblog/assets/js/1.d4860738.js" as="script"><link rel="preload" href="/zyhblog/assets/js/17.31483a01.js" as="script"><link rel="prefetch" href="/zyhblog/assets/js/10.fb5ec3d4.js"><link rel="prefetch" href="/zyhblog/assets/js/11.bfbf71ae.js"><link rel="prefetch" href="/zyhblog/assets/js/12.bfdf47c5.js"><link rel="prefetch" href="/zyhblog/assets/js/13.4424ca31.js"><link rel="prefetch" href="/zyhblog/assets/js/14.cd61eb09.js"><link rel="prefetch" href="/zyhblog/assets/js/15.bd9be96e.js"><link rel="prefetch" href="/zyhblog/assets/js/16.ed760204.js"><link rel="prefetch" href="/zyhblog/assets/js/18.1b46be75.js"><link rel="prefetch" href="/zyhblog/assets/js/19.ac239917.js"><link rel="prefetch" href="/zyhblog/assets/js/20.1a0a783a.js"><link rel="prefetch" href="/zyhblog/assets/js/21.e0cb8b85.js"><link rel="prefetch" href="/zyhblog/assets/js/22.500e1473.js"><link rel="prefetch" href="/zyhblog/assets/js/23.4013a191.js"><link rel="prefetch" href="/zyhblog/assets/js/4.3495396e.js"><link rel="prefetch" href="/zyhblog/assets/js/5.b9a7611e.js"><link rel="prefetch" href="/zyhblog/assets/js/6.6da6b982.js"><link rel="prefetch" href="/zyhblog/assets/js/7.d3cacb51.js"><link rel="prefetch" href="/zyhblog/assets/js/8.3f57e2b1.js"><link rel="prefetch" href="/zyhblog/assets/js/9.c3819867.js">
    <link rel="stylesheet" href="/zyhblog/assets/css/0.styles.4093e82c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>zyhblog</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>小白博客</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>zyh</span>
            
          <!---->
          2021
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zyhblog/" class="home-link router-link-active"><img src="/zyhblog/avatar.png" alt="zyhblog" class="logo"> <span class="site-name">zyhblog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zyhblog/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/zyhblog/categories/面经/" class="nav-link"><i class="undefined"></i>
  面经
</a></li></ul></div></div><div class="nav-item"><a href="/zyhblog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/zyhblog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><a href="https://github.com/alioooooner" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/zyhblog/avatar.png" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    zyh
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>13</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>1</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/zyhblog/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/zyhblog/categories/面经/" class="nav-link"><i class="undefined"></i>
  面经
</a></li></ul></div></div><div class="nav-item"><a href="/zyhblog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/zyhblog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><a href="https://github.com/alioooooner" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面经</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zyhblog/blog/mian-jing/1-css.html" class="sidebar-link">CSS面试题</a></li><li><a href="/zyhblog/blog/mian-jing/10-vue.html" class="sidebar-link">Vue-面试题</a></li><li><a href="/zyhblog/blog/mian-jing/11-vuexiang-mu-xing-neng-you-hua.html" class="sidebar-link">Vue项目性能优化-面试题</a></li><li><a href="/zyhblog/blog/mian-jing/12-suan-fa.html" class="sidebar-link">算法-面试题</a></li><li><a href="/zyhblog/blog/mian-jing/13-yi-wen.html" class="sidebar-link">疑问</a></li><li><a href="/zyhblog/blog/mian-jing/2-html.html" class="sidebar-link">HTML面试题</a></li><li><a href="/zyhblog/blog/mian-jing/3-js.html" aria-current="page" class="active sidebar-link">JS面试题</a></li><li><a href="/zyhblog/blog/mian-jing/4-xing-neng-you-hua.html" class="sidebar-link">性能优化</a></li><li><a href="/zyhblog/blog/mian-jing/5-qian-duan-gong-cheng-hua.html" class="sidebar-link">前端工程化面试题</a></li><li><a href="/zyhblog/blog/mian-jing/6-ji-suan-ji-wang-luo.html" class="sidebar-link">计算机网络面试题</a></li><li><a href="/zyhblog/blog/mian-jing/7-liu-lan-qi-yuan-li.html" class="sidebar-link">浏览器原理面试题</a></li><li><a href="/zyhblog/blog/mian-jing/8-shou-xie-dai-ma.html" class="sidebar-link">手写代码-面试题</a></li><li><a href="/zyhblog/blog/mian-jing/9-leetcode.html" class="sidebar-link">LeetCode-面试题</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>JS面试题</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>zyh</span>
            
          <!---->
          2021
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">JS面试题</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>zyh</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>11/11/2021</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>面试题</span></i></div></div> <div class="theme-reco-content content__default"><h1 id="一、数据类型"><a href="#一、数据类型" class="header-anchor">#</a> 一、数据类型</h1> <h2 id="_1-javascript-有哪些数据类型-它们的区别"><a href="#_1-javascript-有哪些数据类型-它们的区别" class="header-anchor">#</a> 1. JavaScript 有哪些数据类型，它们的区别？</h2> <p>JavaScript 是一门<strong>弱类型/动态</strong>语言。它变量的类型是<strong>在程序运行过程中自动被确定</strong>，这就意味着一个变量可以保存不同类型的数据。</p> <p>8种数据类型：</p> <ul><li>6 种<strong>原始类型</strong>，使用 typeof 运算符检查:
<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/undefined" target="_blank" rel="noopener noreferrer">undefined<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：<code>typeof instance === &quot;undefined&quot;</code></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean" target="_blank" rel="noopener noreferrer">Boolean<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：<code>typeof instance === &quot;boolean&quot;</code></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Number" target="_blank" rel="noopener noreferrer">Number<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：<code>typeof instance === &quot;number&quot;</code></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/String" target="_blank" rel="noopener noreferrer">String<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：<code>typeof instance === &quot;string</code></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt" target="_blank" rel="noopener noreferrer">BigInt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：<code>typeof instance === &quot;bigint&quot;</code></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol" target="_blank" rel="noopener noreferrer">Symbol<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ：<code>typeof instance === &quot;symbol&quot;</code></li></ul></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Null" target="_blank" rel="noopener noreferrer">null<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：<code>typeof instance === &quot;object&quot;</code>。</li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Object" target="_blank" rel="noopener noreferrer">Object<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：<code>typeof instance === &quot;object&quot;</code>。任何 constructed 对象实例的特殊非数据结构类型，也用做数据结构：new <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Object" target="_blank" rel="noopener noreferrer">Object<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，new <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/array" target="_blank" rel="noopener noreferrer">Array<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，new Map，new Set，new WeakMap，new WeakSet，new Date，和几乎所有通过 new keyword 创建的东西。</li></ul> <p>记住 <code>typeof</code> 操作符的<strong>唯一目的</strong>就是检查数据类型，如果我们希望检查任何从 Object 派生出来的结构类型，使用 <code>typeof</code> 是不起作用的，因为总是会得到 <code>&quot;object&quot;</code>。检查 Object 种类的合适方式是使用 instanceof 关键字。但即使这样也存在误差。</p> <ul><li>**引用类型：**Object、Function</li> <li>**基本数据类型：**undefined（未定义）、null（空对象）、boolean、number、string、bigint、symbol</li></ul> <p>为何将数据类型<strong>划分</strong>为基本数据类型和引用数据类型？这是因为它们在内存中的<strong>存储方式是不一样</strong>的。</p> <ul><li><strong>基本数据类型</strong>：占用空间小、空间大小固定，因此直接存放在<strong>栈</strong>中；</li> <li><strong>引用类型</strong>：占用空间大、空间大小不固定，如果频繁创建则会造成性能问题，所以将实体数据放在<strong>堆</strong>中，<strong>栈</strong>只记录该实体数据的起始地址。</li></ul> <h2 id="_2-数据类型检测的方式有哪些"><a href="#_2-数据类型检测的方式有哪些" class="header-anchor">#</a> 2. 数据类型检测的方式有哪些</h2> <ol><li><p><strong>typeof</strong></p> <ol><li>能够正确判断基本数据类型</li> <li>不易判断引用类型，数据、null、对象都会被判断为 object</li></ol></li> <li><p><strong>instanceof</strong></p> <ol><li>该运行原理为 <strong>右操作数的 prototype 是否出现在左操作数的原型链上</strong>。</li> <li><code>instanceof</code> <strong>只能正确判断引用数据类型</strong>，不能判断基本数据类型，这是和 typeof 的区别。</li></ol></li> <li><p><strong>Object.prototype.toString.call()</strong></p> <ol><li><p>使用 Object 对象的原型方法 toString 方法来判断数据类型</p></li> <li><blockquote><p>同样是检测对象 obj 调用 toString 方法，obj.toString() 的结果和Object.prototype.toString.call(obj) 的结果不一样，这是为什么？
因为 数组、函数等都作为 Object 的实例，都重写了 toString 方法，因此先调用了被重写的 toString 方法，而重写的方法返回的不是具体类型。</p></blockquote></li></ol></li> <li><p><strong><code>constructor</code></strong></p> <ol><li><p>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。</p></li> <li><p>需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor<span class="token operator">===</span>Fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor<span class="token operator">===</span>Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li></ol></li></ol> <h2 id="_3-判断数组的方式"><a href="#_3-判断数组的方式" class="header-anchor">#</a> 3. 判断数组的方式</h2> <ol><li>Object.prototype.toString.call()</li> <li>Array.isArray()</li> <li><code>arr.__proto__ === Array.prototype</code></li> <li>instanceof</li> <li>Array.prototype.isPrototypeOf</li> <li>constructor</li></ol> <h2 id="_4-null-和-undefined-的区别"><a href="#_4-null-和-undefined-的区别" class="header-anchor">#</a> 4. null 和 undefined 的区别</h2> <p>首先，它们是 JS 的两种基本数据类型。</p> <ul><li><strong>区别</strong>：undefined 的含义是已声明但未定义（未赋值），null 的含义是空值，希望一个对象被人为的重置未空对象。</li> <li>undefined 在 js 中不是保留字，即可以使用 undefined 作为一个变量名，这是危险的做法。我们可以通过一些方法获取 undefined 值，如 void 0</li> <li>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。</li> <li>当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</li></ul> <h2 id="_5-typeof-null-的结果是什么-为什么"><a href="#_5-typeof-null-的结果是什么-为什么" class="header-anchor">#</a> 5. typeof null 的结果是什么，为什么？</h2> <p>**结果是 **“object”</p> <p>第一版的JavaScript是用32位比特来存储值的，且是通过值的低1位或3位（也就是<strong>类型标记</strong>）来识别类型的。其中<strong>引用类型（object）的类型标记为 000，而 null 的低三位也是 000，所以误判 null 为 object</strong>。</p> <h2 id="_6-instanceof-操作符的实现原理及实现"><a href="#_6-instanceof-操作符的实现原理及实现" class="header-anchor">#</a> 6. instanceof 操作符的实现原理及实现</h2> <p>**作用：**判断该实例是否属于某种类型</p> <p>**实现原理：**查看右操作数的 prototype 是否在左操作数的原型链上</p> <p><strong>实现：</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">instance<span class="token punctuation">,</span> obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">===</span> obj<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        instance <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_7-为什么-0-1-0-2-0-3-如何让其相等"><a href="#_7-为什么-0-1-0-2-0-3-如何让其相等" class="header-anchor">#</a> 7. 为什么 0.1+0.2 !== 0.3，如何让其相等</h2> <p>计算机是通过二进制数的方式存储数据的，所以计算 0.1 + 0.2 的时候，实际上计算的是两个数的二进制的和。0.1 和 0.2 转换成二进制是一串无限循环的二进制数，所以 JS 会对该二进制数进行截取，最后的结果转换成十进制数字是 <code>0.30000000000000004</code>。</p> <p><strong>解决方法：</strong><code>(n1 + n2).toFixed(2)</code> 结果是 “0.30”</p> <h2 id="_8-如何获取安全的-undefined-值"><a href="#_8-如何获取安全的-undefined-值" class="header-anchor">#</a> 8. 如何获取安全的 undefined 值</h2> <p>因为 undefined 不是一个保留字，所以可以当作变量来使用和赋值，这会影响 undefined 的正常判断。获取方法：void 0。</p> <h2 id="_9-typeof-nan-的结果是什么"><a href="#_9-typeof-nan-的结果是什么" class="header-anchor">#</a> 9. typeof NaN 的结果是什么</h2> <p><code>typeof NaN</code>结果是“number”。</p> <ul><li>NaN 表示“不是一个数字”，通常会在一个数字和其他运算过程中产生。</li> <li>NaN 和任何变量都不想等，包括 NaN 自己。</li> <li>判断一个变量是不是 NaN 可以用 <code>isNaN()</code> 函数，ES6 中有更准确的方法 <code>Number.isNaN()</code></li></ul> <h2 id="_10-isnan-和-number-isnan-函数的区别"><a href="#_10-isnan-和-number-isnan-函数的区别" class="header-anchor">#</a> 10. isNaN 和 Number.isNaN 函数的区别</h2> <ul><li>函数 isNaN 接收参数后，<strong>会尝试将这个参数转换为数值</strong>，任何不能被转换为数值的的值（非数字值）都会返回 true，会影响 NaN 的判断。</li> <li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，<strong>不会进行数据类型的转换</strong>，这种方法对于 NaN 的判断更为准确。</li></ul> <h2 id="_11-操作符的强制类型转换规则"><a href="#_11-操作符的强制类型转换规则" class="header-anchor">#</a> 11. == 操作符的强制类型转换规则</h2> <ol><li><p>如果类型相同，调用 <code>===</code> 操作符</p></li> <li><p>如果类型不同，尝试类型转换</p> <ul><li><ol><li>查看是否是 <code>undefined</code> 和 <code>null</code> 比较</li></ol> <ul><li>✅ 返回 <code>true</code></li> <li>⬇️ 如果不是继续下一条规则</li></ul></li> <li><ol><li>是否在比较 <code>string</code> 和 <code>number</code></li></ol> <ul><li>✅ 如果是，那么将 <code>string</code> 转为 <code>number</code> 并回到最初重新比较 ♻️</li> <li>⬇️ 如果不是继续下一条规则</li></ul></li> <li><ol><li>查看我们比较的项中是否有 <code>boolean</code></li></ol> <ul><li>✅ 如果有，那么将 <code>boolean</code> 转为 <code>number</code> 并回到最初重新比较 ♻️</li> <li>⬇️ 如果不是继续下一条规则</li></ul></li> <li><ol><li>查看是否有一项是 <code>object</code></li></ol> <ul><li>✅ 如果有，那么将 <code>object</code> 转为其原始值 <code>primitive</code> 并回到最初重新比较 ♻️</li> <li>❌ 如果还不是，只能返回 <code>false</code> 了</li></ul></li></ul></li></ol> <p><img src="img/image-20210824232932567.png" alt="image-20210824232932567"></p> <h2 id="_12-获取对象原始值"><a href="#_12-获取对象原始值" class="header-anchor">#</a> 12. 获取对象原始值</h2> <blockquote><p>我们需要知道转换类型的这个方法在 JS 源代码中是 <code>ToPrimitive</code> 这个方法，该方法有一个可选参数 <code>PreferredType</code>，这个参数的作用是指定期望类型；如果第一个参数对应的对象可以被转换为不止一种类型，那么后者可以作为一种暗示，表示该对象应该转换为那种类型</p></blockquote> <ul><li>默认情况下（期望类型默认为 <code>number</code>）
<ul><li>调用 <code>valueOf</code> 方法：
<ul><li>✅ 如果返回的是原始值，那么就用这个</li> <li>⬇️ 如果返回的不是原始值，那么跳到下一步</li></ul></li> <li>调用 <code>toString</code> 方法：
<ul><li>✅ 如果返回的是原始值，那么就用这个</li> <li>❌ 否则报错?</li></ul></li></ul></li> <li>如果期望类型为 <code>string</code>：
<ul><li>调用 <code>toString</code> 方法：
<ul><li>✅ 如果返回的是原始值，那么就用这个</li> <li>⬇️ 如果返回的不是原始值，那么跳到下一步</li></ul></li> <li>调用 <code>valueOf</code> 方法：
<ul><li>✅ 如果返回的是原始值，那么就用这个</li> <li>❌ 否则报错?</li></ul></li></ul></li> <li>如果对象是 Date 类型（期望类型为 <code>string</code>）：
<ul><li>调用 <code>toString</code> 方法：
<ul><li>✅ 如果返回的是原始值，那么就用这个</li> <li>⬇️ 如果返回的不是原始值，那么跳到下一步</li></ul></li> <li>调用 <code>valueOf</code> 方法：
<ul><li>✅ 如果返回的是原始值，那么就用这个</li> <li>❌ 否则报错?</li></ul></li></ul></li></ul> <p>简单的说就是默认调用 <code>valueOf</code> 方法，然后是 <code>toString</code> 方法；如果对象是 <code>Date</code> 类型或对象的期望类型为 <code>string</code>，那么先调用 <code>toString</code> 方法</p> <p>例子：</p> <p><img src="img/image-20210824232735702.png" alt="image-20210824232735702"></p> <p>普通的对象，首先调用 valueOf 方法，返回的结果并非原始值，那么会调用 toString 方法</p> <p><img src="img/image-20210824232748839.png" alt="image-20210824232748839"></p> <p>假设我们重写 valueOf 方法，valueOf 和 toString 同时返回 string 原始值。使用 == 操作符可以看出，对象还是优先使用了 valueOf 方法返回的值</p> <p>数组同理，首先默认调用 valueOf 方法，如不是原始值，则调用 toString 方法</p> <p><img src="img/image-20210824232900614.png" alt="image-20210824232900614"></p> <p>再看看 Date 类型，他的期望类型是 string 因此首先调用的是 toString 方法，该方法返回一个原始值，那么就是用这个原始值</p> <h2 id="_13-其他类型转-number"><a href="#_13-其他类型转-number" class="header-anchor">#</a> 13. 其他类型转 number</h2> <p>下面我们来看看转换成 number 类型的规则：</p> <ol><li><code>undefined</code> ➡ <code>NaN</code>。 如果是 undefined 则直接转换成 NaN</li> <li><code>null</code> ➡<code>0</code> 。如果是 null 则转换成 0</li> <li><code>boolean</code> ➡<code>0/1</code> 。如果是 boolean 则转换成 0 或 1</li> <li><code>string</code> ➡ <code>0/NaN/(parse to number)</code> 。如果是 string 则转换成对应的 number，空字符串转换为 0，无法转换的则为 NaN</li> <li><code>object</code> 。 首先获取原始值然后再转为 number</li> <li><code>Symbol</code> 类型的值不能转换为数字，会报错。</li></ol> <h2 id="_14-其他类型转-string"><a href="#_14-其他类型转-string" class="header-anchor">#</a> 14. 其他类型转 string</h2> <ol><li><code>undefined</code> ➡<code>'undefined'</code>。</li> <li><code>null</code> ➡ <code>'null'</code>。</li> <li><code>number</code> ➡<code>'number'</code>。Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li> <li><code>boolean</code> ➡ <code>'true'/'false'</code></li> <li><code>object</code> ： 首先获取原始值，然后转为 string</li> <li><code>Symbol</code> 类型的值直接转换，但是只允许<strong>显式强制类型转换</strong>，使用隐式强制类型转换会产生错误。</li></ol> <h2 id="_15-转为-boolean"><a href="#_15-转为-boolean" class="header-anchor">#</a> 15. 转为 boolean</h2> <p>❌下面这些在 JS 中都为 falsy 除此之外的都是 truthy</p> <ol><li><code>undefined</code>  ➡falsy</li> <li><code>null</code> ➡ falsy</li> <li><code>0</code> ➡ falsy</li> <li><code>&quot;&quot;</code> ➡ falsy</li> <li><code>NaN</code> ➡ falsy</li> <li><code>false</code> ➡ falsy</li></ol> <h2 id="_16-和-操作符的返回值"><a href="#_16-和-操作符的返回值" class="header-anchor">#</a> 16. || 和 &amp;&amp; 操作符的返回值</h2> <p>|| 和 &amp;&amp; 两个操作符首先会对第一个操作数执行条件判断，如果不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p> <ul><li>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li> <li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li></ul> <p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p> <h2 id="_17-object-is-与比较操作符-、-的区别"><a href="#_17-object-is-与比较操作符-、-的区别" class="header-anchor">#</a> 17. Object.is() 与比较操作符“===”、“==”的区别</h2> <ul><li><code>==</code>两边的操作数如果类型不同，会进行类型转换，再进行比较；</li> <li><code>===</code>如果类型不同，则直接返回 false、如果相同则进行值比较；</li> <li>Object.is 类似于 <code>===</code>，但是在三等于号的基础，它多处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul> <h2 id="_18-什么是-javascript-中的包装类型"><a href="#_18-什么是-javascript-中的包装类型" class="header-anchor">#</a> 18. 什么是 JavaScript 中的包装类型</h2> <p><strong>为了便于操作基本数据类型的值</strong>，JavaScript 中的原始数据类型的值会在后台隐式地被包装为对象，从而引出了**基本包装类型（primitive wrapper type）**这个概念。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>
str<span class="token punctuation">.</span>length<span class="token punctuation">;</span>              <span class="token comment">// 11</span>
str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// HELLO WORLD</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们看到的代码是上面的样子，其实后台会自动完成下列的处理：</p> <ul><li>执行到第二行时：
<ul><li>创建 String 类型的一个实例；</li> <li>在实例上调用指定的<strong>属性</strong>；</li> <li>销毁这个实例；</li></ul></li> <li>执行到第三行时：
<ul><li>创建 String 类型的一个实例；</li> <li>在实例上调用指定的<strong>方法</strong>；</li> <li>销毁这个实例；</li></ul></li></ul> <p><strong>JavaScript也可以使用<code>Object</code>函数显式地将基本类型转换为包装类型：</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'abc'</span>
<span class="token function">Object</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// String {&quot;abc&quot;}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>也可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'abc'</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'abc'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_19-引用类型与基本包装类型的区别"><a href="#_19-引用类型与基本包装类型的区别" class="header-anchor">#</a> 19. 引用类型与基本包装类型的区别</h2> <p>引用类型与基本包装类型的<strong>主要区别就是对象的生存期。</strong></p> <blockquote><p>使用 <code>new</code> 操作符创建的引用类型的实例，在执行流离开当前作用域之前，会一直保存在<strong>堆内存</strong>中。而后台自动创建的基本包装类型的对象，则<strong>只存在一行代码的执行瞬间，然后立即被销毁</strong>。这意味着我们不能为基本类型的值添加属性和方法。</p></blockquote> <h2 id="_20-javascript-中如何进行隐式类型转换"><a href="#_20-javascript-中如何进行隐式类型转换" class="header-anchor">#</a> 20.  JavaScript 中如何进行隐式类型转换？</h2> <p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
* @obj 需要转换的对象
* @type 期望的结果类型
*/</span>
<span class="token function">ToPrimitive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>type<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p> <p><strong>（1）当<code>type</code>为<code>number</code>时规则如下：</strong></p> <ul><li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li> <li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li> <li>抛出<code>TypeError</code> 异常。</li></ul> <p><strong>（2）当<code>type</code>为<code>string</code>时规则如下：</strong></p> <ul><li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li> <li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li> <li>抛出<code>TypeError</code> 异常。</li></ul> <p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p> <ul><li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li> <li>其他情况下，<code>type</code>默认为<code>number</code>。</li></ul> <p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">objToNumber</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token function">Number</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">objToNumber</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span>
<span class="token function">objToNumber</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">NaN</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p> <p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p> <ol><li>+操作符<code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'23'</span> <span class="token comment">// '123'</span>
 <span class="token number">1</span> <span class="token operator">+</span> <span class="token boolean">false</span> <span class="token comment">// 1 </span>
 <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Uncaught TypeError: Cannot convert a Symbol value to a number</span>
 <span class="token string">'1'</span> <span class="token operator">+</span> <span class="token boolean">false</span> <span class="token comment">// '1false'</span>
 <span class="token boolean">false</span> <span class="token operator">+</span> <span class="token boolean">true</span> <span class="token comment">// 1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li>-、*、\操作符NaN也是一个数字</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span> <span class="token operator">*</span> <span class="token string">'23'</span> <span class="token comment">// 23</span>
 <span class="token number">1</span> <span class="token operator">*</span> <span class="token boolean">false</span> <span class="token comment">// 0</span>
 <span class="token number">1</span> <span class="token operator">/</span> <span class="token string">'aa'</span> <span class="token comment">// NaN</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="3"><li>对于**<code>==</code>**操作符</li></ol> <p>操作符两边的值都尽量转成<code>number</code>：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">3</span> <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token comment">// false, 3 转为number为3，true转为number为1</span>
<span class="token string">'0'</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token comment">//true, '0'转为number为0，false转为number为0</span>
<span class="token string">'0'</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token comment">// '0'转为number为0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="4"><li>对于<code>&lt;</code>和<code>&gt;</code>比较符</li></ol> <p>如果两边都是字符串，则比较字母表顺序：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token string">'ca'</span> <span class="token operator">&lt;</span> <span class="token string">'bd'</span> <span class="token comment">// false</span>
<span class="token string">'a'</span> <span class="token operator">&lt;</span> <span class="token string">'b'</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>其他情况下，转换为数字再比较：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token string">'12'</span> <span class="token operator">&lt;</span> <span class="token number">13</span> <span class="token comment">// true</span>
<span class="token boolean">false</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
a <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>其对比过程如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>a<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// {}, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span>
a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Object]&quot;，现在是一个字符串了</span>
<span class="token function">Number</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span>
<span class="token number">NaN</span> <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token comment">//false，得出比较结果</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>又比如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'Jack'</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span>age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">}</span>
a <span class="token operator">+</span> b <span class="token comment">// &quot;[object Object][object Object]&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>运算过程如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>a<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// {}，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span>
a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Object]&quot;</span>
b<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 同理</span>
b<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;[object Object]&quot;</span>
a <span class="token operator">+</span> b <span class="token comment">// &quot;[object Object][object Object]&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_21-操作符什么时候用于字符串的拼接"><a href="#_21-操作符什么时候用于字符串的拼接" class="header-anchor">#</a> 21. <code>+</code> 操作符什么时候用于字符串的拼接？</h2> <p>根据 ES5 规范，<strong>如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作</strong>。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p> <p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p> <p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p> <p><strong>注意：</strong></p> <p>为什么在不同环境 <code>{} + []</code> 下情况不同，有的是0，有的是“[object Object]&quot;。因为有的环境把 {} 视为区块语句，而有的环境把 {} 视为字面量。</p> <h2 id="_22-object-assign和扩展运算法是深拷贝还是浅拷贝-两者区别"><a href="#_22-object-assign和扩展运算法是深拷贝还是浅拷贝-两者区别" class="header-anchor">#</a> 22. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h2> <p>扩展运算符：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> outObj <span class="token operator">=</span> <span class="token punctuation">{</span>
  inObj<span class="token operator">:</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>outObj<span class="token punctuation">}</span>
newObj<span class="token punctuation">.</span>inObj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outObj<span class="token punctuation">)</span> <span class="token comment">// {inObj: {a: 2, b: 2}}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Object.assign():</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> outObj <span class="token operator">=</span> <span class="token punctuation">{</span>
  inObj<span class="token operator">:</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> newObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> outObj<span class="token punctuation">)</span>
newObj<span class="token punctuation">.</span>inObj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outObj<span class="token punctuation">)</span> <span class="token comment">// {inObj: {a: 2, b: 2}}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h1 id="二、es6"><a href="#二、es6" class="header-anchor">#</a> 二、ES6</h1> <h2 id="_1-let-const-var-的区别"><a href="#_1-let-const-var-的区别" class="header-anchor">#</a> 1. let const var 的区别</h2> <ol><li><strong>作用域</strong>，使用 var 声明的变量，其作用域为该语句所在的函数内；使用 let、const 声明的变量，其作用域为该语句所在的代码块内。</li> <li><strong>变量提升</strong>，var 声明的变量会变量提升，let、const 不会。</li> <li><strong>给全局添加属性</strong>，var 在全局作用域声明的变量会称为全局对象的属性。</li> <li><strong>重复声明</strong>，var 允许变量重复声明，后面的同名变量会覆盖前面的；let、const 不会。</li> <li><strong>暂时性死区</strong>，在 let、const 声明的变量语句前，该变量不可用；var 声明的变量可以。</li> <li><strong>初始值设置</strong>，var 和 let 在声明变量的时候可以不设置初始值，const 必须设置。</li> <li><strong>指针指向</strong>，var 和 let 声明的是变量，所存储的值可以修改；const 声明的是常量，存储的地址值不可以修改，但是地址值指向的具体数据可以修改。</li></ol> <h2 id="_2-const-对象的属性可以修改吗"><a href="#_2-const-对象的属性可以修改吗" class="header-anchor">#</a> 2. const 对象的属性可以修改吗？</h2> <p>const保证的并不是变量的值不能改动，而是<strong>变量指向的那个内存地址不能改动</strong>。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p> <p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，<strong>const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了</strong>。</p> <h2 id="_3-如果-new-一个箭头函数会怎么样"><a href="#_3-如果-new-一个箭头函数会怎么样" class="header-anchor">#</a> 3. 如果 new 一个箭头函数会怎么样？</h2> <p>箭头函数是ES6中的提出来的，它<strong>没有prototype</strong>，也<strong>没有自己的this指向</strong>，<strong>更不可以使用arguments参数</strong>，所以不能New一个箭头函数。</p> <p><strong>在调用 new 的过程中会发生以上四件事情：</strong></p> <ol><li>首先创建了一个新的空对象</li> <li>设置原型，将对象的原型设置为函数的 prototype 对象</li> <li>让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li> <li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol> <p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p> <h2 id="_4-箭头函数与普通函数的区别"><a href="#_4-箭头函数与普通函数的区别" class="header-anchor">#</a> 4. 箭头函数与普通函数的区别</h2> <ol><li><p><strong>箭头函数比普通函数更加简洁</strong></p> <ol><li><p>如果没有参数，就直接写一个空括号即可</p></li> <li><p>如果只有一个参数，可以省去参数的括号</p></li> <li><p>如果有多个参数，用逗号分割</p></li> <li><p>如果函数体的返回值只有一句，可以省略大括号如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token function">doesNotReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol></li> <li><p><strong>箭头函数没有自己的 this</strong></p> <p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以<strong>箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</strong></p></li> <li><p><strong>箭头函数继承来的 this 永远不会改变</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> id <span class="token operator">=</span> <span class="token string">'GLOBAL'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token string">'OBJ'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 'OBJ'</span>
obj<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 'GLOBAL'</span>
<span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// undefined</span>
<span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Uncaught TypeError: obj.b is not a constructor</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>{}</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p></li> <li><p><strong>call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> id <span class="token operator">=</span> <span class="token string">'Global'</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">fun1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 'Global'</span>
<span class="token function">fun1</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span>id<span class="token operator">:</span> <span class="token string">'Obj'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 'Global'</span>
<span class="token function">fun1</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">{</span>id<span class="token operator">:</span> <span class="token string">'Obj'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 'Global'</span>
<span class="token function">fun1</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">{</span>id<span class="token operator">:</span> <span class="token string">'Obj'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 'Global'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p><strong>箭头函数不能作为构造函数使用</strong></p> <p>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p></li> <li><p><strong>箭头函数没有自己的arguments</strong></p> <p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p></li> <li><p><strong>箭头函数没有prototype</strong></p></li> <li><p><strong>箭头函数不能用作Generator函数，不能使用yeild关键字</strong></p></li></ol> <h2 id="_5-箭头函数的-this-指向哪里"><a href="#_5-箭头函数的-this-指向哪里" class="header-anchor">#</a> 5. 箭头函数的 this 指向哪里？</h2> <p>箭头函数不同于传统JavaScript中的函数，<strong>箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值</strong>，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p> <p>可以⽤Babel理解⼀下箭头函数:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// ES6 </span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> 
  <span class="token function">getArrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>转化后：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// ES5，由 Babel 转译</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> 
   <span class="token function-variable function">getArrow</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">getArrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
     <span class="token keyword">var</span> _this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> 
     <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_this <span class="token operator">===</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token punctuation">}</span><span class="token punctuation">;</span> 
   <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_6-扩展运算符的作用以及使用场景"><a href="#_6-扩展运算符的作用以及使用场景" class="header-anchor">#</a> 6. 扩展运算符的作用以及使用场景</h2> <p><strong>（1）对象扩展运算符</strong></p> <p>对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> baz <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>bar <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// { a: 1, b: 2 }</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上述方法实际上等价于:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> baz <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { a: 1, b: 2 }</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p> <p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> baz <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>bar<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">{</span>a<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// {a: 2, b: 4}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p> <p>需要注意：<strong>扩展运算符对对象实例的拷贝属于浅拷贝</strong>。</p> <p><strong>（2）数组扩展运算符</strong></p> <p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 1 2 3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 1 [2, 3, 4] 5</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>下面是数组的扩展运算符的应用：</p> <ul><li><strong>将数组转换为参数序列</strong></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>numbers<span class="token punctuation">)</span> <span class="token comment">// 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><strong>复制数组</strong></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr1<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><strong>合并数组</strong></li></ul> <p>如果想在数组内合并数组，可以这样：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token operator">...</span>arr1<span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">,</span> <span class="token string">'five'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
first <span class="token comment">// 1</span>
rest  <span class="token comment">// [2, 3, 4, 5]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token operator">...</span>rest<span class="token punctuation">,</span> last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// 报错</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">,</span> last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 报错</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><strong>将字符串转为真正的数组</strong></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token operator">...</span><span class="token string">'hello'</span><span class="token punctuation">]</span>    <span class="token comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li></ul> <p>比较常见的应用是可以将某些数据结构转为数组：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// arguments对象</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p> <ul><li><strong>使用<code>Math</code>函数获取数组中特定的值</strong></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 9</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_7-proxy-可以实现什么功能"><a href="#_7-proxy-可以实现什么功能" class="header-anchor">#</a> 7. Proxy 可以实现什么功能？</h2> <p>在 Vue3.0 中通过 <code>Proxy</code> 来替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。</p> <p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 <code>set</code> 或者 <code>get</code> 函数。</p> <p>下面来通过 <code>Proxy</code> 来实现一个数据响应式：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">onWatch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> setBind<span class="token punctuation">,</span> getLogger</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">getLogger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">)</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setBind</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> property<span class="token punctuation">)</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token function">onWatch</span><span class="token punctuation">(</span>
  obj<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> property</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">监听到属性</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>property<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">改变为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>v<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> property</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">'</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>property<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">' = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>target<span class="token punctuation">[</span>property<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
p<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// 监听到属性a改变</span>
p<span class="token punctuation">.</span>a <span class="token comment">// 'a' = 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>在上述代码中，通过自定义 <code>set</code> 和 <code>get</code> 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p> <p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 <code>get</code> 中收集依赖，在 <code>set</code> 派发更新，之所以 Vue3.0 要使用 <code>Proxy</code> 替换原本的 API 原因在于 <code>Proxy</code> 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 <code>Proxy</code> 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。</p> <h2 id="_8-对对象与数组解构的理解"><a href="#_8-对对象与数组解构的理解" class="header-anchor">#</a> 8. 对对象与数组解构的理解</h2> <p>在解构数组时，以<strong>元素的位置为匹配条件</strong>来提取想要的数据的：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：</p> <img src="img/image-20210825145812072.png" alt="image-20210825145812072" style="zoom:33%;"> <p>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span><span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：</p> <img src="img/image-20210825145832136.png" alt="image-20210825145832136" style="zoom:33%;"> <p><strong>2）对象的解构</strong></p> <p>对象解构比数组结构稍微复杂一些，也更显强大。在<strong>解构对象时，是以属性的名称为匹配条件</strong>，来提取想要的数据的。现在定义一个对象：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> stu <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">24</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>假如想要解构它的两个自有属性，可以这样：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> age <span class="token punctuation">}</span> <span class="token operator">=</span> stu
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样就得到了 name 和 age 两个和 stu 平级的变量：</p> <img src="img/image-20210825145900756.png" alt="image-20210825145900756" style="zoom:33%;"> <p>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> age<span class="token punctuation">,</span> name <span class="token punctuation">}</span> <span class="token operator">=</span> stu
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_9-如何提取高度嵌套的对象里的指定属性"><a href="#_9-如何提取高度嵌套的对象里的指定属性" class="header-anchor">#</a> 9. 如何提取高度嵌套的对象里的指定属性？</h2> <p>有时会遇到一些嵌套程度非常深的对象：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> school <span class="token operator">=</span> <span class="token punctuation">{</span>
   classes<span class="token operator">:</span> <span class="token punctuation">{</span>
      stu<span class="token operator">:</span> <span class="token punctuation">{</span>
         name<span class="token operator">:</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span>
         age<span class="token operator">:</span> <span class="token number">24</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token operator">=</span> school
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> classes <span class="token punctuation">}</span> <span class="token operator">=</span> school
<span class="token keyword">const</span> <span class="token punctuation">{</span> stu <span class="token punctuation">}</span> <span class="token operator">=</span> classes
<span class="token keyword">const</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token operator">=</span> stu
name <span class="token comment">// 'Bob'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> classes<span class="token operator">:</span> <span class="token punctuation">{</span> stu<span class="token operator">:</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span> school
       
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>  <span class="token comment">// 'Bob'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以在解构出来的变量名右侧，通过**冒号+{目标属性名}**这种形式，进一步解构它，一直解构到拿到目标数据为止。</p> <h2 id="_10-对-rest-参数的理解"><a href="#_10-对-rest-参数的理解" class="header-anchor">#</a> 10. 对 rest 参数的理解</h2> <p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mutiple</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> val <span class="token keyword">of</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">*=</span> val<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">mutiple</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// 24</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mutiple</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">mutiple</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// [1, 2, 3, 4]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p> <h2 id="_11-es6中模板语法与字符串处理"><a href="#_11-es6中模板语法与字符串处理" class="header-anchor">#</a> 11. ES6中模板语法与字符串处理</h2> <p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'css'</span>   
<span class="token keyword">var</span> career <span class="token operator">=</span> <span class="token string">'coder'</span> 
<span class="token keyword">var</span> hobby <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'coding'</span><span class="token punctuation">,</span> <span class="token string">'writing'</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> finalString <span class="token operator">=</span> <span class="token string">'my name is '</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">', I work as a '</span> <span class="token operator">+</span> career <span class="token operator">+</span> <span class="token string">', I love '</span> <span class="token operator">+</span> hobby<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">' and '</span> <span class="token operator">+</span> hobby<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'css'</span>   
<span class="token keyword">var</span> career <span class="token operator">=</span> <span class="token string">'coder'</span> 
<span class="token keyword">var</span> hobby <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'coding'</span><span class="token punctuation">,</span> <span class="token string">'writing'</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> finalString <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, I work as a </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>career<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> I love </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hobby<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hobby<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的<strong>第一个优势——允许用${}的方式嵌入变量</strong>。但这还不是问题的关键，模板字符串的关键优势有两个：</p> <ul><li><strong>在模板字符串中，空格、缩进、换行都会被保留</strong></li> <li><strong>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</strong></li></ul> <p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> list <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;ul&gt;
        &lt;li&gt;列表项1&lt;/li&gt;
        &lt;li&gt;列表项2&lt;/li&gt;
    &lt;/ul&gt;
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确输出，不存在报错</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> finalString <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>a<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> + </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>b<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>a<span class="token operator">+</span>b<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>finalString<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 输出 '1 + 2 = 3'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p> <ul><li><p><strong>存在性判定</strong>：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p> <ul><li><strong>includes</strong>：判断字符串与子串的包含关系：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> son <span class="token operator">=</span> <span class="token string">'haha'</span> 
<span class="token keyword">const</span> father <span class="token operator">=</span> <span class="token string">'xixi haha hehe'</span>
father<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>son<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><strong>startsWith</strong>：判断字符串是否以某个/某串字符开头：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> father <span class="token operator">=</span> <span class="token string">'xixi haha hehe'</span>
father<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'haha'</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
father<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'xixi'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><strong>endsWith</strong>：判断字符串是否以某个/某串字符结尾：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> father <span class="token operator">=</span> <span class="token string">'xixi haha hehe'</span>
  father<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">'hehe'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p><strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</p></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> sourceCode <span class="token operator">=</span> <span class="token string">'repeat for 3 times;'</span>
<span class="token keyword">const</span> repeated <span class="token operator">=</span> sourceCode<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>repeated<span class="token punctuation">)</span> <span class="token comment">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h1 id="三、-javascript-基础"><a href="#三、-javascript-基础" class="header-anchor">#</a> 三、 JavaScript 基础</h1> <h2 id="_1-new-操作符的实现原理"><a href="#_1-new-操作符的实现原理" class="header-anchor">#</a> 1. new 操作符的实现原理</h2> <p><strong>new操作符的执行过程：</strong></p> <p>（1）首先创建了一个新的空对象</p> <p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p> <p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p> <p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>res <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> res
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_2-map和object的区别"><a href="#_2-map和object的区别" class="header-anchor">#</a> 2. map和Object的区别</h2> <table><thead><tr><th></th> <th>Map</th> <th>Object</th></tr></thead> <tbody><tr><td>意外的键</td> <td>Map默认情况不包含任何键，只包含显式插入的键。</td> <td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td></tr> <tr><td>键的类型</td> <td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td> <td>Object 的键必须是整数、 String 或是Symbol。</td></tr> <tr><td>键的顺序</td> <td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td> <td>Object 的键是无序的</td></tr> <tr><td>Size</td> <td>Map 的键值对个数可以轻易地通过size 属性获取</td> <td>Object 的键值对个数只能手动计算</td></tr> <tr><td>迭代</td> <td>Map 是 iterable 的，所以可以直接被迭代。</td> <td>迭代Object需要以某种方式获取它的键然后才能迭代。</td></tr> <tr><td>性能</td> <td>在频繁增删键值对的场景下表现更好。</td> <td>在频繁添加和删除键值对的场景下未作出优化。</td></tr> <tr><td>同名碰撞</td> <td>Map 的键存的是内存的地址，只要地址不一样，就是两个不同的键，允许键同名</td> <td>不允许</td></tr></tbody></table> <h2 id="_3-map和weakmap的区别"><a href="#_3-map和weakmap的区别" class="header-anchor">#</a> 3. map和weakMap的区别</h2> <p><strong>（1）Map</strong></p> <p><strong>map本质上就是键值对的集合</strong>，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，<strong>但是它的键不限制范围，可以是任意类型</strong>，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。</p> <p><strong>实际上Map是一个数组，它的每一个数据也都是一个数组</strong>，其形式如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">[</span>
     <span class="token punctuation">[</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;张三&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
     <span class="token punctuation">[</span><span class="token string">&quot;age&quot;</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Map数据结构有以下操作方法：</p> <ul><li><strong>size</strong>： <code>map.size</code> 返回Map结构的成员总数。</li> <li><strong>set(key,value)</strong>：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li> <li><strong>get(key)</strong>：该方法读取key对应的键值，如果找不到key，返回undefined。</li> <li><strong>has(key)</strong>：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li> <li><strong>delete(key)</strong>：该方法删除某个键，返回true，如果删除失败，返回false。</li> <li><strong>clear()</strong>：map.clear()清除所有成员，没有返回值。</li></ul> <p>Map结构原生提供是三个遍历器生成函数和一个遍历方法</p> <ul><li>keys()：返回键名的遍历器。</li> <li>values()：返回键值的遍历器。</li> <li>entries()：返回所有成员的遍历器。</li> <li>forEach()：遍历Map的所有成员。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
     <span class="token punctuation">[</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
     <span class="token punctuation">[</span><span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> map<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// foo bar</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 2</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> items <span class="token keyword">of</span> map<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [&quot;foo&quot;,1]  [&quot;bar&quot;,2]</span>
<span class="token punctuation">}</span>
map<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>key<span class="token punctuation">,</span>map</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo 1    bar 2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>（2）WeakMap</strong></p> <p>WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。<strong>其键必须是对象</strong>，原始数据类型不能作为key值，而值可以是任意的。</p> <p>该对象也有以下几种方法：</p> <ul><li><strong>set(key,value)</strong>：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li> <li><strong>get(key)</strong>：该方法读取key对应的键值，如果找不到key，返回undefined。</li> <li><strong>has(key)</strong>：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li> <li><strong>delete(key)</strong>：该方法删除某个键，返回true，如果删除失败，返回false。</li></ul> <p>其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。</p> <p>WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。</p> <p>而WeakMap的<strong>键名所引用的对象都是弱引用</strong>，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的<strong>键名对象和所对应的键值对会自动消失，不用手动删除引用</strong>。</p> <p><strong>总结：</strong></p> <ul><li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li> <li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul> <h2 id="_4-javascript-有哪些内置对象"><a href="#_4-javascript-有哪些内置对象" class="header-anchor">#</a> 4. JavaScript 有哪些内置对象</h2> <p>全局的对象（<code>global objects</code>）或称标准内置对象，不要和 &quot;全局对象（<code>global object</code>）&quot; 混淆。这里说的全局的对象是说在
全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p> <p>标准内置对象的分类</p> <p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</p> <p>例如 <code>Infinity</code>、<code>NaN</code>、<code>undefined</code>、<code>null</code> 字面量</p> <p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</p> <p>例如 <code>eval()</code>、<code>parseFloat()</code>、<code>parseInt()</code> 等</p> <p>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</p> <p>例如 <code>Object</code>、<code>Function</code>、<code>Boolean</code>、<code>Symbol</code>、<code>Error</code> 等</p> <p>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</p> <p>例如 <code>Number</code>、<code>Math</code>、<code>Date</code></p> <p>（5）字符串，用来表示和操作字符串的对象。</p> <p>例如 <code>String</code>、<code>RegExp</code></p> <p>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 <code>Array</code></p> <p>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</p> <p>例如 <code>Map</code>、<code>Set</code>、<code>WeakMap</code>、<code>WeakSet</code></p> <p>（8）矢量集合，<code>SIMD</code> 矢量集合中的数据会被组织为一个数据序列。</p> <p>例如 <code>SIMD</code> 等</p> <p>（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</p> <p>例如 <code>JSON</code> 等</p> <p>（10）控制抽象对象</p> <p>例如 <code>Promise</code>、<code>Generator</code> 等</p> <p>（11）反射</p> <p>例如 <code>Reflect</code>、<code>Proxy</code></p> <p>（12）国际化，为了支持多语言处理而加入 <code>ECMAScript</code> 的对象。</p> <p>例如 <code>Intl</code>、<code>Intl.Collator</code> 等</p> <p>（13）<code>WebAssembly</code></p> <p>（14）其他</p> <p>例如 <code>arguments</code></p> <p><strong>回答：</strong></p> <p>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。</p> <p>一般我们经常用到的如全局变量值 <code>NaN</code>、<code>undefined</code>，全局函数如 <code>parseInt()</code>、<code>parseFloat()</code> 用来实例化对象的构造函数如 <code>Date</code>、<code>Object</code> 等，还有提供数学计算的单体内置对象如 <code>Math</code> 对象。</p> <p><strong>详细资料可以参考：</strong></p> <ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener noreferrer">《标准内置对象的分类》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://segmentfault.com/a/1190000011467723#articleHeader24" target="_blank" rel="noopener noreferrer">《JS 所有内置对象属性和方法汇总》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="_5-常用的正则表达式有哪些"><a href="#_5-常用的正则表达式有哪些" class="header-anchor">#</a> 5. 常用的正则表达式有哪些？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// （1）匹配 16 进制颜色值</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>

<span class="token comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>

<span class="token comment">// （3）匹配 qq 号</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[1-9][0-9]{4,10}$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>

<span class="token comment">// （4）手机号码正则</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^1[34578]\d{9}$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>

<span class="token comment">// （5）用户名正则</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[a-zA-Z\$][a-zA-Z0-9_\$]{4,16}$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_6-对-json-的理解"><a href="#_6-对-json-的理解" class="header-anchor">#</a> 6. 对 JSON 的理解</h2> <p><strong>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</strong></p> <p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为</p> <p>JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p> <p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p> <p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p> <ul><li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li> <li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li></ul> <h2 id="_7-javascript-脚本延迟加载的方式有哪些"><a href="#_7-javascript-脚本延迟加载的方式有哪些" class="header-anchor">#</a> 7. JavaScript 脚本延迟加载的方式有哪些？</h2> <p>js实现延迟加载的几种方法，js的延迟加载有助与提高页面的加载速度</p> <p>JS延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。</p> <p>一般有以下几种方式：</p> <ul><li>**defer 属性：**给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li> <li>**async 属性：**给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li> <li>**动态创建 DOM 方式：**动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li> <li>**使用 setTimeout 延迟方法：**设置一个定时器来延迟加载js脚本文件</li> <li>**让 JS 最后加载：**将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li></ul> <h2 id="_8-javascript-类数组对象的定义"><a href="#_8-javascript-类数组对象的定义" class="header-anchor">#</a> 8. JavaScript 类数组对象的定义</h2> <p>所谓类数组对象，就是指可以<strong>通过索引属性访问元素</strong>并且<strong>拥有 length</strong> 属性的对象。</p> <p>一个简单的类数组对象是长这样的</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> arrLike <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token operator">:</span> <span class="token string">'name'</span><span class="token punctuation">,</span>
  <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'age'</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token operator">:</span> <span class="token string">'job'</span><span class="token punctuation">,</span>
  length<span class="token operator">:</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>而它所对应的数组应该是这样子的</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token string">'job'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>我们说类数组对象与数组的性质相似，是因为类数组对象在<strong>访问</strong>、<strong>赋值</strong>、<strong>获取长度</strong>上的操作与数组是一致的。<strong>常见的类数组对象</strong>有 arguments 和 DOM 方法的返回结果。</p> <p><strong>常见的类数组转换为数组的方法有这样几种：</strong></p> <p>（1）通过 call 调用数组的 slice 方法来实现转换</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>（2）通过 call 调用数组的 splice 方法来实现转换</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>（4）通过 Array.from 方法来实现转换</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_9-数组有哪些原生方法"><a href="#_9-数组有哪些原生方法" class="header-anchor">#</a> 9. 数组有哪些原生方法？</h2> <ul><li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li> <li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li> <li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li> <li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li> <li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li> <li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li> <li>数组归并方法 reduce() 和 reduceRight() 方法</li></ul> <h2 id="_10-unicode、utf-8、utf-16、utf-32的区别"><a href="#_10-unicode、utf-8、utf-16、utf-32的区别" class="header-anchor">#</a> 10. Unicode、UTF-8、UTF-16、UTF-32的区别？</h2> <h3 id="_1-unicode"><a href="#_1-unicode" class="header-anchor">#</a> （1）Unicode</h3> <p>在说<code>Unicode</code>之前需要先了解一下<code>ASCII</code>码：ASCII 码（<code>American Standard Code for Information Interchange</code>）称为美国标准信息交换码。</p> <ul><li>它是基于拉丁字母的一套电脑编码系统。</li> <li>它定义了一个用于代表常见字符的字典。</li> <li>它包含了&quot;A-Z&quot;(包含大小写)，数据&quot;0-9&quot; 以及一些常见的符号。</li> <li>它是专门为英语而设计的，有128个编码，对其他语言无能为力</li></ul> <p><code>ASCII</code>码可以表示的编码有限，要想表示其他语言的编码，还是要使用<code>Unicode</code>来表示，可以说<code>Unicode</code>是<code>ASCII</code> 的超集。</p> <p><code>Unicode</code>全称 <code>Unicode Translation Format</code>，又叫做统一码、万国码、单一码。<code>Unicode</code> 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p> <p><code>Unicode</code>的实现方式（也就是编码方式）有很多种，常见的是<strong>UTF-8</strong>、<strong>UTF-16</strong>、<strong>UTF-32</strong>和<strong>USC-2</strong>。</p> <h3 id="_2-utf-8"><a href="#_2-utf-8" class="header-anchor">#</a> （2）UTF-8</h3> <p><code>UTF-8</code>是使用最广泛的<code>Unicode</code>编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容<code>ASCII</code>码的128个字符。</p> <p><strong>注意：</strong> <code>UTF-8</code> 是一种编码方式，<code>Unicode</code>是一个字符集合。</p> <p><code>UTF-8</code>的编码规则：</p> <ul><li>对于<strong>单字节</strong>的符号，字节的第一位为0，后面的7位为这个字符的<code>Unicode</code>编码，因此对于英文字母，它的<code>Unicode</code>编码和<code>ACSII</code>编码一样。</li> <li>对于<strong>n字节</strong>的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的<code>Unicode</code>码 。</li></ul> <p>来看一下具体的<code>Unicode</code>编号范围与对应的<code>UTF-8</code>二进制格式 ：</p> <table><thead><tr><th>编码范围（编号对应的十进制数）</th> <th>二进制格式</th></tr></thead> <tbody><tr><td>0x00—0x7F （0-127）</td> <td>0xxxxxxx</td></tr> <tr><td>0x80—0x7FF （128-2047）</td> <td>110xxxxx 10xxxxxx</td></tr> <tr><td>0x800—0xFFFF  （2048-65535）</td> <td>1110xxxx 10xxxxxx 10xxxxxx</td></tr> <tr><td>0x10000—0x10FFFF  （65536以上）</td> <td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table> <p>那该如何通过具体的<code>Unicode</code>编码，进行具体的<code>UTF-8</code>编码呢？<strong>步骤如下：</strong></p> <ul><li>找到该<code>Unicode</code>编码的所在的编号范围，进而找到与之对应的二进制格式</li> <li>将<code>Unicode</code>编码转换为二进制数（去掉最高位的0）</li> <li>将二进制数从右往左一次填入二进制格式的<code>X</code>中，如果有<code>X</code>未填，就设为0</li></ul> <p>来看一个实际的例子：</p> <p>“<strong>马</strong>” 字的<code>Unicode</code>编码是：<code>0x9A6C</code>，整数编号是<code>39532</code></p> <p>（1）首选确定了该字符在第三个范围内，它的格式是 <code>1110xxxx 10xxxxxx 10xxxxxx</code></p> <p>（2）39532对应的二进制数为<code>1001 1010 0110 1100</code></p> <p>（3）将二进制数填入X中，结果是：<code>11101001 10101001 10101100</code></p> <h3 id="_3-utf-16"><a href="#_3-utf-16" class="header-anchor">#</a> （3）UTF-16</h3> <p><strong>1. 平面的概念</strong></p> <p>在了解<code>UTF-16</code>之前，先看一下<strong>平面</strong>的概念：</p> <p><code>Unicode</code>编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放<strong>65536</strong>（216）个字符，这称为一个<strong>平面</strong>，目前总共有17 个平面。</p> <p>最前面的一个平面称为<strong>基本平面</strong>，它的码点从<strong>0 — 2<strong><strong>16</strong></strong>-1</strong>，写成16进制就是<code>U+0000 — U+FFFF</code>，那剩下的16个平面就是<strong>辅助平面</strong>，码点范围是 <code>U+10000—U+10FFFF</code>。</p> <p><strong>2. UTF-16 概念：</strong></p> <p><code>UTF-16</code>也是<code>Unicode</code>编码集的一种编码形式，把<code>Unicode</code>字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。<code>Unicode</code>字符的码位需要1个或者2个16位长的码元来表示，因此<code>UTF-16</code>也是用变长字节表示的。</p> <p><strong>3. UTF-16 编码规则：</strong></p> <ul><li>编号在 <code>U+0000—U+FFFF</code> 的字符（常用字符集），直接用两个字节表示。</li> <li>编号在 <code>U+10000—U+10FFFF</code> 之间的字符，需要用四个字节表示。</li></ul> <p><strong>4. 编码识别</strong></p> <p>那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？</p> <p><code>UTF-16</code> 编码肯定也考虑到了这个问题，在基本平面内，从 <code>U+D800 — U+DFFF</code> 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。</p> <p>辅助平面共有 <strong>2****20</strong> 个字符位，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800 — U+DBFF</code>，称为<strong>高位</strong>（H），后 10 位映射在 <code>U+DC00 — U+DFFF</code>，称为<strong>低位</strong>（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。</p> <p>因此，当遇到两个字节时，发现它的码点在 <code>U+D800 —U+DBFF</code>之间，就可以知道，它后面的两个字节的码点应该在 <code>U+DC00 — U+DFFF</code> 之间，这四个字节必须放在一起进行解读。</p> <p><strong>5. 举例说明</strong></p> <p>以 &quot;<strong>𡠀</strong>&quot; 字为例，它的 <code>Unicode</code> 码点为 <code>0x21800</code>，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：</p> <ul><li>首先计算超出部分的结果：<code>0x21800 - 0x10000</code></li> <li>将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：<code>0001000110 0000000000</code></li> <li>将得到的两个10位二进制数分别对应到两个区间中</li> <li><code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>， 将<code>0001000110</code>填充在它的后10 个二进制位，得到 <code>1101100001000110</code>，转成 16 进制数为 <code>0xD846</code>。同理，低位为 <code>0xDC00</code>，所以这个字的<code>UTF-16</code> 编码为 <code>0xD846 0xDC00</code></li></ul> <h3 id="_4-utf-32"><a href="#_4-utf-32" class="header-anchor">#</a> （4）UTF-32</h3> <p><code>UTF-32</code> 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。</p> <p>比如“<strong>马</strong>” 字的Unicode编号是：<code>U+9A6C</code>，整数编号是<code>39532</code>，直接转化为二进制：<code>1001 1010 0110 1100</code>，这就是它的UTF-32编码。</p> <h3 id="_5-总结"><a href="#_5-总结" class="header-anchor">#</a> （5）总结</h3> <p><strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong></p> <ul><li><code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码（编码规则）；</li> <li><code>UTF-16</code> 使用变长码元序列的编码方式，相较于定长码元序列的<code>UTF-32</code>算法更复杂，甚至比同样是变长码元序列的<code>UTF-8</code>也更为复杂，因为其引入了独特的<strong>代理对</strong>这样的代理机制；</li> <li><code>UTF-8</code>需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而<code>UTF-16</code>不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；</li> <li>如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间；</li></ul> <h2 id="_11-常见的位运算符有哪些-其计算规则是什么"><a href="#_11-常见的位运算符有哪些-其计算规则是什么" class="header-anchor">#</a> 11. 常见的位运算符有哪些？其计算规则是什么？</h2> <p>现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。</p> <p>常见的位运算有以下几种：</p> <table><thead><tr><th>运算符</th> <th>描述</th> <th>运算规则</th></tr></thead> <tbody><tr><td><code>&amp;</code></td> <td>与</td> <td>两个位都为1时，结果才为1</td></tr> <tr><td><code>|</code></td> <td>或</td> <td>两个位都为0时，结果才为0</td></tr> <tr><td><code>^</code></td> <td>异或</td> <td>两个位相同为0，相异为1</td></tr> <tr><td><code>~</code></td> <td>取反</td> <td>0变1，1变0</td></tr> <tr><td><code>&lt;&lt;</code></td> <td>左移</td> <td>各二进制位全部左移若干位，高位丢弃，低位补0</td></tr> <tr><td><code>&gt;&gt;</code></td> <td>右移</td> <td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td></tr></tbody></table> <h3 id="_1-按位与运算符"><a href="#_1-按位与运算符" class="header-anchor">#</a> 1. 按位与运算符（&amp;）</h3> <p><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。</p> <p><strong>运算规则：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0 &amp; 0 = 0  
0 &amp; 1 = 0  
1 &amp; 0 = 0  
1 &amp; 1 = 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>总结：两位同时为1，结果才为1，否则结果为0。</p> <p>例如：3&amp;5 即：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0000 0011 
   0000 0101 
 = 0000 0001
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>因此 3&amp;5 的值为1。</p> <p>注意：负数按补码形式参加按位与运算。</p> <p><strong>用途：</strong></p> <p><strong>（1）判断奇偶</strong></p> <p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p> <p><strong>（2）清零</strong></p> <p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p> <h3 id="_2-按位或运算符"><a href="#_2-按位或运算符" class="header-anchor">#</a> 2. 按位或运算符（|）</h3> <p><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p> <p><strong>运算规则：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0 | 0 = 0
0 | 1 = 1  
1 | 0 = 1  
1 | 1 = 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>总结：参加运算的两个对象只要有一个为1，其值为1。</p> <p>例如：3|5即：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0000 0011
  0000 0101 
= 0000 0111
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>因此，3|5的值为7。</p> <p>注意：负数按补码形式参加按位或运算。</p> <h3 id="_3-异或运算符"><a href="#_3-异或运算符" class="header-anchor">#</a> 3. 异或运算符（^）</h3> <p><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p> <p><strong>运算规则：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0 ^ 0 = 0  
0 ^ 1 = 1  
1 ^ 0 = 1  
1 ^ 1 = 0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。</p> <p>例如：3|5即：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0000 0011
  0000 0101 
= 0000 0110
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>因此，3^5的值为6。</p> <p>异或运算的性质:</p> <ul><li>交换律：<code>(a^b)^c == a^(b^c)</code></li> <li>结合律：<code>(a + b)^c == a^b + b^c</code></li> <li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li> <li>自反性: <code>a^b^b=a^0=a</code>;</li></ul> <h3 id="_4-取反运算符"><a href="#_4-取反运算符" class="header-anchor">#</a> 4. 取反运算符 (~)</h3> <p><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p> <p>运算规则：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>~ 1 = 0
~ 0 = 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>总结：对一个二进制数按位取反，即将0变1，1变0。</p> <p>例如：~6 即：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0000 0110
= 1111 1001
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。</p> <p>当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0000 0110
   = 1111 1001
反码：1000 0110
补码：1000 0111
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>因此，~6的值为-7。</p> <h3 id="_5-左移运算符"><a href="#_5-左移运算符" class="header-anchor">#</a> 5. 左移运算符（&lt;&lt;）</h3> <p><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。</p> <p>设 a=1010 1110，a = a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。</p> <p>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p> <h3 id="_6-右移运算符"><a href="#_6-右移运算符" class="header-anchor">#</a> 6. 右移运算符（&gt;&gt;）</h3> <p><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p> <p>例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。</p> <p>操作数每右移一位，相当于该数除以2。</p> <h3 id="_7-原码、补码、反码"><a href="#_7-原码、补码、反码" class="header-anchor">#</a> 7. 原码、补码、反码</h3> <p>上面提到了补码、反码等知识，这里就补充一下。</p> <p>计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p> <p><strong>（1）原码</strong></p> <p>原码就是一个数的二进制数。</p> <p>例如：10的原码为0000 1010</p> <p><strong>（2）反码</strong></p> <ul><li>正数的反码与原码相同，如：10 反码为 0000 1010</li> <li>负数的反码为除符号位，按位取反，即0变1，1变0。</li></ul> <p>例如：-10</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>原码：1000 1010
反码：1111 0101
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>（3）补码</strong></p> <ul><li>正数的补码与原码相同，如：10 补码为 0000 1010</li> <li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li></ul> <p>例如：-10</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>原码：1000 1010
反码：1111 0101
补码：1111 0110
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_12-为什么函数的-arguments-参数是类数组而不是数组-如何遍历类数组"><a href="#_12-为什么函数的-arguments-参数是类数组而不是数组-如何遍历类数组" class="header-anchor">#</a> 12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h2> <p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p> <p>要遍历类数组，有三个方法：</p> <p>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
  <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token parameter">a</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>（2）使用Array.from方法将类数组转化成数组：‌</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
  <span class="token keyword">const</span> arrArgs <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span> 
  arrArgs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">a</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>（3）使用展开运算符将类数组转化成数组</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token keyword">const</span> arrArgs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span> 
    arrArgs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">a</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_13-什么是-dom-和-bom"><a href="#_13-什么是-dom-和-bom" class="header-anchor">#</a> 13. 什么是 DOM 和 BOM？</h2> <ul><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li> <li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li></ul> <h2 id="_14-escape、encodeurl、encodeurlcomponent-的区别"><a href="#_14-escape、encodeurl、encodeurlcomponent-的区别" class="header-anchor">#</a> 14. escape、encodeURL、encodeURLComponent 的区别</h2> <ol><li><p>escape()</p> <blockquote><p>该函数现不提倡使用，但由历史原因，有很多地方仍在使用它。</p> <p>**作用：**它不能直接用于url编码，它的真正作用是返回一个字符的Unicode编码值。</p> <p>**对应的解码函数：**unescape()。</p> <p>**注意：**无论网页的原始编码是什么，一旦被js编码，就都变为unicode字符。其次，escape不对“+&quot;编码。</p></blockquote></li> <li><p>encodeURL()</p> <blockquote><p><strong>它是js中真正用来对URL编码的函数。</strong></p> <p>它着眼于对<strong>整个URL</strong>进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号“; / ? : @ &amp; = + $ , #”，也不进行编码。编码后，它输出符号的utf-8形式，并且在<strong>每个字节前加上%。</strong></p> <p>它对应的解码函数是decodeURI()。</p> <p>需要注意的是，它不对单引号'编码。</p></blockquote></li> <li><p>encodeURLComponent()</p> <blockquote><p>它与encodeURL的<strong>区别</strong>是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。</p> <p>因此，“; / ? : @ &amp; = + $ , #”，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。</p> <p>它对应的解码函数是decodeURIComponent()。</p></blockquote></li> <li><p>encodeURL 与 encodeURLComponent 的区别</p> <blockquote><p>区别就是encodeURIComponent编码范围更广，适合给参数编码，encodeURI适合给URL本身（locaion.origin）编码,当然项目里一般都是用qs库去处理</p></blockquote></li></ol> <h2 id="_15-对-ajax-的理解-实现一个-ajax-请求"><a href="#_15-对-ajax-的理解-实现一个-ajax-请求" class="header-anchor">#</a> 15. 对 Ajax 的理解，实现一个 Ajax 请求</h2> <p><code>AJAX</code>全称(Async Javascript and XML)</p> <p>即异步的<code>JavaScript</code> 和<code>XML</code>，是<strong>一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页</strong></p> <p><code>Ajax</code>的原理简单来说通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>JavaScript</code>来操作<code>DOM</code>而更新页面</p> <p><strong>实现过程</strong></p> <ul><li>创建 <code>Ajax</code>的核心对象 <code>XMLHttpRequest</code>对象</li> <li>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务端建立连接</li> <li>构建请求所需的数据内容，并通过<code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</li> <li>通过 <code>XMLHttpRequest</code> 对象提供的 <code>onreadystatechange</code> 事件监听服务器端你的通信状态</li> <li>接受并处理服务端向客户端响应的数据结果</li> <li>将处理结果更新到 <code>HTML</code>页面中</li> <li><strong>其中，readyState 各个状态如下</strong>：
<ul><li>0 - <strong>未初始化</strong>，还没有调用 send() 方法</li> <li>1 - <strong>载入</strong>，已调用 send() 方法，正在发送请求</li> <li>2 - <strong>载入完成</strong>，send() 方法执行完成，已经接收到全部响应内容</li> <li>3 - <strong>交互</strong>，正在解析响应内容</li> <li>4 - <strong>完成</strong>，响应内容解析完成，可以在客户端调用了</li></ul></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myAjax</span><span class="token punctuation">(</span><span class="token parameter">method<span class="token punctuation">,</span> url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建XMLHttpRequest对象</span>
    <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 第三个参数布尔值，表示是否异步执行操作，默认为true，表开启异步</span>
    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
    xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">&gt;=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">&gt;=</span> <span class="token number">400</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;错误信息：&quot;</span><span class="token operator">+</span>xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>使用 promise 封装 ajax</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myPromiseAjax</span><span class="token punctuation">(</span>method <span class="token operator">=</span> <span class="token string">'GET'</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    	xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
        xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">&gt;=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">resolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">&gt;=</span> <span class="token number">400</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">reject</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
		xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="_16-javascript-为什么要进行变量提升-它导致了什么问题"><a href="#_16-javascript-为什么要进行变量提升-它导致了什么问题" class="header-anchor">#</a> 16. JavaScript 为什么要进行变量提升，它导致了什么问题？</h2> <h3 id="前言"><a href="#前言" class="header-anchor">#</a> 前言：</h3> <p>用过的JavaScript的应该都知道，它有变量提升的机制，不过可能很少去考虑为什么会有变量提升的机制，现在就来看一下为什么要进行变量提升。</p> <h3 id="_1-什么是变量提升"><a href="#_1-什么是变量提升" class="header-anchor">#</a> 1. 什么是变量提升？</h3> <p>变量提升实际上很容易理解，就是说在任何位置所声明的变量或函数，都会自动“提”到最前面，就好像它们是在函数的开头声明的一样。</p> <h3 id="_2-为什么进行变量提升"><a href="#_2-为什么进行变量提升" class="header-anchor">#</a> 2. 为什么进行变量提升？</h3> <p>首先我们要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即<strong>解析和执行</strong>。</p> <ul><li><strong>在解析阶段</strong>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。
<ul><li>全局上下文：变量定义，函数声明</li> <li>函数上下文：变量定义，函数声明，this，arguments</li></ul></li> <li><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</li></ul> <p>那为什么会进行变量提升呢？主要有以下两个原因：</p> <ul><li>提高性能</li> <li>容错性更好</li></ul> <h4 id="_1-提高性能"><a href="#_1-提高性能" class="header-anchor">#</a> （1）提高性能</h4> <p>在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p> <p>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p> <h4 id="_2-容错性更好"><a href="#_2-容错性更好" class="header-anchor">#</a> （2）容错性更好</h4> <p>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p> <p>虽然，我们在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结：</h4> <ul><li><strong>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</strong></li> <li><strong>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</strong></li></ul> <h3 id="_3-变量提升导致的问题"><a href="#_3-变量提升导致的问题" class="header-anchor">#</a> 3. 变量提升导致的问题</h3> <p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。</p> <p>下面来看一下变量提升可能会导致的问题：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// undefined</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tmp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 11</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p> <h2 id="_17-什么是尾调用-使用尾调用有什么好处"><a href="#_17-什么是尾调用-使用尾调用有什么好处" class="header-anchor">#</a> 17. 什么是尾调用，使用尾调用有什么好处?</h2> <h3 id="什么是尾调用"><a href="#什么是尾调用" class="header-anchor">#</a> 什么是尾调用</h3> <p>尾调用的概念非常简单，一句话就能说清楚，就是<strong>指某个函数的最后一步是调用另一个函数</strong>。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</p> <p>以下两种情况，都不属于尾调用。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 情况一</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 情况二</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。</p> <p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">m</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">n</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</p> <h3 id="尾调用优化"><a href="#尾调用优化" class="header-anchor">#</a> 尾调用优化</h3> <p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p> <p>我们知道，函数调用会在内存形成一个&quot;调用记录&quot;，又称&quot;调用帧&quot;（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88" target="_blank" rel="noopener noreferrer">&quot;调用栈&quot;<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（call stack）。</p> <p><img src="img/image-20210825181914707.png" alt="image-20210825181914707"></p> <p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等同于</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等同于</span>
<span class="token function">g</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。</p> <p>**这就叫做&quot;尾调用优化&quot;（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。**这就是&quot;尾调用优化&quot;的意义。</p> <h3 id="注意"><a href="#注意" class="header-anchor">#</a> 注意</h3> <p><strong>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</strong></p> <p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p> <ul><li><code>arguments</code>：返回调用时函数的参数。</li> <li><code>func.caller</code>：返回调用当前函数的那个函数。</li></ul> <p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p> <h2 id="_18-es6-模块与-commonjs-模块有什么异同"><a href="#_18-es6-模块与-commonjs-模块有什么异同" class="header-anchor">#</a> 18. ES6 模块与 COMMONJS 模块有什么异同？</h2> <ul><li><p>因为<strong>CommonJS</strong>的<code>require</code>语法是同步的，所以就导致了<strong>CommonJS</strong>模块规范只适合用在服务端，而ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用 ；</p></li> <li><p><strong>CommonJS</strong> 模块输出的是一个值的拷贝，而<strong>ES6 模块</strong>输出的是值的引用；</p> <ul><li><p>CommonJS输出的是值的拷贝，换句话说就是，一旦输出了某个值，如果模块内部后续的变化，影响不了外部对这个值的使用。具体例子：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// lib.js</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  counter<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  counter<span class="token operator">:</span> counter<span class="token punctuation">,</span>
  incCounter<span class="token operator">:</span> incCounter<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>然后我们在其它文件中使用这个模块：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> mod <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./lib'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mod<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3</span>
mod<span class="token punctuation">.</span><span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mod<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上面的例子充分说明了如果我们对外输出了<code>counter</code> 变量，就算后续调用模块内部的<code>incCounter</code> 方法去修改它的值，它的值依旧没有变化。</p> <p>ES6模块运行机制完全不一样，JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行的时候，再根据这个只读引用，到被加载的那个模块里去取值。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// lib.js</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  counter<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> counter<span class="token punctuation">,</span> incCounter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./lib'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>上面代码说明，ES6 模块<code>import</code>的变量<code>counter</code>是可变的，完全反应其所在模块<code>lib.js</code>内部的变化。</p></li></ul></li> <li><p><strong>CommonJS</strong> 模块是运行时加载，而ES6 模块是编译时输出接口，使得对JS的模块进行静态分析成为了可能；</p> <ul><li>我们知道CommonJS其实加载的是一个对象，这个对象只有在脚本运行时才会生成，而且只会生成一次，这个后面我们会具体解释。但是ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成，这样我们就可以使用各种工具对JS模块进行依赖分析，优化代码，而Webpack中的 <code>tree shaking</code> 和 <code>scope hoisting</code> 实际上就是依赖ES6模块化。</li></ul></li> <li><p>因为两个模块加载机制的不同，所以在对待循环加载的时候，它们会有不同的表现。<strong>CommonJS</strong>遇到循环依赖的时候，只会输出已经执行的部分，后续的输出或者变化，是不会影响已经输出的变量。而ES6模块相反，使用<code>import</code>加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值；</p></li> <li><p>关于模块顶层的<code>this</code>指向问题，在<strong>CommonJS</strong>顶层，<code>this</code>指向当前模块；而在ES6模块中，<code>this</code>指向<code>undefined</code>；</p></li> <li><p>关于两个模块互相引用的问题，在ES6模块当中，是支持加载<strong>CommonJS</strong>模块的。但是反过来，<strong>CommonJS</strong>并不能<code>require</code>ES6模块，在NodeJS中，两种模块方案是分开处理的。</p></li></ul> <h2 id="_19-常见的-dom-操作有哪些"><a href="#_19-常见的-dom-操作有哪些" class="header-anchor">#</a> 19. 常见的 DOM 操作有哪些</h2> <h3 id="_1-dom-节点的获取"><a href="#_1-dom-节点的获取" class="header-anchor">#</a> 1）DOM 节点的获取</h3> <p>DOM 节点的获取的API及使用：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>getElementById <span class="token comment">// 按照 id 查询</span>
getElementsByTagName <span class="token comment">// 按照标签名查询</span>
getElementsByClassName <span class="token comment">// 按照类名查询</span>
querySelectorAll <span class="token comment">// 按照 css 选择器查询</span>

<span class="token comment">// 按照 id 查询</span>
<span class="token keyword">var</span> imooc <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'imooc'</span><span class="token punctuation">)</span> <span class="token comment">// 查询到 id 为 imooc 的元素</span>
<span class="token comment">// 按照标签名查询</span>
<span class="token keyword">var</span> pList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span>  <span class="token comment">// 查询到标签为 p 的集合</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>divList<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>divList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 按照类名查询</span>
<span class="token keyword">var</span> moocList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'mooc'</span><span class="token punctuation">)</span> <span class="token comment">// 查询到类名为 mooc 的集合</span>
<span class="token comment">// 按照 css 选择器查询</span>
<span class="token keyword">var</span> pList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'.mooc'</span><span class="token punctuation">)</span> <span class="token comment">// 查询到类名为 mooc 的集合</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="_2-dom-节点的创建"><a href="#_2-dom-节点的创建" class="header-anchor">#</a> 2）DOM 节点的创建</h3> <p>**创建一个新节点，并把它添加到指定节点的后面。**已知的 HTML 结构如下：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>DEMO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>container<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>title<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>我是标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>   
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 首先获取父节点</span>
<span class="token keyword">var</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span>
<span class="token comment">// 创建新节点</span>
<span class="token keyword">var</span> targetSpan <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span>
<span class="token comment">// 设置 span 节点的内容</span>
targetSpan<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'hello world'</span>
<span class="token comment">// 把新创建的元素塞进父节点里去</span>
container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>targetSpan<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_3-dom-节点的删除"><a href="#_3-dom-节点的删除" class="header-anchor">#</a> 3）DOM 节点的删除</h3> <p>**删除指定的 DOM 节点，**已知的 HTML 结构如下：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>DEMO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>container<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>title<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>我是标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>   
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>需要删除 id 为 title 的元素，做法是：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 获取目标元素的父元素</span>
<span class="token keyword">var</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span>
<span class="token comment">// 获取目标元素</span>
<span class="token keyword">var</span> targetNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span>
<span class="token comment">// 删除目标元素</span>
container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>targetNode<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>或者通过子节点数组来完成删除：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 获取目标元素的父元素</span>
<span class="token keyword">var</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span>
<span class="token comment">// 获取目标元素</span>
<span class="token keyword">var</span> targetNode <span class="token operator">=</span> container<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token comment">// 删除目标元素</span>
container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>targetNode<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_4-修改-dom-元素"><a href="#_4-修改-dom-元素" class="header-anchor">#</a> 4）修改 DOM 元素</h3> <p>修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。</p> <p>**将指定的两个 DOM 元素交换位置，**已知的 HTML 结构如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span class="token constant">DEMO</span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span> 
      <span class="token operator">&lt;</span>h1 id<span class="token operator">=</span><span class="token string">&quot;title&quot;</span><span class="token operator">&gt;</span>我是标题<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">&quot;content&quot;</span><span class="token operator">&gt;</span>我是内容<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>   
  <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 获取父元素</span>
<span class="token keyword">var</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span>   
 
<span class="token comment">// 获取两个需要被交换的元素</span>
<span class="token keyword">var</span> title <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> content <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">)</span>
<span class="token comment">// 交换两个元素，把 content 置于 title 前面</span>
container<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> title<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_20-use-strict-是什么意思-使用它区别是什么"><a href="#_20-use-strict-是什么意思-使用它区别是什么" class="header-anchor">#</a> 20. use strict 是什么意思？使用它区别是什么？</h2> <p>use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：</p> <ul><li>消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;</li> <li>消除代码运行的不安全之处，保证代码运行的安全；</li> <li>提高编译器效率，增加运行速度；</li> <li>为未来新版本的 Javascript 做好铺垫。</li></ul> <p>区别：</p> <ul><li>禁止使用 with 语句。</li> <li>禁止 this 关键字指向全局对象。</li> <li>对象不能有重名的属性。</li></ul> <h2 id="_21-如何判断一个对象是否属于某个类"><a href="#_21-如何判断一个对象是否属于某个类" class="header-anchor">#</a> 21. 如何判断一个对象是否属于某个类</h2> <ol><li>第一种方式，使用 <strong>instanceof</strong> 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li> <li>第二种方式，通过对象的 <strong>constructor 属性</strong>来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li> <li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 <strong>Object.prototype.toString()</strong> 方法来打印对象的[[Class]] 属性来进行判断。</li></ol> <h2 id="_22-强类型语言和弱类型语言的区别"><a href="#_22-强类型语言和弱类型语言的区别" class="header-anchor">#</a> 22. 强类型语言和弱类型语言的区别</h2> <p>强类型语言是一种强制类型定义的语言，即一旦某一个变量被定义类型，如果不经强制转换，那么它永远就是该数据类型。而弱类型语言是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过现行强制转换。</p> <p><strong>区别：</strong></p> <p>强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。<strong>强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。</strong></p> <p><strong>额外小知识：</strong></p> <p>对于动态语言与静态语言的区分，其根本在<strong>于判断是在运行期间还是在编译期间才确定数据类型。</strong></p> <p>js 是动态语言。</p> <h2 id="_23-解释型语言和编译型语言的区别"><a href="#_23-解释型语言和编译型语言的区别" class="header-anchor">#</a> 23. 解释型语言和编译型语言的区别</h2> <p><strong>(1）解释型语言</strong></p> <p>使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下</p> <ul><li>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li> <li>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li> <li>JavaScript、Python等属于解释型语言。</li></ul> <p><strong>（2）编译型语言</strong></p> <p>使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：</p> <ul><li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li> <li>与特定平台相关，一般无法移植到其他平台；</li> <li>C、C++等属于编译型语言。</li></ul> <p>**两者主要区别在于：**前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。</p> <h2 id="_24-for-in-和-for-of-的区别"><a href="#_24-for-in-和-for-of-的区别" class="header-anchor">#</a> 24. for...in 和 for...of 的区别</h2> <p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p> <ul><li>for…in 获取的是对象的键名，for…of 遍历获取的是对象的键值；</li> <li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li> <li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li></ul> <p>**总结：**for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p> <h2 id="_25-如何使用-for-of-遍历对象"><a href="#_25-如何使用-for-of-遍历对象" class="header-anchor">#</a> 25. 如何使用 for...of 遍历对象</h2> <p><code>ES6</code> 中提供了 <code>for-of</code>，可以很方便的遍历数组和类数组，但是却不能遍历对象，这是为什么，与 <code>for-in</code> 仅仅相差一个单词，用途也是遍历，为什么却不能使用在对象上？</p> <p>查资料后得知，原来 <code>ES6</code> 中引入了 <code>Iterator</code>，只有提供了 <code>Iterator</code> 接口的数据类型才可以使用 <code>for-of</code> 来循环遍历，而 <code>Array</code>、<code>Set</code>、<code>Map</code>、某些类数组如 <code>arguments</code> 等数据类型都默认提供了 <code>Iterator</code> 接口，所以它们可以使用 <code>for-of</code> 来进行遍历</p> <p>那么原因清楚了，该怎么解决呢？能不能为对象已经其它的一些数据类型提供 <code>Iterator</code> 接口呢</p> <p>答案是可以的，<code>ES6</code> 同时提供了 <code>Symbol.iterator</code> 属性，只要一个数据结构有这个属性，就会被视为有 <code>Iterator</code> 接口，接着就是如何实现这个接口了，如下就是一个最简实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>newObj<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> <span class="token keyword">this</span> <span class="token punctuation">)</span>
        <span class="token punctuation">;</span>
    
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">yield</span> <span class="token punctuation">{</span>
            key<span class="token operator">:</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">[</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">{</span>key<span class="token punctuation">,</span> value<span class="token punctuation">}</span> <span class="token keyword">of</span> newObj<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 输出结果</span>
<span class="token comment">// e 5</span>
<span class="token comment">// f 6</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="_26-ajax、axios、fetch-的区别"><a href="#_26-ajax、axios、fetch-的区别" class="header-anchor">#</a> 26. ajax、axios、fetch 的区别</h2> <p><strong>（1）AJAX</strong></p> <p>Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是<strong>指一种创建交互式<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E7%BD%91%E9%A1%B5" target="_blank" rel="noopener noreferrer">网页<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</strong>。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：</p> <ul><li>本身是针对MVC编程，不符合前端MVVM的浪潮</li> <li>基于原生XHR开发，XHR本身的架构不清晰</li> <li>不符合关注分离（Separation of Concerns）的原则</li> <li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li></ul> <p><strong>（2）Fetch</strong></p> <p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。<strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</p> <p>fetch的优点：</p> <ul><li>语法简洁，更加语义化</li> <li>基于标准 Promise 实现，支持 async/await</li> <li>更加底层，提供的API丰富（request, response）</li> <li>脱离了XHR，是ES规范里新的实现方式</li></ul> <p>fetch的缺点：</p> <ul><li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li> <li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})</li> <li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li> <li>fetch没有办法原生监测请求的进度，而XHR可以</li></ul> <p><strong>（3）Axios</strong></p> <p>Axios 是一种基于Promise封装的HTTP客户端，其特点如下：</p> <ul><li>浏览器端发起XMLHttpRequests请求</li> <li>node端发起http请求</li> <li>支持Promise API</li> <li>监听请求和返回</li> <li>对请求和返回进行转化</li> <li>取消请求</li> <li>自动转换json数据</li> <li>客户端支持抵御CSRF攻击</li></ul> <h2 id="_27-数组的遍历方法有哪些"><a href="#_27-数组的遍历方法有哪些" class="header-anchor">#</a> 27. 数组的遍历方法有哪些</h2> <table><thead><tr><th><strong>方法</strong></th> <th><strong>是否改变原数组</strong></th> <th><strong>特点</strong></th></tr></thead> <tbody><tr><td>forEach()</td> <td>否</td> <td>数组方法，不改变原数组，没有返回值</td></tr> <tr><td>map()</td> <td>否</td> <td>数组方法，不改变原数组，有返回值，可链式调用</td></tr> <tr><td>filter()</td> <td>否</td> <td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td></tr> <tr><td>for...of</td> <td>否</td> <td>for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td></tr> <tr><td>every() 和 some()</td> <td>否</td> <td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td></tr> <tr><td>find() 和 findIndex()</td> <td>否</td> <td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td></tr> <tr><td>reduce() 和 reduceRight()</td> <td>否</td> <td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td></tr></tbody></table> <p>遍历方法的详细解释：<a href="https://cuggz.blog.csdn.net/article/details/107649549" target="_blank" rel="noopener noreferrer">《细数JavaScript中那些遍历和循环》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>keys，values，entries</strong></p> <p>ES6 提供三个新的方法 —— entries()，keys()和values() —— 用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 0</span>
<span class="token comment">// 1</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> elem <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 'a'</span>
<span class="token comment">// 'b'</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>index<span class="token punctuation">,</span> elem<span class="token punctuation">]</span> <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 0 &quot;a&quot;</span>
<span class="token comment">// 1 &quot;b&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_28-foreach-和-map-方法有什么区别"><a href="#_28-foreach-和-map-方法有什么区别" class="header-anchor">#</a> 28. forEach 和 map 方法有什么区别</h2> <p>这方法都是用来遍历数组的，两者区别如下：</p> <ul><li>forEach() 方法会针对每一个元素执行提供的函数，对数据的操作会<strong>改变原数组，该方法没有返回值</strong>；</li> <li>map() 方法<strong>不会改变原数组的值，返回一个新数组</strong>，新数组中的值为原数组调用函数处理之后的值；</li></ul> <h2 id="_29-vo-ao-go"><a href="#_29-vo-ao-go" class="header-anchor">#</a> 29. VO AO GO</h2> <h3 id="底层渲染过程"><a href="#底层渲染过程" class="header-anchor">#</a> 底层渲染过程</h3> <ol><li>在浏览器中打开页面，浏览器引擎会渲染相关代码（包含JS代码），换句话说，会把代码自上而下执行。</li> <li>浏览器想要执行代码，会提供一个供代码执行的环境，我们把这个环境叫做<code>ECStack</code>（Execution Context Stack）执行环境栈 =》 栈内存 Stack （栈内存作用：供代码自上而下执行）。</li> <li>最开始执行的是全局代码，所以会形成一个<code>EC</code>（GLOBAL）全局上下文，在栈内存中执行全局的代码。</li> <li>在全局的执行上下文中有一个<code>VO</code>（GLOBAL）全局变量对象，可以把接下来定义的变量和对应的值储存到这里面。</li></ol> <blockquote><p><strong>名词解释：</strong></p> <p>ECStack (Execution Context Stack) 执行环境栈，栈内存；</p> <p>EC (Execution Context) 执行上下文；</p> <p>AO (Active Object) 私有对象/活动性对象/执行期上下文，就是我们常说的 <strong>作用域</strong>。AO可以理解为VO的一个实例，也就是VO的一个构造函数，然后VO(Context) === AO，所以VO提供的是一个函数中所有变量数据的模板；</p> <p>VO  (Variable Object) 变量对象：存储当前上下文中的变量；</p> <p>GO (Global Object) 全局对象 。</p></blockquote> <h3 id="堆栈定义"><a href="#堆栈定义" class="header-anchor">#</a> 堆栈定义</h3> <p>堆（heap）（引用类型）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。</p> <p>栈（stack）（基本类型）：由编译器自动分配释放，存放函数的参数值，局部变量等。</p> <blockquote><p>所谓栈堆内存，其实就是计算机内存中分配出来的一块空间，用来执行和存储代码的。</p></blockquote> <h3 id="栈内存和堆内存的区别"><a href="#栈内存和堆内存的区别" class="header-anchor">#</a> 栈内存和堆内存的区别</h3> <p>栈内存：用来执行代码，存基本类型值的</p> <p>堆内存：用来存引用类型值的</p> <h3 id="执行过程"><a href="#执行过程" class="header-anchor">#</a> 执行过程</h3> <h4 id="前言-2"><a href="#前言-2" class="header-anchor">#</a> 前言</h4> <p>研究以下代码如何执行</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">]</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	y<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">200</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_1-ecstack、go、ec、vo、ao"><a href="#_1-ecstack、go、ec、vo、ao" class="header-anchor">#</a> 1. ECStack、GO、EC、VO、AO</h4> <p>浏览器会在计算机内存分配一块内存，专门用来供代码执行的 <strong>栈内存</strong>，称作 **执行环境栈（ECStack）**同时会创建一个 <strong>全局对象（G0）</strong>，将内置的属性方法（<code>isNaN</code>、<code>setInterval</code>、<code>setTimeout</code>......）存放到一块单独的堆内存空间，并且使用 <strong>window</strong> 指向全局对象</p> <p>在执行代码前，还需要创建一个 <strong>全局执行上下文（EC(G)）</strong>，创建完成后，进入到栈内存中去执行（进栈）；在当前全局执行上下文中，因为会创建很多变量并且赋值，所以会创建一个 **变量对象VO（Variable Object）**来进行保存，在函数私有上下文中的变量对象叫做 <strong>活动对象AO（Activation Object）</strong>。每个执行上下文都有一个单独的变量对象。</p> <p>总结不常见的名词：</p> <ul><li>执行环境栈 ECStack（Execution Context Stack）：专门用来供代码执行的栈内存</li> <li>全局对象GO（Global Object）：存放内置的属性方法，window指向</li> <li>全局执行上下文EC(G) （Execution Context(G)）：页面加载后进栈、销毁后出栈</li> <li>变量对象VO（Variable Object）：存放当前执行上下文中创建的变量和值</li> <li>活动对象AO（Activation Object）：函数私有上下文中的变量对象</li></ul> <p><img src="img/didi.gif" alt="didi"></p> <h4 id="_2-全局代码执行"><a href="#_2-全局代码执行" class="header-anchor">#</a> 2. 全局代码执行</h4> <p>当一切准备就绪，就开始从上到下执行代码。执行前还会设计变量提升的问题，这里不展开</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>js在解析这段代码时，会按照以下3个步骤</p> <ul><li>先创建一个值[12, 23]</li> <li>再创建一个变量x</li> <li>最后将变量与值关联</li></ul> <p>当创建的值是引用类型时，会在堆内存中开辟新的内存空间用来保存值，创建完成后，会将堆内存地址（通常是16进制）保存到栈内存中；如果创建的值是基本类型时，会直接保存到栈内存中</p> <p><img src="img/4e1b6d3897174cd38bbdb61c2aaaa310_tplv-k3u1fbpfcp-zoom-1.gif" alt="4e1b6d3897174cd38bbdb61c2aaaa310_tplv-k3u1fbpfcp-zoom-1"></p> <p>继续向下执行</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>
    y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span>
    y<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">200</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>函数也是属于引用类型，也需要开辟堆内存空间进行保存，不同于数组和对象保存的是键值对，JS会将函数体通过字符串包裹进行保存，同时也会保存函数相关的属性，例如 <strong>函数名 name:fn、形参个数length:1</strong>等。同时，更重要的是，创建函数的时候，就定义了 <strong>函数的作用域</strong>，也就是 <strong>等于当前创建函数的执行上下文</strong>。在这个例子中，函数fn的作用域就是全局执行上下文，标识为 <code>[[scope]]:EC(G)</code></p> <p><img src="img/ad310ce9d16f41dea92186d788703feb_tplv-k3u1fbpfcp-zoom-1.gif" alt="ad310ce9d16f41dea92186d788703feb_tplv-k3u1fbpfcp-zoom-1"></p> <p>在函数创建好后，继续向下执行</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通过上面的动图了解到，fn和x都指向堆内存地址，所以，fn(x) 相当于 <strong>AAAFFF000(AAAFFF111)</strong>，在执行函数体代码之前，我们需要知道的是：</p> <ul><li><strong>每次函数执行</strong>，都会创建一个 <strong>函数私有执行上下文</strong>，创建完之后，需要进入到栈内存中去执行，此时，执行栈中的 <strong>全局执行上下文就会被压入到栈底（压栈）</strong></li> <li>同时，需要创建一个 <strong>活动对象AO</strong> 存放当前函数执行上下文中创建的变量和值等</li></ul> <p><img src="img/4ee58aabd027402f91c98c4ebc490c40_tplv-k3u1fbpfcp-zoom-1.gif" alt="4ee58aabd027402f91c98c4ebc490c40_tplv-k3u1fbpfcp-zoom-1"></p> <p>再完成函数执行上下文入栈后，接下来会做以下几件事</p> <ol><li><strong>初始化作用域链scopeChain</strong>：作用域链通常标记为 <strong>&lt;当前执行上下文，函数创建时的作用域&gt;</strong>，而作用域链是为了函数执行过程中，当活动对象不存在某个变量时，会沿着作用域链向上找到</li> <li><strong>初始化this指向</strong>：本例子中，this等于window</li> <li><strong>初始化实参集合arguments</strong></li> <li><strong>形参赋值</strong> y = x = AAAFFF111</li> <li><strong>执行函数体</strong> 紧接着就是执行函数体内容，在执行完后，当前函数的执行上下文就会出栈，退出执行栈，而被压入栈底的全局执行上下文又被推到了栈顶，此时会继续执行全局上下文中的代码</li></ol> <p><img src="img/624fc0122f3040d5adbcd0e6913a620d_tplv-k3u1fbpfcp-zoom-1.gif" alt="624fc0122f3040d5adbcd0e6913a620d_tplv-k3u1fbpfcp-zoom-1"></p> <p>至此，代码执行结束，最终输出的x是 [100, 23]</p> <h1 id="四、原型与原型链"><a href="#四、原型与原型链" class="header-anchor">#</a> 四、原型与原型链</h1> <h2 id="_1-对原型、原型链的理解"><a href="#_1-对原型、原型链的理解" class="header-anchor">#</a> 1. 对原型、原型链的理解</h2> <p><strong>对象的原型</strong>是它构造函数的<code>prototype</code>所指向的原型对象。</p> <p>由对象的原型、以及该对象的原型的原型，以此类推，组成的关系链叫做<strong>原型链</strong>。</p> <p><img src="img/image-20210825234828887.png" alt="image-20210825234828887"></p> <p><strong>总结：</strong></p> <ul><li>一切对象都是继承自<code>Object</code>对象，<code>Object</code> 对象直接继承根源对象<code>null</code></li> <li>一切的函数对象（包括 <code>Object</code> 对象），都是继承自 <code>Function</code> 对象</li> <li><code>Object</code> 对象直接继承自 <code>Function</code> 对象</li> <li><code>Function</code>对象的<code>__proto__</code>会指向自己的原型对象，最终还是继承自<code>Object</code>对象</li></ul> <h2 id="_2-原型链的终点是什么-如何打印出原型链的终点"><a href="#_2-原型链的终点是什么-如何打印出原型链的终点" class="header-anchor">#</a> 2. 原型链的终点是什么？如何打印出原型链的终点？</h2> <p>由于 <code>Object</code>是构造函数，原型链终点是 <code>Object.prototype.__proto__</code>，而 <code>Object.prototype.__proto__=== null // true</code>，所以，<strong>原型链的终点是<code>null</code>。</strong></p> <h2 id="_3-如何获得对象非原型链上的属性"><a href="#_3-如何获得对象非原型链上的属性" class="header-anchor">#</a> 3. 如何获得对象非原型链上的属性？</h2> <p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">iterate</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">var</span> res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>
           res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">': '</span><span class="token operator">+</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h1 id="五、执行上下文-作用域链-闭包"><a href="#五、执行上下文-作用域链-闭包" class="header-anchor">#</a> 五、执行上下文/作用域链/闭包</h1> <h2 id="_1-对闭包的理解"><a href="#_1-对闭包的理解" class="header-anchor">#</a> 1. 对闭包的理解</h2> <ul><li><strong>理解1：一个函数和对其周围状态（词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包。</strong></li> <li><strong>理解2：闭包是指有权访问另一个函数作用域中变量的函数。</strong></li></ul> <p><strong>使用场景：</strong></p> <ol><li><p>创建私有变量</p></li> <li><p>延长变量的生命周期</p> <blockquote><p>一般函数的词法环境在函数返回后就被销毁，但是<strong>闭包会保存对创建时所在词法环境的引用</strong>，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的</p></blockquote></li></ol> <p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。<strong>解决办法有三种</strong>：</p> <ul><li>第一种是使用闭包的方式</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> j <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在上述代码中，首先使用了<strong>立即执行函数</strong>将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p> <ul><li>第二种就是使用 <code>setTimeout</code> 的<strong>第三个参数</strong>，这个参数会被当成 <code>timer</code> 函数的参数传入。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span>
    <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">,</span>
    i
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_2-对作用域、作用域链的理解"><a href="#_2-对作用域、作用域链的理解" class="header-anchor">#</a> 2. 对作用域、作用域链的理解</h2> <h3 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h3> <p>**作用域，**即变量（变量作用域又称为上下文）和函数生效（能被访问）的区域或集合。<strong>换句话说，作用域决定了代码区块中变量和其他资源的可见性。</strong></p> <p><strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p> <p><strong>作用域一般分为三类：</strong></p> <ol><li><p><strong>全局作用域</strong></p> <p>任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问</p></li> <li><p><strong>函数作用域</strong></p> <p>函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问</p></li> <li><p><strong>块级作用域</strong></p> <p>ES6引入了<code>let</code>和<code>const</code>关键字,和<code>var</code>关键字不同，在大括号中使用<code>let</code>和<code>const</code>声明的变量存在于块级作用域中。在大括号之外不能访问这些变量</p></li></ol> <h3 id="词法作用域"><a href="#词法作用域" class="header-anchor">#</a> 词法作用域</h3> <p>词法作用域，又叫静态作用域，<strong>变量被创建时就确定好了</strong>，而非执行阶段确定的。</p> <p>因为 JavaScript 采用的是<strong>词法作用域</strong>，函数的作用域在<strong>函数定义</strong>的时候就决定了。</p> <p>而与词法作用域相对的是<strong>动态作用域</strong>，函数的作用域是在<strong>函数调用</strong>的时候才决定的。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>假设JavaScript采用静态作用域，让我们分析下执行过程：</p> <p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p> <p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p> <p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p> <p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。</p> <h3 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h3> <p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是<strong>自由变量</strong>。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是<strong>作用域链</strong>。</p> <p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p> <p>作用域链的本质上是一个指向变量对象的<strong>指针列表</strong>。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p> <p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p> <h2 id="_3-对执行上下文的理解"><a href="#_3-对执行上下文的理解" class="header-anchor">#</a> 3. 对执行上下文的理解</h2> <p><strong>1. 执行上下文类型</strong></p> <ol><li><p><strong>全局执行上下文</strong></p> <p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p></li> <li><p><strong>函数执行上下文</strong></p> <p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p></li> <li><p><strong>eval 函数执行上下文</strong></p> <p>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p></li></ol> <p><strong>2. 执行上下文栈</strong></p> <p>JavaScript 引擎创建了执行上下文栈来管理执行上下文。<strong>可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。</p> <p><strong>步骤：</strong></p> <p>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</p> <p><strong>3. 执行上下文的生命周期</strong></p> <p>执行上下文的生命周期包括三个阶段：<strong>创建阶段→执行阶段→回收阶段</strong></p> <p><strong>创建阶段</strong></p> <p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p> <ul><li><p>创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。</p> <ul><li><p>用当前函数的<strong>参数列表</strong>（<code>arguments</code>）初始化一个 “变量对象” 并将当前执行上下文与之关联 ，函数代码块中声明的 <strong>变量</strong> 和 <strong>函数</strong> 将作为属性添加到这个变量对象上。<strong>在这一阶段，会进行变量和函数的初始化声明，变量统一定义为 <code>undefined</code> 需要等到赋值时才会有确值，而函数则会直接定义</strong>。</p> <blockquote><p>有没有发现这段加粗的描述非常熟悉？没错，这个操作就是  <strong>变量声明提升</strong>（变量和函数声明都会提升，但是函数提升更靠前）。</p></blockquote></li></ul></li> <li><p>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</p></li> <li><p>确定this指向</p></li></ul> <p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p> <p>另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出this arguments和函数的参数。</p> <p><strong>执行阶段</strong></p> <p>执行变量赋值、代码执行</p> <p><strong>回收阶段</strong></p> <p>执行上下文出栈等待虚拟机回收执行上下文</p> <p><strong>简单来说执行上下文就是指：</strong></p> <p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来（函数提升优先级比变量声明优先级高），变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p> <p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p> <ul><li>全局上下文：变量定义，函数声明</li> <li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li></ul> <h1 id="六、-this-call-apply-bind"><a href="#六、-this-call-apply-bind" class="header-anchor">#</a> 六、 this/call/apply/bind</h1> <h2 id="_1-对-this-对象的理解"><a href="#_1-对-this-对象的理解" class="header-anchor">#</a> 1. 对 this 对象的理解</h2> <p>this 是执行上下文的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断：</p> <ol><li><strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li> <li>**方法调用模式，**如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li> <li>**构造器调用模式，**如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li> <li>**apply、call 和 bind 调用模式，**这三个方法显示指定调用函数 this 的指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。<strong>这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</strong></li></ol> <p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p> <h2 id="_2-call-和-apply-的区别"><a href="#_2-call-和-apply-的区别" class="header-anchor">#</a> 2. call 和 apply 的区别</h2> <p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p> <ul><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li> <li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul> <h2 id="_3-call-和-bind-的区别"><a href="#_3-call-和-bind-的区别" class="header-anchor">#</a> 3. call 和 bind 的区别</h2> <ol><li><strong>返回值不同</strong>，call 返回的是函数执行后的结果，bind 返回的是永久改变 this 指向的函数，而该函数有类似于柯里化的作用。</li> <li>调用绑定函数时作为 <code>this</code> 参数传递给目标函数的值。 如果使用<code>new</code>运算符构造绑定函数，则忽略第一个参数。</li></ol> <h2 id="_4-实现-call、apply-以及-bind-函数"><a href="#_4-实现-call、apply-以及-bind-函数" class="header-anchor">#</a> 4. 实现 call、apply 以及 bind 函数</h2> <p><strong>call</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context <span class="token operator">=</span> window<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 创建唯一的key值作为传入对象的方法名</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment">// 将函数赋给传入对象作为它的属性</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token comment">// 调用对象的方法</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token comment">// 调用完毕删除属性</span>
    <span class="token keyword">return</span> result <span class="token comment">// 返回结果</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>apply</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context <span class="token operator">=</span> window<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span>
    <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>bind</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context <span class="token operator">=</span> window<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创造唯一的key值  作为我们构造的context内部方法名</span>
    <span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> _this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">//  bind情况要复杂一点</span>
    <span class="token keyword">const</span> <span class="token function-variable function">result</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>innerArgs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第一种情况 :若是将 bind 绑定之后的函数当作构造函数，通过 new 操作符使用，则不绑定传入的 this，而是将 this 指向实例化出来的对象</span>
        <span class="token comment">// 此时由于new操作符作用  this指向result实例对象  而result又继承自传入的_this 根据原型链知识可得出以下结论</span>
        <span class="token comment">// this.__proto__ === result.prototype   //this instanceof result =&gt;true</span>
        <span class="token comment">// this.__proto__.__proto__ === result.prototype.__proto__ === _this.prototype; //this instanceof _this =&gt;true</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">_this</span> <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 此时this指向指向result的实例  这时候不需要改变this指向</span>
            <span class="token keyword">this</span><span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> _this<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>innerArgs<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这里使用es6的方法让bind支持参数合并</span>
            <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果只是作为普通函数调用  那就很简单了 直接改变this指向为传入的context</span>
            context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>innerArgs<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法</span>
    <span class="token comment">// 实现继承的方式: 使用Object.create</span>
    result<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><strong>用法如下</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//'我是参数传进来的name'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//'我是参数传进来的age'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//构造函数this指向实例对象</span>
<span class="token punctuation">}</span>
<span class="token comment">// 构造函数原型的方法</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  objName<span class="token operator">:</span> <span class="token string">'我是obj传进来的name'</span><span class="token punctuation">,</span>
  objAge<span class="token operator">:</span> <span class="token string">'我是obj传进来的age'</span>
<span class="token punctuation">}</span>
<span class="token comment">// 普通函数</span>
<span class="token keyword">function</span> <span class="token function">normalFun</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//'我是参数传进来的name'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//'我是参数传进来的age'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//普通函数this指向绑定bind的第一个参数 也就是例子中的obj</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>objName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//'我是obj传进来的name'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>objAge<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//'我是obj传进来的age'</span>
<span class="token punctuation">}</span>

<span class="token comment">//先测试作为构造函数调用</span>
<span class="token keyword">let</span> bindFun <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token function">myBind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'我是参数传进来的name'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">bindFun</span><span class="token punctuation">(</span><span class="token string">'我是参数传进来的age'</span><span class="token punctuation">)</span>
a<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//123</span>

<span class="token comment">//再测试作为普通函数调用</span>
<span class="token keyword">let</span> bindFun <span class="token operator">=</span> normalFun<span class="token punctuation">.</span><span class="token function">myBind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'我是参数传进来的name'</span><span class="token punctuation">)</span>
 <span class="token function">bindFun</span><span class="token punctuation">(</span><span class="token string">'我是参数传进来的age'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h1 id="七、异步编程"><a href="#七、异步编程" class="header-anchor">#</a> 七、异步编程</h1> <h2 id="_1-js-为什么要异步"><a href="#_1-js-为什么要异步" class="header-anchor">#</a> 1. js 为什么要异步？</h2> <p>JavaScript 语言的执行环境是“单线程”，即代码得一句一句得按顺序依次执行，前面的代码会阻塞后面的代码。**好处：**实现起来比较简单，执行环境相对单纯；**坏处：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。**如：浏览器无响应（假死），可能是因为某一段 js 代码长时间运行（如死循环），导致整个页面卡在这个地方，其他任务无法执行。<strong>为了解决这个问题，js 语言将任务的执行模式分为两种：同步和异步</strong>。</p> <h2 id="_2-异步编程的实现方式"><a href="#_2-异步编程的实现方式" class="header-anchor">#</a> 2. 异步编程的实现方式？</h2> <ol><li><p><strong>回调函数</strong></p> <p>优点：简单、容易理解
缺点：不利于维护，代码耦合高，多个异步操作下容易形成回调地狱。</p></li> <li><p><strong>事件监听</strong></p> <p>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数
缺点：事件驱动型，流程不够清晰</p></li> <li><p><strong>发布/订阅（观察者模式）</strong></p> <p>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</p></li> <li><p><strong>Promise</strong></p> <p>优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；
缺点：编写和理解，相对比较难</p></li> <li><p><strong>Generation</strong></p> <p>优点：函数体内外的数据交换、错误处理机制
缺点：流程管理不方便</p></li> <li><p><strong>async/await</strong></p> <p>优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。
缺点：错误处理机制</p></li></ol> <h2 id="_3-settimeout、promise、async-await-的区别"><a href="#_3-settimeout、promise、async-await-的区别" class="header-anchor">#</a> 3. setTimeout、Promise、Async/Await 的区别</h2> <p><strong>（1）setTimeout</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span> <span class="token comment">//1. 打印 script start</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'settimeout'</span><span class="token punctuation">)</span>   <span class="token comment">// 4. 打印 settimeout</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>   <span class="token comment">//3. 打印 script start</span>
<span class="token comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>（2）Promise</strong></p> <p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> promise1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1 end'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'settimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
<span class="token comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>当JS主线程执行到Promise对象时：</p> <ul><li>promise1.then() 的回调就是一个 task</li> <li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li> <li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li> <li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li></ul> <p><strong>（3）async/await</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
<span class="token comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p> <p>例如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="img/image-20210826221653750.png" alt="image-20210826221653750"></p> <p>func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 30</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p> <h2 id="_4-对-promise-的理解"><a href="#_4-对-promise-的理解" class="header-anchor">#</a> 4. 对 Promise 的理解</h2> <p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，<strong>避免了地狱回调</strong>，它比传统的解决方案回调函数和事件更合理和更强大。</p> <p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p> <p>（1）Promise的实例有<strong>三个状态</strong>:</p> <ul><li>Pending（进行中）</li> <li>Resolved（已完成）</li> <li>Rejected（已拒绝）</li></ul> <p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p> <p>（2）Promise的实例有<strong>两个过程</strong>：</p> <ul><li>pending -&gt; fulfilled : Resolved（已完成）</li> <li>pending -&gt; rejected：Rejected（已拒绝）</li></ul> <p><strong>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</strong></p> <p><strong>Promise的特点：</strong></p> <ul><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li> <li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li></ul> <p><strong>Promise的缺点：</strong></p> <ul><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li> <li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li> <li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul> <p><strong>总结：</strong></p> <p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p> <p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p> <p><strong>注意：在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</strong></p> <h2 id="_5-promise-的基本用法"><a href="#_5-promise-的基本用法" class="header-anchor">#</a> 5. Promise 的基本用法</h2> <h3 id="_1-创建promise对象"><a href="#_1-创建promise对象" class="header-anchor">#</a> （1）创建Promise对象</h3> <p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p> <p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... some code</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* 异步操作成功 */</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>一般情况下都会使用<code>new Promise()</code>来创建promise对象，但是也可以使用<code>promise.resolve</code>和 <code>promise.reject</code>这两个方法：</strong></p> <ul><li><strong>Promise.resolve</strong></li></ul> <p><code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印出11</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p> <p>创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p> <ul><li><strong>Promise.reject</strong></li></ul> <p><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>“我错了，请原谅俺！！”<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>就是下面的代码new Promise的简单形式：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;我错了，请原谅俺！！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>下面是使用resolve方法和reject方法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">testPromise</span><span class="token punctuation">(</span><span class="token parameter">ready</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">&quot;No thanks&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 方法调用</span>
<span class="token function">testPromise</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p> <h4 id="_2-promise方法"><a href="#_2-promise方法" class="header-anchor">#</a> （2）Promise方法</h4> <p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p> <ol><li><strong>then()</strong></li></ol> <p>当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// success</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// failure</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。</p> <p><code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p> <p>当要写有顺序的异步事件时，需要串行时，可以这样写：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">'first'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resovle<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">'second'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resovle<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">'second'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p> <p><strong>2. catch()</strong></p> <p>Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span> 
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>3. all()</strong></p> <p><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>javascript
<span class="token keyword">let</span> promise1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> promise3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span>promise2<span class="token punctuation">,</span>promise3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//结果为：[1,2,3] </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象<code>resolve</code>执行时的值。</p> <p><strong>（4）race()</strong></p> <p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> promise1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       <span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> promise3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span>promise2<span class="token punctuation">,</span>promise3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//结果：2</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token parameter">rej</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rej<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span><span class="token function">timeOutPromise</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>5. finally()</strong></p> <p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>promise
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>···<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>···<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>···<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p> <p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>promise
<span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 语句</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等同于</span>
promise
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 语句</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 语句</span>
    <span class="token keyword">throw</span> error<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p> <h2 id="_6-对-async-await-的理解"><a href="#_6-对-async-await-的理解" class="header-anchor">#</a> 6. 对 async/await 的理解</h2> <p>async/await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">testAsy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">testAsy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="img/image-20210826230550033.png" alt="image-20210826230550033"></p> <p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p> <p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">testAsy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token string">'hello world'</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">testAsy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
result<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>   <span class="token comment">// hello world</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p> <p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p> <p><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p> <h2 id="_7-await-到底在等啥"><a href="#_7-await-到底在等啥" class="header-anchor">#</a> 7. await 到底在等啥？</h2> <p>**await 在等待什么呢？**一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p> <p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;something&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">testAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;hello async&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> v1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> v2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">testAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><img src="img/image-20210826231603761.png" alt="image-20210826231603761"></p> <p>await 表达式的运算结果取决于它等的是什么。</p> <ul><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li> <li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul> <p>来看一个例子：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">testAsy</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
   <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">testAwt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    
  <span class="token keyword">let</span> result <span class="token operator">=</span>  <span class="token keyword">await</span> <span class="token function">testAsy</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3秒钟之后出现hello world</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'cuger'</span><span class="token punctuation">)</span>   <span class="token comment">// 3秒钟之后出现cuger</span>
<span class="token punctuation">}</span>
<span class="token function">testAwt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'cug'</span><span class="token punctuation">)</span>  <span class="token comment">//立即输出cug</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><img src="img/image-20210826231657648.png" alt="image-20210826231657648"></p> <p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以'cug''最先输出，hello world'和‘cuger’是3秒钟后同时出现的。</p> <h2 id="_8-async-await-的优势"><a href="#_8-async-await-的优势" class="header-anchor">#</a> 8. async/await 的优势</h2> <p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p> <p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 */</span>
<span class="token keyword">function</span> <span class="token function">takeLongTime</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">step1</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">step1 with </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">takeLongTime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">step2</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">step2 with </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">takeLongTime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">step3</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">step3 with </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">takeLongTime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>现在用 Promise 方式来实现这三个步骤的处理：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">doIt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">&quot;doIt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> time1 <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>
    <span class="token function">step1</span><span class="token punctuation">(</span>time1<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">time2</span> <span class="token operator">=&gt;</span> <span class="token function">step2</span><span class="token punctuation">(</span>time2<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">time3</span> <span class="token operator">=&gt;</span> <span class="token function">step3</span><span class="token punctuation">(</span>time3<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">result is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">&quot;doIt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">doIt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// c:\var\test&gt;node --harmony_async_await .</span>
<span class="token comment">// step1 with 300</span>
<span class="token comment">// step2 with 500</span>
<span class="token comment">// step3 with 700</span>
<span class="token comment">// result is 900</span>
<span class="token comment">// doIt: 1507.251ms</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>如果用 async/await 来实现呢，会是这样：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">doIt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">&quot;doIt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> time1 <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> time2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">step1</span><span class="token punctuation">(</span>time1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> time3 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">step2</span><span class="token punctuation">(</span>time2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">step3</span><span class="token punctuation">(</span>time3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">result is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">&quot;doIt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">doIt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p> <h2 id="_9-async-await-对比-promise-的优势"><a href="#_9-async-await-对比-promise-的优势" class="header-anchor">#</a> 9. async/await 对比 Promise 的优势</h2> <ul><li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担</li> <li>Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅</li> <li>错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余</li> <li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li></ul> <h2 id="_10-async-await-如何捕获异常"><a href="#_10-async-await-如何捕获异常" class="header-anchor">#</a> 10. async/await 如何捕获异常</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_11-并发与并行的区别"><a href="#_11-并发与并行的区别" class="header-anchor">#</a> 11. 并发与并行的区别？</h2> <p><font color="orange"><strong>并发</strong></font>：指两个或多个事件在同一时间间隔内发生。这些事件<font color="orange">宏观上是同时发生</font>的，但<font color="orange">微观上是交替发生</font>的。与之容易混淆的是<font color="red"><strong>并行</strong></font>：并行指的是在同一个时刻同时发生。</p> <blockquote><p><strong>并行</strong>：你现在同时跟两个女朋友约会
<strong>并发</strong>：你9:00-10:00跟女友A约会，10:00-11:00跟女友B约会</p></blockquote> <h2 id="_12-什么是回调函数-回调函数有什么缺点-如何解决回调地狱问题"><a href="#_12-什么是回调函数-回调函数有什么缺点-如何解决回调地狱问题" class="header-anchor">#</a> 12. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</h2> <p>以下代码就是一个回调函数的例子：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理逻辑</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>回调函数有一个致命的<strong>弱点，就是容易写出回调地狱</strong>（Callback hell）。假设多个请求存在依赖性，可能会有如下代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理逻辑</span>
    <span class="token function">ajax</span><span class="token punctuation">(</span>url1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 处理逻辑</span>
        <span class="token function">ajax</span><span class="token punctuation">(</span>url2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 处理逻辑</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>以上代码看起来不利于阅读和维护，当然，也可以把函数分开来写：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">firstAjax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ajax</span><span class="token punctuation">(</span>url1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理逻辑</span>
    <span class="token function">secondAjax</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">secondAjax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ajax</span><span class="token punctuation">(</span>url2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理逻辑</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 处理逻辑</span>
  <span class="token function">firstAjax</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。回调地狱的根本问题就是：</p> <ol><li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li> <li>嵌套函数一多，就很难处理错误</li></ol> <p>当然，回调函数还存在着别的几个缺点，比如不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code>。</p> <p><strong>解决：</strong></p> <ol><li>Generator</li> <li>Promise</li> <li>async 及 await</li></ol> <h2 id="_13-settimeout、setinterval、requestanimationframe-各有什么特点"><a href="#_13-settimeout、setinterval、requestanimationframe-各有什么特点" class="header-anchor">#</a> 13. setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h2> <p>与 setTimeout、setInterval 不同，requestAnimationFrame 不需要设置时间间隔，这有什么好处呢？</p> <p>计时器一直是 JavaScript 动画的核心技术，而编写动画循环的核心是要知道延迟时间多长合适。一方面循环间隔必须足够短，这样才能让不同的动画效果显得平滑顺畅，另一方面循环间隔要足够的长，这样才能保证浏览器有能力渲染产生的变化。大多数电脑显示器的刷新频率是60Hz，大概相当于每秒重绘60次(16.7ms)。大多数浏览器都会对重绘操作加以限制，不会超出显示器的重绘频率。</p> <p>而 setTimeout 和 setInterval 的缺点是他们都不够精确。它们内在的运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器 UI 线程队列中等待执行的时间，如果队列中已经加入了其他任务，那么动画的执行要等前面的任务结束之后才会执行。</p> <p>requestAnimationFrame采用的是系统时间间隔，保证了最佳绘制效率。不会因间隔时间过短，造成过度绘制，增加开销；也不会因时间间隔太长，造成动画卡顿。它能够让各种网页动画有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p> <p><strong>特点</strong></p> <ol><li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。</li> <li>在隐藏或不可见的元素中，requsetAnimationFrame 将不会进行重绘或回流，这就意味着更少的 CPU、GPU 和内存使用量。</li> <li>requestAnimationFrame 是浏览器专门提供的 api，在运行时浏览器会自动优化方法的调用，并且页面不是激活状态下，动画会暂停执行，有效节省 CPU 开销。</li></ol> <h1 id="八、面向对象"><a href="#八、面向对象" class="header-anchor">#</a> 八、面向对象</h1> <h2 id="_1-对象创建的方式有哪些"><a href="#_1-对象创建的方式有哪些" class="header-anchor">#</a> 1. 对象创建的方式有哪些？</h2> <ol><li><p>通过<strong>字面量</strong>方式创建</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'dongjc'</span><span class="token punctuation">,</span> <span class="token function-variable function">work</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'write coding'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//创建空对象</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'dudu'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>通过<strong>构造函数</strong>方式创建</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">函数名</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>通过 <code>Object</code> 方式创建</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;dongjc&quot;</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function-variable function">Introduce</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;My name is &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">&quot;.I'm &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">Introduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>使用<strong>工厂模式</strong>创建对象</p> <p>这种方式是使用一个函数来创建对象，减少重复代码，解决了前面三种方式的代码冗余的问题，但是方法不能共享的问题还是存在。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>use strict'<span class="token punctuation">;</span>

<span class="token comment">// 使用工厂模式创建对象</span>
<span class="token comment">// 定义一个工厂方法</span>
<span class="token keyword">function</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token string">'zhang'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//缺点：调用的还是不同的方法</span>
<span class="token comment">//优点：解决了前面的代码重复的问题</span>
<span class="token function">alert</span><span class="token punctuation">(</span>o1<span class="token punctuation">.</span>sayName <span class="token operator">===</span> o2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></li> <li><p>通过<strong>原型模式</strong>创建对象</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
	<span class="token string">'use strict'</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 *  原型模式创建对象
	 */</span>
	<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

	<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'animal'</span><span class="token punctuation">;</span>
	<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">var</span> a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> a2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	a1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">alert</span><span class="token punctuation">(</span>a1<span class="token punctuation">.</span>sayName <span class="token operator">===</span> a2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
	<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//function Animal(){}</span>
	<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Animal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div></li></ol> <h2 id="_2-对象继承的方式有哪些"><a href="#_2-对象继承的方式有哪些" class="header-anchor">#</a> 2. 对象继承的方式有哪些？</h2> <p><strong>继承可以使得子类具有父类别的各种属性和方法</strong>，而不需要再次编写相同的代码。</p> <p>在子类继承父类的同时，子类可以重新定义某些属性，并重写某些方法，即覆盖父类的原有属性和方法，使其获得与父类不同的功能。</p> <h3 id="实现方式"><a href="#实现方式" class="header-anchor">#</a> 实现方式</h3> <h4 id="原型链继承"><a href="#原型链继承" class="header-anchor">#</a> 原型链继承</h4> <p>第一种是以原型链的方式来实现继承，但是这种实现方式存在的<strong>缺点</strong>是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p> <p><strong>实现本质</strong></p> <p>重写子类构造函数的原型对象，使其原型对象指向超类的实例</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;green&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;blue&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSubValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty
<span class="token punctuation">}</span>
<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><img src="img/image-20210827143014147.png" alt="image-20210827143014147"></p> <h4 id="借用构造函数继承"><a href="#借用构造函数继承" class="header-anchor">#</a> 借用构造函数继承</h4> <p>为了解决原型链继承中解决原型中包含引用类型值带来的问题，开发人员开始使用一种借用构造函数来实现继承，即在子类型构造函数中调用超类型构造函数。</p> <p><strong>优点</strong></p> <ul><li>可以解决原型链中超类型中包含引用类型值带来的问题</li> <li>可以向子类型构造函数中向超类型构造函数中传递参数</li></ul> <p><strong>缺点</strong></p> <ul><li>在超类型构造函数原型中定义的属性和方法对子类不可见</li> <li>由于超类原型上的方法对子类不可见（在超类原型上的方法无法被实例继承），故方法都在构造函数中定义，则函数复用就无从谈起</li></ul> <p>代码如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;green&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;yellow&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">&quot;dididi&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><img src="img/image-20210120130645749.png" alt="image-20210120130645749"></p> <h4 id="组合继承"><a href="#组合继承" class="header-anchor">#</a> 组合继承</h4> <p>组合继承指的是将原型链和借用构造函数技术组合在一起，发挥二者之长的一种继承模式。组合继承思想是使用原型链实现对原型的属性和方法的继承，通过借用构造函数实现对实例属性的继承。</p> <p><strong>优点</strong></p> <ul><li>避免了原型链继承和借用构造函数的缺陷，既能实现超类原型上方法和属性的继承，也能像超类构造函数中传参</li></ul> <p><strong>缺点</strong></p> <ul><li>会调用两次构造函数，一次是构造函数中，一次是原型对象赋值时</li></ul> <p>代码如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">&quot;instance&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">&quot;instance1&quot;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
instance<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p><img src="img/image-20210120141134782.png" alt="image-20210120141134782"></p> <h4 id="原型式继承"><a href="#原型式继承" class="header-anchor">#</a> 原型式继承</h4> <p>原型式继承是借助原型可以基于已有的对象创建新对象，同时还不必因为创建自定义类型。先创建一个临时性的构造函数，然后将传入的对象作为整个构造函数的原型，最后返回这个临时类型的一个新实例。从本质上来讲，对传入的对象做了一次浅复制。且必须有一个对象作为另一个对象的继承。代码如下：</p> <p><strong>缺点</strong></p> <ul><li>包含引用类型值的属性始终都会共享相应的值</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>es5通过新增<code>Object.create(参数1, 参数2)</code>方法规范了原型式继承；第一个参数的作用是用作新对象原型的对象，参数2是一个可为新对象定义额外属性的对象。例如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&quot;dididi&quot;</span><span class="token punctuation">,</span>
    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> anotherPerson <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token punctuation">{</span>
        value<span class="token operator">:</span> <span class="token string">&quot;dadada&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>anotherPerson<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><img src="img/image-20210120142615772.png" alt="image-20210120142615772"></p> <h4 id="寄生式继承"><a href="#寄生式继承" class="header-anchor">#</a> 寄生式继承</h4> <p>寄生式继承的思路是创建一个仅用于封装继承过程的函数，在函数内部增强对象，最后再返回对象。代码如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span> <span class="token comment">// 通过调用函数创建一个对象</span>
    clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	 <span class="token comment">// 以某种方式增强这个对象</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    reeturn clone 				 <span class="token comment">// 返回这个对象</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="header-anchor">#</a> 寄生组合式继承</h4> <p>组合继承会调用两次超类型构造函数，一次是创建子类型原型的时候，一次是子类型构造函数内部，寄生组合式继承就是为了解决这一问题而出现的。</p> <p><strong>优点</strong></p> <ul><li>集寄生式继承和组合继承优点于一体，是实现基于类型继承的最有效方式。</li> <li>只调用了一次SuperType构造函数，避免了SubType.prototype上不必要也用不到的属性，因此可以说这个例子的效率更高。而且，原型链仍然保持不变。</li></ul> <p>代码如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">inheritProrotype</span><span class="token punctuation">(</span><span class="token parameter">SubType<span class="token punctuation">,</span> SuperType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> prototype <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// 创建对象</span>
    prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType <span class="token comment">// 增强对象</span>
    <span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype <span class="token comment">// 指定对象</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;green&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;yellow&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;blue&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>
<span class="token function">inheritProrotype</span><span class="token punctuation">(</span>SubType<span class="token punctuation">,</span> SuperType<span class="token punctuation">)</span>
<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">&quot;dididi&quot;</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">&quot;bibibi&quot;</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p><img src="img/image-20210120143726975.png" alt="image-20210120143726975"></p> <h1 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="header-anchor">#</a> 九、垃圾回收与内存泄漏</h1> <h2 id="_1-垃圾回收机制"><a href="#_1-垃圾回收机制" class="header-anchor">#</a> 1. 垃圾回收机制</h2> <h3 id="垃圾回收的概念"><a href="#垃圾回收的概念" class="header-anchor">#</a> 垃圾回收的概念</h3> <p><strong>垃圾回收</strong>：JavaScript 代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p> <p><strong>回收机制</strong>：</p> <ul><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li> <li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续到页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li> <li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li></ul> <h3 id="v8-的垃圾回收机制"><a href="#v8-的垃圾回收机制" class="header-anchor">#</a> V8 的垃圾回收机制</h3> <p>通常情况下，垃圾数据回收分为<strong>手动回收</strong>和<strong>自动回收</strong>两种策略。</p> <p><strong>手动回收策略</strong>，何时分配内存、何时销毁内存都是由代码控制的。</p> <p><strong>自动回收策略</strong>，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。</p> <p><strong>JavaScript 中调用栈中的数据回收</strong></p> <p>JavaScript 引擎会通过向下移动 ESP(记录当前执行状态的指针) 来销毁该函数保存在栈中的执行上下文。</p> <p><strong>JavaScript 堆中的数据回收</strong></p> <p>在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</p> <p>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p> <ul><li>副垃圾回收器，主要负责新生代的垃圾回收。</li> <li>主垃圾回收器，主要负责老生代的垃圾回收。</li></ul> <p>不论什么类型的垃圾回收器，它们都有一套共同的执行流程。</p> <ol><li>第一步是<strong>标记</strong>空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</li> <li>第二步是<strong>回收</strong>非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</li> <li>第三步是做<strong>内存整理</strong>。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要<strong>整理</strong>这些内存碎片。(这步其实是可选的，因为有的垃圾回收器不会产生内存碎片)。</li></ol> <p><strong>新生代中垃圾回收</strong></p> <p>新生代中用 <strong>Scavenge 算法</strong>来处理，把新生代空间对半划分为两个区域，<u>一半是对象区域，一半是空闲区域</u>。新加入的对象都会存放到对象区域( Form 空间)，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p> <p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到**空闲区域( To 空间)**中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p> <p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p> <p>为了执行效率，一般新生区的空间会被设置得比较小,也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p> <p><strong>老生代中的垃圾回收</strong></p> <p>老生代中用<strong>标记 - 清除（Mark-Sweep）<strong>的算法来处理。首先是标记过程阶段，标记阶段就是从一组根元素开始，递归遍历这组根元素(遍历调用栈)，在这个遍历过程中，能到达的元素称为</strong>活动对象</strong>,没有到达的元素就可以判断为<strong>垃圾数据</strong>然后在遍历过程中标记，标记完成后就进行清除过程。它和副垃圾回收器的垃圾清除过程完全不同，这个的清除过程是删除标记数据。</p> <p>清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了<code>标记 - 整理（Mark-Compact）</code>算法，这个标记过程仍然与<code>标记 - 清除算法</code>里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，从而让存活对象占用连续的内存块。</p> <p><strong>全停顿</strong></p> <p>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿</strong>。</p> <p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果执行垃圾回收的过程中，占用主线程时间过久，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在垃圾回收过程中无法执行，这将会造成页面的卡顿现象。</p> <p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记（Incremental Marking）**算法.</p> <p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p> <h3 id="减少垃圾回收"><a href="#减少垃圾回收" class="header-anchor">#</a> 减少垃圾回收</h3> <p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p> <ul><li>**对数组进行优化：**在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，<strong>可以将数组的长度设置为0，以此来达到清空数组的目的</strong>。</li> <li>**对<code>object</code>进行优化：**对象尽量复用，对于不再使用的对象，就将其设置为 null，尽快被回收。</li> <li>**对函数进行优化：**在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li></ul> <h2 id="_2-哪些情况会导致内存泄漏"><a href="#_2-哪些情况会导致内存泄漏" class="header-anchor">#</a> 2. 哪些情况会导致内存泄漏</h2> <p>以下四种情况会造成内存的泄漏：</p> <ul><li>**意外的全局变量：**由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li> <li>**被遗忘的计时器或回调函数：**设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li> <li>**脱离 DOM 的引用：**获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li> <li>**闭包：**不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/zyhblog/blog/mian-jing/2-html.html" class="prev">
            HTML面试题
          </a></span> <span class="next"><a href="/zyhblog/blog/mian-jing/4-xing-neng-you-hua.html">
            性能优化
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-javascript-有哪些数据类型-它们的区别" class="sidebar-link reco-side-_1-javascript-有哪些数据类型-它们的区别" data-v-70334359>1. JavaScript 有哪些数据类型，它们的区别？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-数据类型检测的方式有哪些" class="sidebar-link reco-side-_2-数据类型检测的方式有哪些" data-v-70334359>2. 数据类型检测的方式有哪些</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_3-判断数组的方式" class="sidebar-link reco-side-_3-判断数组的方式" data-v-70334359>3. 判断数组的方式</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_4-null-和-undefined-的区别" class="sidebar-link reco-side-_4-null-和-undefined-的区别" data-v-70334359>4. null 和 undefined 的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_5-typeof-null-的结果是什么-为什么" class="sidebar-link reco-side-_5-typeof-null-的结果是什么-为什么" data-v-70334359>5. typeof null 的结果是什么，为什么？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_6-instanceof-操作符的实现原理及实现" class="sidebar-link reco-side-_6-instanceof-操作符的实现原理及实现" data-v-70334359>6. instanceof 操作符的实现原理及实现</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_7-为什么-0-1-0-2-0-3-如何让其相等" class="sidebar-link reco-side-_7-为什么-0-1-0-2-0-3-如何让其相等" data-v-70334359>7. 为什么 0.1+0.2 !== 0.3，如何让其相等</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_8-如何获取安全的-undefined-值" class="sidebar-link reco-side-_8-如何获取安全的-undefined-值" data-v-70334359>8. 如何获取安全的 undefined 值</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_9-typeof-nan-的结果是什么" class="sidebar-link reco-side-_9-typeof-nan-的结果是什么" data-v-70334359>9. typeof NaN 的结果是什么</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_10-isnan-和-number-isnan-函数的区别" class="sidebar-link reco-side-_10-isnan-和-number-isnan-函数的区别" data-v-70334359>10. isNaN 和 Number.isNaN 函数的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_11-操作符的强制类型转换规则" class="sidebar-link reco-side-_11-操作符的强制类型转换规则" data-v-70334359>11. == 操作符的强制类型转换规则</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_12-获取对象原始值" class="sidebar-link reco-side-_12-获取对象原始值" data-v-70334359>12. 获取对象原始值</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_13-其他类型转-number" class="sidebar-link reco-side-_13-其他类型转-number" data-v-70334359>13. 其他类型转 number</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_14-其他类型转-string" class="sidebar-link reco-side-_14-其他类型转-string" data-v-70334359>14. 其他类型转 string</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_15-转为-boolean" class="sidebar-link reco-side-_15-转为-boolean" data-v-70334359>15. 转为 boolean</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_16-和-操作符的返回值" class="sidebar-link reco-side-_16-和-操作符的返回值" data-v-70334359>16. || 和 &amp;&amp; 操作符的返回值</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_17-object-is-与比较操作符-、-的区别" class="sidebar-link reco-side-_17-object-is-与比较操作符-、-的区别" data-v-70334359>17. Object.is() 与比较操作符“\===”、“\==”的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_18-什么是-javascript-中的包装类型" class="sidebar-link reco-side-_18-什么是-javascript-中的包装类型" data-v-70334359>18. 什么是 JavaScript 中的包装类型</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_19-引用类型与基本包装类型的区别" class="sidebar-link reco-side-_19-引用类型与基本包装类型的区别" data-v-70334359>19. 引用类型与基本包装类型的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_20-javascript-中如何进行隐式类型转换" class="sidebar-link reco-side-_20-javascript-中如何进行隐式类型转换" data-v-70334359>20.  JavaScript 中如何进行隐式类型转换？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_21-操作符什么时候用于字符串的拼接" class="sidebar-link reco-side-_21-操作符什么时候用于字符串的拼接" data-v-70334359>21. + 操作符什么时候用于字符串的拼接？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_22-object-assign和扩展运算法是深拷贝还是浅拷贝-两者区别" class="sidebar-link reco-side-_22-object-assign和扩展运算法是深拷贝还是浅拷贝-两者区别" data-v-70334359>22. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-let-const-var-的区别" class="sidebar-link reco-side-_1-let-const-var-的区别" data-v-70334359>1. let const var 的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-const-对象的属性可以修改吗" class="sidebar-link reco-side-_2-const-对象的属性可以修改吗" data-v-70334359>2. const 对象的属性可以修改吗？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_3-如果-new-一个箭头函数会怎么样" class="sidebar-link reco-side-_3-如果-new-一个箭头函数会怎么样" data-v-70334359>3. 如果 new 一个箭头函数会怎么样？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_4-箭头函数与普通函数的区别" class="sidebar-link reco-side-_4-箭头函数与普通函数的区别" data-v-70334359>4. 箭头函数与普通函数的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_5-箭头函数的-this-指向哪里" class="sidebar-link reco-side-_5-箭头函数的-this-指向哪里" data-v-70334359>5. 箭头函数的 this 指向哪里？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_6-扩展运算符的作用以及使用场景" class="sidebar-link reco-side-_6-扩展运算符的作用以及使用场景" data-v-70334359>6. 扩展运算符的作用以及使用场景</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_7-proxy-可以实现什么功能" class="sidebar-link reco-side-_7-proxy-可以实现什么功能" data-v-70334359>7. Proxy 可以实现什么功能？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_8-对对象与数组解构的理解" class="sidebar-link reco-side-_8-对对象与数组解构的理解" data-v-70334359>8. 对对象与数组解构的理解</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_9-如何提取高度嵌套的对象里的指定属性" class="sidebar-link reco-side-_9-如何提取高度嵌套的对象里的指定属性" data-v-70334359>9. 如何提取高度嵌套的对象里的指定属性？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_10-对-rest-参数的理解" class="sidebar-link reco-side-_10-对-rest-参数的理解" data-v-70334359>10. 对 rest 参数的理解</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_11-es6中模板语法与字符串处理" class="sidebar-link reco-side-_11-es6中模板语法与字符串处理" data-v-70334359>11. ES6中模板语法与字符串处理</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-new-操作符的实现原理" class="sidebar-link reco-side-_1-new-操作符的实现原理" data-v-70334359>1. new 操作符的实现原理</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-map和object的区别" class="sidebar-link reco-side-_2-map和object的区别" data-v-70334359>2. map和Object的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_3-map和weakmap的区别" class="sidebar-link reco-side-_3-map和weakmap的区别" data-v-70334359>3. map和weakMap的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_4-javascript-有哪些内置对象" class="sidebar-link reco-side-_4-javascript-有哪些内置对象" data-v-70334359>4. JavaScript 有哪些内置对象</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_5-常用的正则表达式有哪些" class="sidebar-link reco-side-_5-常用的正则表达式有哪些" data-v-70334359>5. 常用的正则表达式有哪些？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_6-对-json-的理解" class="sidebar-link reco-side-_6-对-json-的理解" data-v-70334359>6. 对 JSON 的理解</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_7-javascript-脚本延迟加载的方式有哪些" class="sidebar-link reco-side-_7-javascript-脚本延迟加载的方式有哪些" data-v-70334359>7. JavaScript 脚本延迟加载的方式有哪些？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_8-javascript-类数组对象的定义" class="sidebar-link reco-side-_8-javascript-类数组对象的定义" data-v-70334359>8. JavaScript 类数组对象的定义</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_9-数组有哪些原生方法" class="sidebar-link reco-side-_9-数组有哪些原生方法" data-v-70334359>9. 数组有哪些原生方法？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_10-unicode、utf-8、utf-16、utf-32的区别" class="sidebar-link reco-side-_10-unicode、utf-8、utf-16、utf-32的区别" data-v-70334359>10. Unicode、UTF-8、UTF-16、UTF-32的区别？</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-unicode" class="sidebar-link reco-side-_1-unicode" data-v-70334359>（1）Unicode</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-utf-8" class="sidebar-link reco-side-_2-utf-8" data-v-70334359>（2）UTF-8</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_3-utf-16" class="sidebar-link reco-side-_3-utf-16" data-v-70334359>（3）UTF-16</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_4-utf-32" class="sidebar-link reco-side-_4-utf-32" data-v-70334359>（4）UTF-32</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_5-总结" class="sidebar-link reco-side-_5-总结" data-v-70334359>（5）总结</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_11-常见的位运算符有哪些-其计算规则是什么" class="sidebar-link reco-side-_11-常见的位运算符有哪些-其计算规则是什么" data-v-70334359>11. 常见的位运算符有哪些？其计算规则是什么？</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-按位与运算符" class="sidebar-link reco-side-_1-按位与运算符" data-v-70334359>1. 按位与运算符（&amp;）</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-按位或运算符" class="sidebar-link reco-side-_2-按位或运算符" data-v-70334359>2. 按位或运算符（|）</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_3-异或运算符" class="sidebar-link reco-side-_3-异或运算符" data-v-70334359>3. 异或运算符（^）</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_4-取反运算符" class="sidebar-link reco-side-_4-取反运算符" data-v-70334359>4. 取反运算符 (~)</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_5-左移运算符" class="sidebar-link reco-side-_5-左移运算符" data-v-70334359>5. 左移运算符（&lt;&lt;）</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_6-右移运算符" class="sidebar-link reco-side-_6-右移运算符" data-v-70334359>6. 右移运算符（&gt;&gt;）</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_7-原码、补码、反码" class="sidebar-link reco-side-_7-原码、补码、反码" data-v-70334359>7. 原码、补码、反码</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_12-为什么函数的-arguments-参数是类数组而不是数组-如何遍历类数组" class="sidebar-link reco-side-_12-为什么函数的-arguments-参数是类数组而不是数组-如何遍历类数组" data-v-70334359>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_13-什么是-dom-和-bom" class="sidebar-link reco-side-_13-什么是-dom-和-bom" data-v-70334359>13. 什么是 DOM 和 BOM？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_14-escape、encodeurl、encodeurlcomponent-的区别" class="sidebar-link reco-side-_14-escape、encodeurl、encodeurlcomponent-的区别" data-v-70334359>14. escape、encodeURL、encodeURLComponent 的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_15-对-ajax-的理解-实现一个-ajax-请求" class="sidebar-link reco-side-_15-对-ajax-的理解-实现一个-ajax-请求" data-v-70334359>15. 对 Ajax 的理解，实现一个 Ajax 请求</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_16-javascript-为什么要进行变量提升-它导致了什么问题" class="sidebar-link reco-side-_16-javascript-为什么要进行变量提升-它导致了什么问题" data-v-70334359>16. JavaScript 为什么要进行变量提升，它导致了什么问题？</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#前言" class="sidebar-link reco-side-前言" data-v-70334359>前言：</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-什么是变量提升" class="sidebar-link reco-side-_1-什么是变量提升" data-v-70334359>1. 什么是变量提升？</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-为什么进行变量提升" class="sidebar-link reco-side-_2-为什么进行变量提升" data-v-70334359>2. 为什么进行变量提升？</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_3-变量提升导致的问题" class="sidebar-link reco-side-_3-变量提升导致的问题" data-v-70334359>3. 变量提升导致的问题</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_17-什么是尾调用-使用尾调用有什么好处" class="sidebar-link reco-side-_17-什么是尾调用-使用尾调用有什么好处" data-v-70334359>17. 什么是尾调用，使用尾调用有什么好处?</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#什么是尾调用" class="sidebar-link reco-side-什么是尾调用" data-v-70334359>什么是尾调用</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#尾调用优化" class="sidebar-link reco-side-尾调用优化" data-v-70334359>尾调用优化</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#注意" class="sidebar-link reco-side-注意" data-v-70334359>注意</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_18-es6-模块与-commonjs-模块有什么异同" class="sidebar-link reco-side-_18-es6-模块与-commonjs-模块有什么异同" data-v-70334359>18. ES6 模块与 COMMONJS 模块有什么异同？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_19-常见的-dom-操作有哪些" class="sidebar-link reco-side-_19-常见的-dom-操作有哪些" data-v-70334359>19. 常见的 DOM 操作有哪些</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-dom-节点的获取" class="sidebar-link reco-side-_1-dom-节点的获取" data-v-70334359>1）DOM 节点的获取</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-dom-节点的创建" class="sidebar-link reco-side-_2-dom-节点的创建" data-v-70334359>2）DOM 节点的创建</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_3-dom-节点的删除" class="sidebar-link reco-side-_3-dom-节点的删除" data-v-70334359>3）DOM 节点的删除</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_4-修改-dom-元素" class="sidebar-link reco-side-_4-修改-dom-元素" data-v-70334359>4）修改 DOM 元素</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_20-use-strict-是什么意思-使用它区别是什么" class="sidebar-link reco-side-_20-use-strict-是什么意思-使用它区别是什么" data-v-70334359>20. use strict 是什么意思？使用它区别是什么？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_21-如何判断一个对象是否属于某个类" class="sidebar-link reco-side-_21-如何判断一个对象是否属于某个类" data-v-70334359>21. 如何判断一个对象是否属于某个类</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_22-强类型语言和弱类型语言的区别" class="sidebar-link reco-side-_22-强类型语言和弱类型语言的区别" data-v-70334359>22. 强类型语言和弱类型语言的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_23-解释型语言和编译型语言的区别" class="sidebar-link reco-side-_23-解释型语言和编译型语言的区别" data-v-70334359>23. 解释型语言和编译型语言的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_24-for-in-和-for-of-的区别" class="sidebar-link reco-side-_24-for-in-和-for-of-的区别" data-v-70334359>24. for...in 和 for...of 的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_25-如何使用-for-of-遍历对象" class="sidebar-link reco-side-_25-如何使用-for-of-遍历对象" data-v-70334359>25. 如何使用 for...of 遍历对象</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_26-ajax、axios、fetch-的区别" class="sidebar-link reco-side-_26-ajax、axios、fetch-的区别" data-v-70334359>26. ajax、axios、fetch 的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_27-数组的遍历方法有哪些" class="sidebar-link reco-side-_27-数组的遍历方法有哪些" data-v-70334359>27. 数组的遍历方法有哪些</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_28-foreach-和-map-方法有什么区别" class="sidebar-link reco-side-_28-foreach-和-map-方法有什么区别" data-v-70334359>28. forEach 和 map 方法有什么区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_29-vo-ao-go" class="sidebar-link reco-side-_29-vo-ao-go" data-v-70334359>29. VO AO GO</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#底层渲染过程" class="sidebar-link reco-side-底层渲染过程" data-v-70334359>底层渲染过程</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#堆栈定义" class="sidebar-link reco-side-堆栈定义" data-v-70334359>堆栈定义</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#栈内存和堆内存的区别" class="sidebar-link reco-side-栈内存和堆内存的区别" data-v-70334359>栈内存和堆内存的区别</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#执行过程" class="sidebar-link reco-side-执行过程" data-v-70334359>执行过程</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-对原型、原型链的理解" class="sidebar-link reco-side-_1-对原型、原型链的理解" data-v-70334359>1. 对原型、原型链的理解</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-原型链的终点是什么-如何打印出原型链的终点" class="sidebar-link reco-side-_2-原型链的终点是什么-如何打印出原型链的终点" data-v-70334359>2. 原型链的终点是什么？如何打印出原型链的终点？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_3-如何获得对象非原型链上的属性" class="sidebar-link reco-side-_3-如何获得对象非原型链上的属性" data-v-70334359>3. 如何获得对象非原型链上的属性？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-对闭包的理解" class="sidebar-link reco-side-_1-对闭包的理解" data-v-70334359>1. 对闭包的理解</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-对作用域、作用域链的理解" class="sidebar-link reco-side-_2-对作用域、作用域链的理解" data-v-70334359>2. 对作用域、作用域链的理解</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#作用域" class="sidebar-link reco-side-作用域" data-v-70334359>作用域</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#词法作用域" class="sidebar-link reco-side-词法作用域" data-v-70334359>词法作用域</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#作用域链" class="sidebar-link reco-side-作用域链" data-v-70334359>作用域链</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_3-对执行上下文的理解" class="sidebar-link reco-side-_3-对执行上下文的理解" data-v-70334359>3. 对执行上下文的理解</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-对-this-对象的理解" class="sidebar-link reco-side-_1-对-this-对象的理解" data-v-70334359>1. 对 this 对象的理解</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-call-和-apply-的区别" class="sidebar-link reco-side-_2-call-和-apply-的区别" data-v-70334359>2. call 和 apply 的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_3-call-和-bind-的区别" class="sidebar-link reco-side-_3-call-和-bind-的区别" data-v-70334359>3. call 和 bind 的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_4-实现-call、apply-以及-bind-函数" class="sidebar-link reco-side-_4-实现-call、apply-以及-bind-函数" data-v-70334359>4. 实现 call、apply 以及 bind 函数</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-js-为什么要异步" class="sidebar-link reco-side-_1-js-为什么要异步" data-v-70334359>1. js 为什么要异步？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-异步编程的实现方式" class="sidebar-link reco-side-_2-异步编程的实现方式" data-v-70334359>2. 异步编程的实现方式？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_3-settimeout、promise、async-await-的区别" class="sidebar-link reco-side-_3-settimeout、promise、async-await-的区别" data-v-70334359>3. setTimeout、Promise、Async/Await 的区别</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_4-对-promise-的理解" class="sidebar-link reco-side-_4-对-promise-的理解" data-v-70334359>4. 对 Promise 的理解</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_5-promise-的基本用法" class="sidebar-link reco-side-_5-promise-的基本用法" data-v-70334359>5. Promise 的基本用法</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-创建promise对象" class="sidebar-link reco-side-_1-创建promise对象" data-v-70334359>（1）创建Promise对象</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_6-对-async-await-的理解" class="sidebar-link reco-side-_6-对-async-await-的理解" data-v-70334359>6. 对 async/await 的理解</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_7-await-到底在等啥" class="sidebar-link reco-side-_7-await-到底在等啥" data-v-70334359>7. await 到底在等啥？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_8-async-await-的优势" class="sidebar-link reco-side-_8-async-await-的优势" data-v-70334359>8. async/await 的优势</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_9-async-await-对比-promise-的优势" class="sidebar-link reco-side-_9-async-await-对比-promise-的优势" data-v-70334359>9. async/await 对比 Promise 的优势</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_10-async-await-如何捕获异常" class="sidebar-link reco-side-_10-async-await-如何捕获异常" data-v-70334359>10. async/await 如何捕获异常</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_11-并发与并行的区别" class="sidebar-link reco-side-_11-并发与并行的区别" data-v-70334359>11. 并发与并行的区别？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_12-什么是回调函数-回调函数有什么缺点-如何解决回调地狱问题" class="sidebar-link reco-side-_12-什么是回调函数-回调函数有什么缺点-如何解决回调地狱问题" data-v-70334359>12. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_13-settimeout、setinterval、requestanimationframe-各有什么特点" class="sidebar-link reco-side-_13-settimeout、setinterval、requestanimationframe-各有什么特点" data-v-70334359>13. setTimeout、setInterval、requestAnimationFrame 各有什么特点？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-对象创建的方式有哪些" class="sidebar-link reco-side-_1-对象创建的方式有哪些" data-v-70334359>1. 对象创建的方式有哪些？</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-对象继承的方式有哪些" class="sidebar-link reco-side-_2-对象继承的方式有哪些" data-v-70334359>2. 对象继承的方式有哪些？</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#实现方式" class="sidebar-link reco-side-实现方式" data-v-70334359>实现方式</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_1-垃圾回收机制" class="sidebar-link reco-side-_1-垃圾回收机制" data-v-70334359>1. 垃圾回收机制</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#垃圾回收的概念" class="sidebar-link reco-side-垃圾回收的概念" data-v-70334359>垃圾回收的概念</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#v8-的垃圾回收机制" class="sidebar-link reco-side-v8-的垃圾回收机制" data-v-70334359>V8 的垃圾回收机制</a></li><li class="level-3" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#减少垃圾回收" class="sidebar-link reco-side-减少垃圾回收" data-v-70334359>减少垃圾回收</a></li><li class="level-2" data-v-70334359><a href="/zyhblog/blog/mian-jing/3-js.html#_2-哪些情况会导致内存泄漏" class="sidebar-link reco-side-_2-哪些情况会导致内存泄漏" data-v-70334359>2. 哪些情况会导致内存泄漏</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><canvas id="vuepress-canvas-cursor"></canvas><div></div><APlayer audio="" fixed="true" mini="true" autoplay="autoplay" theme="#b7daff" loop="loop" order="random" preload="auto" volume="0.15" mutex="true" lrc-type="0" list-max-height="250" storage-name="vuepress-plugin-meting" id="aplayer-fixed"></APlayer></div></div>
    <script src="/zyhblog/assets/js/app.f03e268b.js" defer></script><script src="/zyhblog/assets/js/3.bb78181b.js" defer></script><script src="/zyhblog/assets/js/1.d4860738.js" defer></script><script src="/zyhblog/assets/js/17.31483a01.js" defer></script>
  </body>
</html>
