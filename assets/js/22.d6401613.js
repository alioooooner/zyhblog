(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{573:function(_,v,t){"use strict";t.r(v);var s=t(6),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"http-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-协议"}},[_._v("#")]),_._v(" HTTP 协议")]),_._v(" "),t("h2",{attrs:{id:"_1-get-和-post-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-get-和-post-的区别"}},[_._v("#")]),_._v(" 1. GET 和 POST 的区别")]),_._v(" "),t("ol",[t("li",[_._v("GET在浏览器回退时是无害的，而POST会再次提交请求")]),_._v(" "),t("li",[_._v("GET请求会被浏览器主动缓存，而POST不会，除非手动设置")]),_._v(" "),t("li",[_._v("GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留")]),_._v(" "),t("li",[_._v("GET请求在URL中传送的参数是有长度限制的，而POST没有限制")]),_._v(" "),t("li",[_._v("GET参数通过URL传递，POST放在Request body中")]),_._v(" "),t("li",[_._v("get 的参数数据类型只允许 ASCII，post 的参数数据类型无限制")])]),_._v(" "),t("h2",{attrs:{id:"_2-put-和-post-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-put-和-post-的区别"}},[_._v("#")]),_._v(" 2. PUT 和 POST 的区别")]),_._v(" "),t("ol",[t("li",[_._v("put 用于更新数据，post 用于提交数据")])]),_._v(" "),t("h2",{attrs:{id:"_3-常见的-http-请求头和响应头"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-常见的-http-请求头和响应头"}},[_._v("#")]),_._v(" 3. 常见的 HTTP 请求头和响应头")]),_._v(" "),t("h3",{attrs:{id:"常见的-request-headers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的-request-headers"}},[_._v("#")]),_._v(" 常见的 Request Headers")]),_._v(" "),t("ul",[t("li",[_._v("Accept 浏览器可接收的数据格式")]),_._v(" "),t("li",[_._v("Accept-Charset:浏览器能够显示的字符集")]),_._v(" "),t("li",[_._v("Accept-Encoding 浏览器可接收的压缩算法，如 gzip")]),_._v(" "),t("li",[_._v("Accept-Languange 浏览器可接收的语言，如 zh-CN")]),_._v(" "),t("li",[_._v("Connection: keep-alive 一次 TCP 连接重复使用")]),_._v(" "),t("li",[_._v("cookie")]),_._v(" "),t("li",[_._v("Host 域名")]),_._v(" "),t("li",[_._v("User-Agent（简称 UA）浏览器信息")]),_._v(" "),t("li",[_._v("Content-type 发送数据的格式，如 application/json")]),_._v(" "),t("li",[_._v("Referer：发出请求的页面的URL")])]),_._v(" "),t("h3",{attrs:{id:"常见的-response-headers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的-response-headers"}},[_._v("#")]),_._v(" 常见的 Response Headers")]),_._v(" "),t("ul",[t("li",[_._v("Content-type 返回数据的格式，如 application/json")]),_._v(" "),t("li",[_._v("Content-length 返回数据的大小，多少字节")]),_._v(" "),t("li",[_._v("Content-Encoding 返回数据的压缩算法，如 gzip")]),_._v(" "),t("li",[_._v("Set-Cookie")])]),_._v(" "),t("h3",{attrs:{id:"缓存相关的-headers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存相关的-headers"}},[_._v("#")]),_._v(" 缓存相关的 headers")]),_._v(" "),t("ul",[t("li",[_._v("Cache-Control Expires")]),_._v(" "),t("li",[_._v("Last-Modified If-Modified-Since")]),_._v(" "),t("li",[_._v("Etag If-None-Match")])]),_._v(" "),t("p",[t("strong",[_._v("常见的 Content-Type 属性值有以下四种：")])]),_._v(" "),t("p",[_._v("（1）"),t("strong",[_._v("application/x-www-form-urlencoded")]),_._v("：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。")]),_._v(" "),t("p",[_._v("（2）"),t("strong",[_._v("multipart/form-data")]),_._v("：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。")]),_._v(" "),t("p",[_._v("（3）"),t("strong",[_._v("application/json")]),_._v("：服务器消息主体是序列化后的 JSON 字符串。")]),_._v(" "),t("p",[_._v("（4）"),t("strong",[_._v("text/xml")]),_._v("：该种方式主要用来提交 XML 格式的数据。")]),_._v(" "),t("h2",{attrs:{id:"_4-http-状态码-304-是多好还是少好"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-http-状态码-304-是多好还是少好"}},[_._v("#")]),_._v(" 4. http 状态码 304 是多好还是少好")]),_._v(" "),t("p",[_._v("服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。【有关协商缓存】")]),_._v(" "),t("p",[_._v("状态码304不应该认为是一种错误，而是对客户端"),t("strong",[_._v("有缓存情况下")]),_._v("服务端的一种响应。")]),_._v(" "),t("p",[t("strong",[_._v("产生较多304状态码的原因：")])]),_._v(" "),t("ul",[t("li",[_._v("页面更新周期长或不更新")]),_._v(" "),t("li",[_._v("纯静态页面或强制生成静态 html")])]),_._v(" "),t("p",[t("strong",[_._v("304状态码出现过多会造成一下问题：")])]),_._v(" "),t("ul",[t("li",[_._v("网站快照停止")]),_._v(" "),t("li",[_._v("收录减少")]),_._v(" "),t("li",[_._v("权重下降")])]),_._v(" "),t("h2",{attrs:{id:"_5-常见的-http-请求方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-常见的-http-请求方法"}},[_._v("#")]),_._v(" 5. 常见的 http 请求方法")]),_._v(" "),t("ul",[t("li",[_._v("get 获取数据")]),_._v(" "),t("li",[_._v("post 提交数据")]),_._v(" "),t("li",[_._v("put 更新数据")]),_._v(" "),t("li",[_._v("delete 删除数据")]),_._v(" "),t("li",[_._v("head 获取报文首部，与 get 相比，不返回主体部分")]),_._v(" "),t("li",[_._v("options 询问支持的请求方法，用来跨域请求")]),_._v(" "),t("li",[_._v("connect 要求在与代理服务器通信时建立隧道，使用隧道进行 tcp 通信")]),_._v(" "),t("li",[_._v("trace 回显服务器收到的请求，主要用于测试或诊断")])]),_._v(" "),t("h2",{attrs:{id:"_6-options-请求方法及使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-options-请求方法及使用场景"}},[_._v("#")]),_._v(" 6. options 请求方法及使用场景")]),_._v(" "),t("p",[t("strong",[_._v("用 options 请求去嗅探某个请求在对应的服务器中都支持哪种请求方法")]),_._v("。")]),_._v(" "),t("p",[_._v("有时候同一个请求在浏览器中发起了两次，这是因为在跨域的情况下，在浏览器发起“复杂请求”时主动发起的。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 http 请求方法，浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获取服务器是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。")]),_._v(" "),t("p",[t("strong",[_._v("总结")])]),_._v(" "),t("p",[t("strong",[_._v("options 请求就是预检请求，可用于检测服务器允许的 http 方法")]),_._v("。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。")]),_._v(" "),t("h2",{attrs:{id:"_7-http-1-0-和-http-1-1-之间的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-http-1-0-和-http-1-1-之间的区别"}},[_._v("#")]),_._v(" 7. http 1.0 和 http 1.1 之间的区别")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("长连接")]),_._v("：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("http 1.0 默认使用短链接，每次请求都要重新建立一次 tcp 连接，则每一次建立或断开连接，都需要三次握手四次挥手的开销，如果每次请求都这样的话，开销会比较大。")])]),_._v(" "),t("li",[t("p",[_._v("http 1.1 默认使用长连接"),t("code",[_._v("Connection: keep-avlie")]),_._v("（长连接可以用来发多个 http 请求）。")])]),_._v(" "),t("li",[t("blockquote",[t("p",[_._v("在HTTP1.0中，发送一次请求时，需要"),t("strong",[_._v("等待服务端响应了")]),_._v("才可以继续发送请求。")]),_._v(" "),t("p",[_._v("在HTTP1.1中，发送一次请求时，不需要等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照"),t("strong",[_._v("响应的顺序")]),_._v("来一一接收")]),_._v(" "),t("p",[_._v("所以说，无论是HTTP1.0还是HTTP1.1提出了Pipelining理论，还是会出现"),t("strong",[_._v("阻塞")]),_._v("的情况。从专业的名词上说这种情况，叫做"),t("strong",[_._v("线头阻塞")]),_._v("（Head of line blocking）简称：HOLB")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。"),t("strong",[_._v("http1.1 通过使用持久连接来使")]),_._v("多个 http 请求")]),_._v("复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。")])]),_._v(" "),t("li",[t("p",[_._v("http 1.1 长连接有流水方式和非流水方式之分。流水方式，是客户收到 http 响应报文之前，可以接着发送新的请求报文；非流水线方式，是客户收到前一个响应后才能发起下一个请求。")])])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("错误响应码：")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("在 HTTP 1.1 中，新增了 24 个错误状态响应码")]),_._v("，如 409（Conflict）：表示请求的资源与资源的当前状态发生冲突；410（Gone）：表示服务器上的某个资源被永久性的删除；")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("缓存处理：")])]),_._v(" "),t("ul",[t("li",[_._v("HTTP 1.0 中，主要使用 header 头里的 "),t("code",[_._v("If-Modified-Since")]),_._v("、"),t("code",[_._v("Expires")]),_._v(" 来做为缓存判断的标准；")]),_._v(" "),t("li",[t("strong",[_._v("HTTP 1.1，则引入了更多的缓存控制策略")]),_._v("，如 "),t("code",[_._v("Entity tag")]),_._v("，"),t("code",[_._v("If-Unmodified-Since")]),_._v(", "),t("code",[_._v("If-Match")]),_._v(", "),t("code",[_._v("If-None-Match")]),_._v(" 等；")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("节约宽带：")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("HTTP 1.1支持只发送header信息")]),_._v("(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。\n这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。\n另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("HOST 域：")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("用来指定服务器的域名")]),_._v("。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("请求方法：")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("http1.1 相对于 http1.0 还新增了很多请求方法")]),_._v("，如 PUT、HEAD、OPTIONS 等。")])])])]),_._v(" "),t("h2",{attrs:{id:"_8-http-1-1-和-http-2-0-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-http-1-1-和-http-2-0-的区别"}},[_._v("#")]),_._v(" 8. http 1.1 和 http 2.0 的区别")]),_._v(" "),t("p",[_._v("HTTP2与HTTP1.1最重要的区别就是"),t("strong",[_._v("解决了线头阻塞（队头阻塞）的")]),_._v("问题！其中最重要的改动是："),t("strong",[_._v("多路复用 (Multiplexing)")])]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("多路复用：")])]),_._v(" "),t("ul",[t("li",[_._v("http 2.0 使用了多路复用技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 http 1.1 大了好几个数量级")]),_._v(" "),t("li",[_._v("HTTP2所有性能增强的核心在于"),t("strong",[_._v("新的二进制分帧层")]),_._v("(不再以文本格式来传输了)，它定义了如何封装http消息并在客户端与服务器之间传输。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("头部压缩：")])]),_._v(" "),t("ul",[t("li",[_._v("HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("服务器推送：")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。")]),_._v(" "),t("p",[_._v("服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。")])])])])]),_._v(" "),t("h2",{attrs:{id:"_9-当在浏览器中输入-url-并且按下回车之后发生了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-当在浏览器中输入-url-并且按下回车之后发生了什么"}},[_._v("#")]),_._v(" 9. 当在浏览器中输入 url 并且按下回车之后发生了什么？")]),_._v(" "),t("h3",{attrs:{id:"大致流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大致流程"}},[_._v("#")]),_._v(" 大致流程")]),_._v(" "),t("ol",[t("li",[_._v("URL 解析")]),_._v(" "),t("li",[_._v("DNS 查询")]),_._v(" "),t("li",[_._v("TCP 连接")]),_._v(" "),t("li",[_._v("处理请求")]),_._v(" "),t("li",[_._v("接受响应")]),_._v(" "),t("li",[_._v("渲染页面")])]),_._v(" "),t("h3",{attrs:{id:"一、url-解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、url-解析"}},[_._v("#")]),_._v(" 一、URL 解析")]),_._v(" "),t("p",[t("strong",[_._v("地址解析：")])]),_._v(" "),t("p",[_._v("首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容自动完成、字符编码等操作。")]),_._v(" "),t("p",[t("strong",[_._v("HSTS：")])]),_._v(" "),t("p",[_._v("由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。")]),_._v(" "),t("p",[t("strong",[_._v("其他操作：")])]),_._v(" "),t("p",[_._v("浏览器还会进行一些额外的操作，比如安全检查、访问限制")]),_._v(" "),t("p",[t("strong",[_._v("检查缓存：")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210823151508033.png",alt:"image-20210823151508033"}})]),_._v(" "),t("h4",{attrs:{id:"url-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#url-是什么"}},[_._v("#")]),_._v(" URL 是什么")]),_._v(" "),t("p",[_._v("URL是统一资源定位符，用于定位互联网上资源，俗称网址。")]),_._v(" "),t("p",[_._v("遵守以下的语法规则：")]),_._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[_._v("scheme"),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v(":")]),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),_._v("host"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v("domain"),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v(":")]),_._v("port"),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),_._v("path"),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),_._v("filename\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br")])]),t("p",[_._v("各部分解释如下：")]),_._v(" "),t("ul",[t("li",[_._v("scheme - 定义因特网服务的类型。常见的协议有http、https、ftp、file，其中最常见的类型是http，而https则是进行加密的网络传输。")]),_._v(" "),t("li",[_._v("host - 定义域主机（http 的默认主机是 www）")]),_._v(" "),t("li",[_._v("domain - 定义因特网 "),t("strong",[_._v("域名")]),_._v(" ，比如 w3school.com.cn")]),_._v(" "),t("li",[_._v("port - 定义主机上的端口号（http的默认端口号是80）")]),_._v(" "),t("li",[_._v("path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）")]),_._v(" "),t("li",[_._v("filename - 定义文档/资源的名称")])]),_._v(" "),t("h4",{attrs:{id:"为什么要url解析-编码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要url解析-编码"}},[_._v("#")]),_._v(" 为什么要URL解析（编码）")]),_._v(" "),t("p",[_._v("避免特殊符号带来的歧义，比如：key=value 中的 key 出现等于号=，变成这样子 ke=y=value，就难以区分哪个是key哪个是value，"),t("strong",[_._v("解决的方法")]),_._v("就是对参数进行URL编码，URL编码只是简单的在特殊符号的各个字节前加上%。")]),_._v(" "),t("p",[_._v("**另外一个问题：**为什么要用ASCII传输，可不可以用别的编码？可以，你可以自己开发一套编码自己解析，就像各个国家有各自的语言一样。但是国家之间要交流，怎么办？那就用使用访问最广的语言——英语，也就是ASCII。")]),_._v(" "),t("h4",{attrs:{id:"url的编码规则是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#url的编码规则是什么"}},[_._v("#")]),_._v(" URL的编码规则是什么")]),_._v(" "),t("p",[_._v("emmm，"),t("strong",[_._v("不同的操作系统、不同的浏览器、不同的网页字符集，都会采用不同的编码规则")]),_._v("，这将导致完全不同的编码结果。")]),_._v(" "),t("ul",[t("li",[_._v("网络路径中包含汉字的话，采用utf-8编码")]),_._v(" "),t("li",[_._v("查询字符串包含汉字的话，采用操作系统的默认编码")]),_._v(" "),t("li",[_._v("Get和POST方法生成的URL包含汉字，用的是网页的编码")]),_._v(" "),t("li",[_._v("AJax调用的URL包含汉字，IE采用操作系统默认的编码，火狐采用utf-8编码。")])]),_._v(" "),t("h4",{attrs:{id:"url编码太多-如何保证客户端只用一种编码方法向服务器发出请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#url编码太多-如何保证客户端只用一种编码方法向服务器发出请求"}},[_._v("#")]),_._v(" url编码太多，如何保证客户端只用一种编码方法向服务器发出请求？")]),_._v(" "),t("p",[_._v("使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。")]),_._v(" "),t("p",[_._v("因为JavaScript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。")]),_._v(" "),t("p",[t("strong",[_._v("Javascript三个用于编码的函数")])]),_._v(" "),t("ol",[t("li",[t("p",[_._v("escape()")]),_._v(" "),t("blockquote",[t("p",[_._v("该函数现不提倡使用，但由历史原因，有很多地方仍在使用它。")]),_._v(" "),t("p",[_._v("**作用：**它不能直接用于url编码，它的真正作用是返回一个字符的Unicode编码值。")]),_._v(" "),t("p",[_._v("**对应的解码函数：**unescape()。")]),_._v(" "),t("p",[_._v('**注意：**无论网页的原始编码是什么，一旦被js编码，就都变为unicode字符。其次，escape不对“+"编码。')])])]),_._v(" "),t("li",[t("p",[_._v("encodeURL()")]),_._v(" "),t("blockquote",[t("p",[t("strong",[_._v("它是js中真正用来对URL编码的函数。")])]),_._v(" "),t("p",[_._v("它着眼于对"),t("strong",[_._v("整个URL")]),_._v("进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号“; / ? : @ & = + $ , #”，也不进行编码。编码后，它输出符号的utf-8形式，并且在"),t("strong",[_._v("每个字节前加上%。")])]),_._v(" "),t("p",[_._v("它对应的解码函数是decodeURI()。")]),_._v(" "),t("p",[_._v("需要注意的是，它不对单引号'编码。")])])]),_._v(" "),t("li",[t("p",[_._v("encodeURLComponent()")]),_._v(" "),t("blockquote",[t("p",[_._v("它与encodeURL的"),t("strong",[_._v("区别")]),_._v("是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。")]),_._v(" "),t("p",[_._v("因此，“; / ? : @ & = + $ , #”，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。")]),_._v(" "),t("p",[_._v("它对应的解码函数是decodeURIComponent()。")])])]),_._v(" "),t("li",[t("p",[_._v("encodeURL 与 encodeURLComponent 的区别")]),_._v(" "),t("blockquote",[t("p",[_._v("区别就是encodeURIComponent编码范围更广，适合给参数编码，encodeURI适合给URL本身（locaion.origin）编码,当然项目里一般都是用qs库去处理")])])])]),_._v(" "),t("h3",{attrs:{id:"二、dns-查询"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、dns-查询"}},[_._v("#")]),_._v(" 二、DNS 查询")]),_._v(" "),t("p",[t("strong",[_._v("基本步骤")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210823151537261.png",alt:"image-20210823151537261"}})]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("浏览器缓存")])]),_._v(" "),t("p",[_._v("浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("操作系统缓存")])]),_._v(" "),t("p",[_._v("操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("路由器缓存")])]),_._v(" "),t("p",[_._v("路由器也有自己的缓存")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("ISP DNS 缓存")])]),_._v(" "),t("p",[_._v("ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("根域名服务器查询")])]),_._v(" "),t("p",[_._v("在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210823151907314.png",alt:"image-20210823151907314"}})]),_._v(" "),t("p",[t("strong",[_._v("需要注意的点")])]),_._v(" "),t("ol",[t("li",[_._v("递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）")]),_._v(" "),t("li",[_._v("迭代方式：就是本地 DNS 服务器到根域名服务器查询的方式")]),_._v(" "),t("li",[_._v("什么是 DNS 劫持？")]),_._v(" "),t("li",[_._v("前端 dns-prefetch 优化")])])])]),_._v(" "),t("h4",{attrs:{id:"dns-劫持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dns-劫持"}},[_._v("#")]),_._v(" DNS 劫持")]),_._v(" "),t("p",[_._v("DNS劫持成为DNS重定向，通过覆盖计算机的TCP/IP设置，将个人查询重定向到域名服务器DNS。这可以通过使用恶意软件或修改服务器的设置来实现。一旦执行DNS劫持，他们就可以使用它来将流量引导到不同的网站。")]),_._v(" "),t("p",[_._v("要执行攻击，犯罪者要么在用户计算机上安装恶意软件，要么接管路由器，要么拦截或破解DNS通信。DNS劫持可用于域欺骗或用于网络钓鱼。")]),_._v(" "),t("p",[t("strong",[_._v("DNS劫持的四种基本类型")]),_._v(":")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("本地DNS劫持")]),_._v(":攻击者在用户计算机上安装木马恶意软件，并更改本地DNS设置以将用户重定向到恶意站点。")]),_._v(" "),t("li",[t("strong",[_._v("路由器DNS劫持")]),_._v(":许多路由器都有默认密码或固件漏洞，攻击者可以接管路由器并覆盖DNS设置，从而影响连接到该路由器的所有用户。")]),_._v(" "),t("li",[t("strong",[_._v("中间DNS攻击")]),_._v("：攻击者拦截用户和DNS服务器之间的通信，并提供指向恶意站点的不同目标ip地址。")]),_._v(" "),t("li",[t("strong",[_._v("流氓DNS服务器")]),_._v(":攻击者攻击DNS服务器，并更改DNS记录以将DNS请求重定向到恶意站点。")])]),_._v(" "),t("h4",{attrs:{id:"前端的-dns-优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端的-dns-优化"}},[_._v("#")]),_._v(" 前端的 DNS 优化")]),_._v(" "),t("p",[t("strong",[_._v("DNS 预获取，是尝试在请求资源之前解析域名")]),_._v("。")]),_._v(" "),t("p",[_._v("当浏览器从（第三方）服务器请求资源的时候，必须先将该跨域域名解析为 ip 地址，然后浏览器才能发出请求。此过程称为 DNS 解析。DNS 缓存可以帮助减少此延迟，而 DNS 解析可以导致请求增加明显的延迟。")]),_._v(" "),t("p",[_._v("dns-prefetch 可以帮助开发人员掩盖 DNS 解析延迟。")]),_._v(" "),t("div",{staticClass:"language-html line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("<")]),_._v("meta")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[_._v("http-equiv")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[_._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v('"')]),_._v("x-dns-prefetch-control"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v('"')])]),_._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[_._v("content")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[_._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v('"')]),_._v("on"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v('"')])]),_._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("/>")])]),_._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("<")]),_._v("link")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[_._v("rel")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[_._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v('"')]),_._v("dns-prefetch"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v('"')])]),_._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[_._v("href")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[_._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v('"')]),_._v("http://bdimg.share.baidu.com"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v('"')])]),_._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("/>")])]),_._v("\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br")])]),t("h3",{attrs:{id:"三、tcp-连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、tcp-连接"}},[_._v("#")]),_._v(" 三、TCP 连接")]),_._v(" "),t("p",[_._v("TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210823152159042.png",alt:"image-20210823152159042"}})]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("应用层：发送 http 请求")])]),_._v(" "),t("p",[_._v("在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 http 报文，其中包括：")]),_._v(" "),t("ol",[t("li",[_._v("请求报头（Request Header）：请求方法、目标地址、遵顼的协议等等")]),_._v(" "),t("li",[_._v("请求主体（其他参数）")])]),_._v(" "),t("blockquote",[t("p",[_._v("其中需要注意的点：")]),_._v(" "),t("ol",[t("li",[_._v("浏览器只能发送 get、post 方法，而打开网页使用的是 get 方法。")])])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("传输层：tcp 传输报文")])]),_._v(" "),t("p",[_._v("传输层会发起一条到达服务器的 tcp 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。")]),_._v(" "),t("p",[_._v("在建立连接前，会先进行 tcp 三次握手。")]),_._v(" "),t("blockquote",[t("p",[_._v("相关知识点：tcp 三次握手、syn 泛洪攻击")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("网络层：IP 协议查询 Mac 地址")])]),_._v(" "),t("p",[_._v("将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。")]),_._v(" "),t("p",[_._v("判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。")]),_._v(" "),t("blockquote",[t("p",[_._v("注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 协议中，它位于网络层。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("链路层：以太网协议")])]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("以太网协议")])]),_._v(" "),t("p",[_._v("根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：")]),_._v(" "),t("ol",[t("li",[_._v("标头：数据包的发送者、接受者、数据类型")]),_._v(" "),t("li",[_._v("数据：数据包具体内容")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("Mac 地址")])]),_._v(" "),t("p",[_._v("以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("广播")])]),_._v(" "),t("p",[_._v("发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。")]),_._v(" "),t("blockquote",[t("p",[_._v("注意：接收方回应是单播")]),_._v(" "),t("p",[_._v("相关知识点：arp 攻击")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("服务器接受请求")])]),_._v(" "),t("p",[_._v("接受过程就是把以上步骤逆转过来")])])])])]),_._v(" "),t("h3",{attrs:{id:"四、服务器处理请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、服务器处理请求"}},[_._v("#")]),_._v(" 四、服务器处理请求")]),_._v(" "),t("p",[_._v("大致流程")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210823154022227.png",alt:"image-20210823154022227"}})]),_._v(" "),t("p",[t("strong",[_._v("HTTPD")])]),_._v(" "),t("p",[_._v("最常见的 HTTPD 有 Linux 上常用的 Apacche 和 Nginx，以及 Windows 上的 IIS")]),_._v(" "),t("p",[_._v("它会监听得到的请求，然后开启一个子进程去处理这个请求。")]),_._v(" "),t("p",[t("strong",[_._v("处理请求")])]),_._v(" "),t("p",[_._v("接受 TCP 报文后，会对连接进行处理，对 HTTP 协议进行解析（请求方法、域名、路径等），并且进行一些验证：")]),_._v(" "),t("ul",[t("li",[_._v("验证是否配置虚拟主机")]),_._v(" "),t("li",[_._v("验证虚拟主机是否接受此方法")]),_._v(" "),t("li",[_._v("验证该用户可以使用该方法（根据 IP 地址、身份信息等）")])]),_._v(" "),t("p",[t("strong",[_._v("重定向")])]),_._v(" "),t("p",[_._v("假如服务器配置了 HTTP 重定向，就会返回一个 "),t("code",[_._v("301")]),_._v("永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。")]),_._v(" "),t("p",[t("strong",[_._v("URL 重写")])]),_._v(" "),t("p",[_._v("然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，则会直接把这个文件返回。")]),_._v(" "),t("p",[_._v("否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。")]),_._v(" "),t("p",[_._v("然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。")]),_._v(" "),t("p",[_._v("以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。")]),_._v(" "),t("h3",{attrs:{id:"五、浏览器接受响应"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、浏览器接受响应"}},[_._v("#")]),_._v(" 五、浏览器接受响应")]),_._v(" "),t("p",[_._v("浏览器接收到来自服务器的响应资源后，会对资源进行分析。")]),_._v(" "),t("p",[_._v("首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。")]),_._v(" "),t("p",[_._v("如果响应资源进行了压缩（比如 gzip），还需要进行解压。")]),_._v(" "),t("p",[_._v("然后，对响应资源做缓存。")]),_._v(" "),t("p",[_._v("接下来，根据响应资源里的 "),t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types",target:"_blank",rel:"noopener noreferrer"}},[_._v("MIME (opens new window)"),t("OutboundLink")],1),_._v("类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。")]),_._v(" "),t("h3",{attrs:{id:"六、渲染页面"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、渲染页面"}},[_._v("#")]),_._v(" 六、渲染页面")]),_._v(" "),t("p",[t("strong",[_._v("浏览器内核")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210823154248269.png",alt:"image-20210823154248269"}})]),_._v(" "),t("p",[_._v("不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。")]),_._v(" "),t("p",[t("strong",[_._v("基本流程")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210823154333647.png",alt:"image-20210823154333647"}})]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("HTML解析")])]),_._v(" "),t("p",[_._v("首先要知道浏览器解析是从上往下一行一行地解析的。")]),_._v(" "),t("p",[_._v("解析的过程可以分为四个步骤：")]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("解码（encoding）")])]),_._v(" "),t("p",[_._v("传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("预解析（pre-parsing）")])]),_._v(" "),t("p",[_._v("预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如"),t("code",[_._v("img")]),_._v("标签的"),t("code",[_._v("src")]),_._v("属性，并将这个请求加到请求队列中。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("符号化（Tokenization）")])]),_._v(" "),t("p",[_._v("符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。")]),_._v(" "),t("p",[_._v("它通过一个状态机去识别符号的状态，比如遇到"),t("code",[_._v("<")]),_._v("，"),t("code",[_._v(">")]),_._v("状态都会产生变化。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("构建树（tree construction）")])]),_._v(" "),t("blockquote",[t("p",[_._v("注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。")])]),_._v(" "),t("p",[_._v("在上一步符号化中，解析器获得这些标记，然后以合适的方法创建"),t("code",[_._v("DOM")]),_._v("对象并把这些符号插入到"),t("code",[_._v("DOM")]),_._v("对象中。")]),_._v(" "),t("div",{staticClass:"language-html line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("<")]),_._v("html")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("\n  "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("<")]),_._v("head")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("<")]),_._v("title")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("Web page parsing"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("</")]),_._v("title")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("\n  "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("</")]),_._v("head")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("\n  "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("<")]),_._v("body")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("<")]),_._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("\n      "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("<")]),_._v("h1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("Web page parsing"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("</")]),_._v("h1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("\n      "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("<")]),_._v("p")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("This is an example Web page."),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("</")]),_._v("p")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("</")]),_._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("\n  "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("</")]),_._v("body")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("</")]),_._v("html")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(">")])]),_._v("\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br"),t("span",{staticClass:"line-number"},[_._v("5")]),t("br"),t("span",{staticClass:"line-number"},[_._v("6")]),t("br"),t("span",{staticClass:"line-number"},[_._v("7")]),t("br"),t("span",{staticClass:"line-number"},[_._v("8")]),t("br"),t("span",{staticClass:"line-number"},[_._v("9")]),t("br"),t("span",{staticClass:"line-number"},[_._v("10")]),t("br"),t("span",{staticClass:"line-number"},[_._v("11")]),t("br")])]),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210823154533179.png",alt:"image-20210823154533179"}})]),_._v(" "),t("p",[t("strong",[_._v("浏览器容错进制")])]),_._v(" "),t("p",[_._v('你从来没有在浏览器看过类似"语法无效"的错误，这是因为浏览器去纠正错误的语法，然后继续工作。')]),_._v(" "),t("p",[t("strong",[_._v("事件")])]),_._v(" "),t("p",[_._v("当整个解析的过程完成以后，浏览器会通过"),t("code",[_._v("DOMContentLoaded")]),_._v("事件来通知"),t("code",[_._v("DOM")]),_._v("解析完成。")])])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("css 解析")])]),_._v(" "),t("p",[_._v("一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据"),t("a",{attrs:{href:"https://drafts.csswg.org/css-syntax-3/",target:"_blank",rel:"noopener noreferrer"}},[_._v("语法规范 (opens new window)"),t("OutboundLink")],1),_._v("解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。")]),_._v(" "),t("p",[t("strong",[_._v("css 匹配规则")])]),_._v(" "),t("p",[_._v("在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如："),t("code",[_._v("div p { font-size :14px }")]),_._v("会先寻找所有的"),t("code",[_._v("p")]),_._v("标签然后判断它的父元素是否为"),t("code",[_._v("div")]),_._v("。")]),_._v(" "),t("p",[_._v("所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("渲染树")])]),_._v(" "),t("p",[_._v("其实这就是一个 DOM 树和 CSS 规则树合并的过程。")]),_._v(" "),t("p",[t("strong",[_._v("计算")])]),_._v(" "),t("p",[_._v("通过计算让任何尺寸值都减少到三个可能之一："),t("code",[_._v("auto")]),_._v("、百分比、px，比如把"),t("code",[_._v("rem")]),_._v("转化为"),t("code",[_._v("px")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("级联")])]),_._v(" "),t("p",[_._v("浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做"),t("code",[_._v("specificity")]),_._v("的公式，这个公式会通过：")]),_._v(" "),t("ol",[t("li",[_._v("标签名、class、id")]),_._v(" "),t("li",[_._v("是否内联样式")]),_._v(" "),t("li",[t("code",[_._v("!important")])])]),_._v(" "),t("p",[_._v("然后得出一个权重值，取最高的那个。")]),_._v(" "),t("p",[t("strong",[_._v("渲染阻塞")])]),_._v(" "),t("p",[_._v("当遇到一个"),t("code",[_._v("script")]),_._v("标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。")]),_._v(" "),t("p",[_._v("但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。")]),_._v(" "),t("p",[_._v("所有我们知道：")]),_._v(" "),t("ul",[t("li",[_._v("CSS 会阻塞 JS 执行")]),_._v(" "),t("li",[_._v("JS 会阻塞后面的 DOM 解析")])]),_._v(" "),t("p",[_._v("为了避免这种情况，应该以下原则：")]),_._v(" "),t("ul",[t("li",[_._v("CSS 资源排在 JavaScript 资源前面")]),_._v(" "),t("li",[_._v("JS 放在 HTML 最底部，也就是 "),t("code",[_._v("</body>")]),_._v("前")])]),_._v(" "),t("p",[_._v("另外，如果要改变阻塞模式，可以使用 defer 与 async")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("布局与绘制")])]),_._v(" "),t("p",[_._v("确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。")]),_._v(" "),t("p",[_._v("然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("合并渲染层")])]),_._v(" "),t("p",[_._v("把以上绘制的所有图片合并，最终输出一张图片。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("回流与重绘")])]),_._v(" "),t("p",[t("strong",[_._v("回流（reflow）")])]),_._v(" "),t("p",[_._v("当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从"),t("code",[_._v("html")]),_._v("标签开始递归往下，重新计算位置和大小。")]),_._v(" "),t("p",[_._v("reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。")]),_._v(" "),t("p",[t("strong",[_._v("重绘（repaint）")])]),_._v(" "),t("p",[_._v("改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。")]),_._v(" "),t("p",[_._v("每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。")]),_._v(" "),t("p",[_._v("回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。")]),_._v(" "),t("p",[_._v("比如：")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("display:none")]),_._v(" 会触发回流，而 "),t("code",[_._v("visibility:hidden")]),_._v(" 只会触发重绘。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("JavaScript 编译执行")])]),_._v(" "),t("p",[_._v("大致流程")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210823155106251.png",alt:"image-20210823155106251"}})]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("词法解析")])]),_._v(" "),t("p",[_._v("JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。")]),_._v(" "),t("p",[_._v("几个步骤：")]),_._v(" "),t("ul",[t("li",[_._v("分词，例如将"),t("code",[_._v("var a = 2")]),_._v("，，分成"),t("code",[_._v("var")]),_._v("、"),t("code",[_._v("a")]),_._v("、"),t("code",[_._v("=")]),_._v("、"),t("code",[_._v("2")]),_._v("这样的词法单元。")]),_._v(" "),t("li",[_._v("解析，将词法单元转换成抽象语法树（AST）。")]),_._v(" "),t("li",[_._v("代码生成，将抽象语法树转换成机器指令。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("预编译")])]),_._v(" "),t("p",[_._v("JS 有三种运行环境：")]),_._v(" "),t("ul",[t("li",[_._v("全局环境")]),_._v(" "),t("li",[_._v("函数环境")]),_._v(" "),t("li",[_._v("eval")])]),_._v(" "),t("p",[_._v("每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。")]),_._v(" "),t("p",[t("strong",[_._v("创建执行上下文")])]),_._v(" "),t("p",[_._v("创建执行上下文的过程中，主要做了以下三件事：")]),_._v(" "),t("ul",[t("li",[_._v("创建变量对象\n"),t("ul",[t("li",[_._v("参数、函数、变量")])])]),_._v(" "),t("li",[_._v("建立作用域链\n"),t("ul",[t("li",[_._v("确认当前执行环境是否能访问变量")])])]),_._v(" "),t("li",[_._v("确定 This 指向")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("执行")])]),_._v(" "),t("p",[t("strong",[_._v("JS 线程")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210823155705926.png",alt:"image-20210823155705926"}})]),_._v(" "),t("p",[_._v("虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：")]),_._v(" "),t("blockquote",[t("p",[_._v("其中三个只是协助，只有 JS 引擎线程是真正执行的")])]),_._v(" "),t("ul",[t("li",[_._v("JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎")]),_._v(" "),t("li",[_._v("事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行")]),_._v(" "),t("li",[_._v("定时器触发线程：主要控制"),t("code",[_._v("setInterval")]),_._v("和"),t("code",[_._v("setTimeout")]),_._v("，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。")]),_._v(" "),t("li",[_._v("HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。")])]),_._v(" "),t("p",[t("strong",[_._v("注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。")])]),_._v(" "),t("p",[t("strong",[_._v("宏任务")])]),_._v(" "),t("p",[_._v("分为：")]),_._v(" "),t("ul",[t("li",[_._v("同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务")]),_._v(" "),t("li",[_._v("异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待 JS 引擎主线程上的任务执行完毕时才开始执行，例如异步 Ajax、DOM 事件，setTimeout 等。")])]),_._v(" "),t("p",[t("strong",[_._v("微任务")])]),_._v(" "),t("p",[_._v("微任务是 ES6 和 Node 环境下的，主要 API 有："),t("code",[_._v("Promise")]),_._v("，"),t("code",[_._v("process.nextTick")]),_._v("。")]),_._v(" "),t("p",[_._v("微任务的执行在宏任务的同步任务之后，在异步任务之前。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210823155730647.png",alt:"image-20210823155730647"}})])])])])]),_._v(" "),t("p",[_._v("文章推荐：")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://4ark.me/post/b6c7c0a2.html#_3-%E6%B8%B2%E6%9F%93%E6%A0%91",target:"_blank",rel:"noopener noreferrer"}},[_._v("在浏览器输入 URL 回车之后发生了什么（超详细版）"),t("OutboundLink")],1)]),_._v(" "),t("h2",{attrs:{id:"_10-对-keep-alive-的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-对-keep-alive-的理解"}},[_._v("#")]),_._v(" 10. 对 keep-alive 的理解")]),_._v(" "),t("p",[_._v("HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是"),t("strong",[_._v("短连接")]),_._v("。当使用 Keep-Alive 模式时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，"),t("strong",[_._v("Keep-Alive 功能避免了建立或者重新建立连接（减少创建/关闭多个 TCP 连接的开销）")]),_._v("，这就是"),t("strong",[_._v("长连接")]),_._v("。其使用方法如下：")]),_._v(" "),t("ul",[t("li",[_._v("HTTP1.0 版本是默认没有 Keep-alive 的，所以要想连接得到保持，必须手动配置发送 "),t("code",[_._v("Connection: keep-alive")]),_._v(" 字段。若想断开keep-alive连接，需发送"),t("code",[_._v("Connection:close")]),_._v("字段；")]),_._v(" "),t("li",[_._v("HTTP1.1 规定了默认保持长连接，数据传输完成了保持 TCP")]),_._v(" "),t("li",[_._v("连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送"),t("code",[_._v("Connection：close")]),_._v("首部字段。")])]),_._v(" "),t("p",[_._v("Keep-Alive 的"),t("strong",[_._v("建立过程")]),_._v("：")]),_._v(" "),t("ul",[t("li",[_._v("客户端向服务器在发送请求报文同时在首部添加发送Connection字段")]),_._v(" "),t("li",[_._v("服务器收到请求并处理 Connection字段")]),_._v(" "),t("li",[_._v("服务器回送Connection:Keep-Alive字段给客户端")]),_._v(" "),t("li",[_._v("客户端接收到Connection字段")]),_._v(" "),t("li",[_._v("Keep-Alive连接建立成功")])]),_._v(" "),t("p",[t("strong",[_._v("服务端自动断开过程（也就是没有keep-alive）")]),_._v("：")]),_._v(" "),t("ul",[t("li",[_._v("客户端向服务器只是发送内容报文（不包含Connection字段）")]),_._v(" "),t("li",[_._v("服务器收到请求并处理")]),_._v(" "),t("li",[_._v("服务器返回客户端请求的资源并关闭连接")]),_._v(" "),t("li",[_._v("客户端接收资源，发现没有Connection字段，断开连接")])]),_._v(" "),t("p",[t("strong",[_._v("客户端请求断开连接过程")]),_._v("：")]),_._v(" "),t("ul",[t("li",[_._v("客户端向服务器发送Connection:close字段")]),_._v(" "),t("li",[_._v("服务器收到请求并处理connection字段")]),_._v(" "),t("li",[_._v("服务器回送响应资源并断开连接")]),_._v(" "),t("li",[_._v("客户端接收资源并断开连接")])]),_._v(" "),t("p",[_._v("开启 Keep-Alive 的"),t("strong",[_._v("优点：")])]),_._v(" "),t("ul",[t("li",[_._v("较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；")]),_._v(" "),t("li",[_._v("允许请求和应答的HTTP管线化；")]),_._v(" "),t("li",[_._v("降低拥塞控制 （TCP连接减少了）；")]),_._v(" "),t("li",[_._v("减少了后续请求的延迟（⽆需再进⾏握⼿）；")]),_._v(" "),t("li",[_._v("报告错误⽆需关闭TCP连；")])]),_._v(" "),t("p",[_._v("开启 Keep-Alive 的"),t("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),t("ul",[t("li",[_._v("长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。")])]),_._v(" "),t("p",[_._v("显然，如果客户端和服务端的确需要进行多次通信，则开启 keep-alive 是更好的选择。")]),_._v(" "),t("h2",{attrs:{id:"_11-页面有多张图片-http-是怎样的加载表现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-页面有多张图片-http-是怎样的加载表现"}},[_._v("#")]),_._v(" 11. 页面有多张图片，http 是怎样的加载表现？")]),_._v(" "),t("ul",[t("li",[_._v("在"),t("code",[_._v("HTTP 1")]),_._v("下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用"),t("strong",[_._v("多域名部署")]),_._v("解决。这样可以提高同时请求的数目，加快页面图片的获取速度。")]),_._v(" "),t("li",[_._v("在"),t("code",[_._v("HTTP 2")]),_._v("下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。")])]),_._v(" "),t("h2",{attrs:{id:"_12-http2-的头部压缩算法是怎样的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-http2-的头部压缩算法是怎样的"}},[_._v("#")]),_._v(" 12. http2 的头部压缩算法是怎样的？")]),_._v(" "),t("p",[_._v("HTTP2 的头部压缩是 HPACK 算法。在客户端和服务器两端建立“字典”，用"),t("strong",[_._v("索引号")]),_._v("表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。")]),_._v(" "),t("p",[t("strong",[_._v("过程简述：")]),_._v("【重要👇】")]),_._v(" "),t("ol",[t("li",[_._v("消息发送端和消息接收端"),t("u",[_._v("共同维护一份静态表和一份动态表")]),_._v("（这两个合起来充当字典的角色）。\n"),t("ol",[t("li",[t("strong",[_._v("静态表")]),_._v("由 header 字段的预定义静态列表组成")]),_._v(" "),t("li",[t("strong",[_._v("动态表")]),_._v("包含以"),t("strong",[_._v("先进先出")]),_._v("的顺序维护的 header 字段列表。")]),_._v(" "),t("li",[_._v("两表在同一个索引地址空间内，且动态表邻接在静态表之后。")])])]),_._v(" "),t("li",[_._v("每次请求时，发送方根据字典的内容，将 header 字段映射到索引值，从而得到编码，编码压缩消息头部")]),_._v(" "),t("li",[_._v("接收方根据字典进行解码，并且根据指令来判断是否需要更新动态表（每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值）")])]),_._v(" "),t("p",[_._v("例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210828153429187.png",alt:"image-20210828153429187"}})]),_._v(" "),t("h2",{attrs:{id:"_13-http-请求报文的是什么样的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-http-请求报文的是什么样的"}},[_._v("#")]),_._v(" 13. http 请求报文的是什么样的？")]),_._v(" "),t("p",[_._v("请求报文由4部分组成：")]),_._v(" "),t("ol",[t("li",[_._v("请求行")]),_._v(" "),t("li",[_._v("请求头")]),_._v(" "),t("li",[_._v("空行")]),_._v(" "),t("li",[_._v("请求体")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210828153759167.png",alt:"image-20210828153759167"}})]),_._v(" "),t("p",[t("strong",[_._v("组成部分")])]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("请求行包括")]),_._v("：请求方法字段、URL 字段、HTTP 协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。")]),_._v(" "),t("blockquote",[t("p",[_._v("其中HTTP协议版本有两种：HTTP1.0/HTTP1.1 可以这样区别：")]),_._v(" "),t("p",[_._v("HTTP1.0对于每个连接都只能传送一个请求和响应，请求就会关闭，HTTP1.0没有Host字段;而HTTP1.1在同一个连接中可以传送多个请求和响应，多个请求可以重叠和同时进行，HTTP1.1必须有Host字段。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("请求头部")]),_._v(":请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔")]),_._v(" "),t("ul",[t("li",[_._v("User-Agent：产⽣请求的浏览器类型。")]),_._v(" "),t("li",[_._v("Accept：客户端可识别的内容类型列表。")]),_._v(" "),t("li",[_._v("Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("请求体")]),_._v(": post put等请求携带的数据")])])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210828170118491.png",alt:"image-20210828170118491"}})]),_._v(" "),t("h2",{attrs:{id:"_14-http-响应报文是什么样的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-http-响应报文是什么样的"}},[_._v("#")]),_._v(" 14. http 响应报文是什么样的？")]),_._v(" "),t("p",[_._v("响应报文由4部分组成：")]),_._v(" "),t("ol",[t("li",[_._v("响应行")]),_._v(" "),t("li",[_._v("响应头")]),_._v(" "),t("li",[_._v("空行")]),_._v(" "),t("li",[_._v("响应体")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210828170247846.png",alt:"image-20210828170247846"}})]),_._v(" "),t("ul",[t("li",[_._v("响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。")]),_._v(" "),t("li",[_._v("响应头：响应部⾸组成")]),_._v(" "),t("li",[_._v("响应体：服务器响应的数据")])]),_._v(" "),t("h2",{attrs:{id:"_15-http-协议的优点和缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-http-协议的优点和缺点"}},[_._v("#")]),_._v(" 15. http 协议的优点和缺点")]),_._v(" "),t("p",[_._v("HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。")]),_._v(" "),t("p",[_._v("HTTP协议具有以下"),t("strong",[_._v("优点")]),_._v("：")]),_._v(" "),t("ul",[t("li",[_._v("支持客户端/服务器模式")]),_._v(" "),t("li",[t("strong",[_._v("简单快速")]),_._v("：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。")]),_._v(" "),t("li",[t("strong",[_._v("无连接")]),_._v("：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。")]),_._v(" "),t("li",[t("strong",[_._v("无状态")]),_._v("：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。")]),_._v(" "),t("li",[t("strong",[_._v("灵活")]),_._v("：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。")])]),_._v(" "),t("p",[_._v("HTTP 协议具有以下"),t("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),t("ul",[t("li",[_._v("通信使用明文，内容可能会被窃听；")]),_._v(" "),t("li",[_._v("不验证通信方的身份，因此有可能遭遇伪装；")]),_._v(" "),t("li",[_._v("无法证明报文的完整性，有可能已遭篡改；")])]),_._v(" "),t("h2",{attrs:{id:"_16-说一下-http-3-0"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-说一下-http-3-0"}},[_._v("#")]),_._v(" 16. 说一下 http 3.0")]),_._v(" "),t("p",[_._v("HTTP/3 "),t("strong",[_._v("基于 UDP 协议")]),_._v("实现了类似于 TCP 的多路复用数据流、传输可靠性等功能，这套功能被称为 QUIC 协议。")]),_._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210828171103471.png",alt:"image-20210828171103471"}}),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("流量控制、传输可靠性功能")]),_._v("："),t("strong",[_._v("QUIC")]),_._v(" 在 UDP 的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些 TCP 中的特性。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("集成 TLS 加密功能")]),_._v("：目前 QUIC 使用 TLS1.3，减少了握手所花费的 RTT 数。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("多路复用")]),_._v("：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了 TCP 的队头阻塞问题。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210828172317023.png",alt:"image-20210828172317023"}})])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("快速握手")]),_._v("：由于基于 UDP，可以实现 0-1 个 RTT 来建立连接。")])])]),_._v(" "),t("h2",{attrs:{id:"_17-http-协议的性能怎么样"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-http-协议的性能怎么样"}},[_._v("#")]),_._v(" 17. http 协议的性能怎么样")]),_._v(" "),t("p",[_._v("HTTP 协议是基于 TCP/IP，并且使用了"),t("strong",[_._v("请求-应答")]),_._v("的通信模式，所以性能的关键就在这两点里。")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("长连接")])])]),_._v(" "),t("p",[_._v("HTTP协议有两种连接模式，一种是持续连接，一种非持续连接。")]),_._v(" "),t("p",[_._v("（1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。")]),_._v(" "),t("p",[_._v("（2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。")]),_._v(" "),t("p",[_._v("对于不同版本的采用不同的连接方式：")]),_._v(" "),t("ul",[t("li",[_._v("在HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。")]),_._v(" "),t("li",[_._v("在HTTP/1.1 提出了"),t("strong",[_._v("长连接")]),_._v("的通信方式，也叫持久连接。这种方式的好处在于"),t("strong",[_._v("减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载")]),_._v("。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210829001337838.png",alt:"image-20210829001337838"}})]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("管道网络传输")])])]),_._v(" "),t("p",[_._v("HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。")]),_._v(" "),t("p",[t("strong",[_._v("管道（pipeline）网络传输是指")]),_._v("：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以"),t("strong",[_._v("减少整体的响应时间")]),_._v("。但是"),t("u",[t("strong",[_._v("服务器还是按照顺序回应请求")]),_._v("。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为"),t("strong",[_._v("队头堵塞")])]),_._v("。")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("队头堵塞")])])]),_._v(" "),t("p",[_._v("HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。")]),_._v(" "),t("p",[t("strong",[_._v("队头阻塞的解决方案：")])]),_._v(" "),t("p",[_._v("（1）"),t("strong",[_._v("并发连接")]),_._v("："),t("u",[_._v("对于一个域名允许分配多个长连接")]),_._v("，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。")]),_._v(" "),t("p",[_._v("（2）"),t("strong",[_._v("域名分片")]),_._v("："),t("u",[_._v("将域名分出很多二级域名，它们都指向同样的一台服务器")]),_._v("，能够并发的长连接数变多，解决了队头阻塞的问题。")]),_._v(" "),t("h2",{attrs:{id:"_18-url-有哪些组成部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18-url-有哪些组成部分"}},[_._v("#")]),_._v(" 18. url 有哪些组成部分")]),_._v(" "),t("p",[_._v("以下面的URL为例："),t("strong",[_._v("http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name")])]),_._v(" "),t("p",[_._v("从上面的 URL 可以看出，一个完整的 URL 包括以下几部分：")]),_._v(" "),t("ol",[t("li",[_._v("**协议部分：**该 url 的协议部分为 "),t("code",[_._v("http")]),_._v('，这代表网页使用的是 http 协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符；')]),_._v(" "),t("li",[_._v("**域名部分：**该URL的域名部分为 "),t("code",[_._v("www.aspxfans.com")]),_._v("。一个 URL 中，也可以使用 IP 地址作为域名使用。")]),_._v(" "),t("li",[t("strong",[_._v("端口部分")]),_._v("：跟在域名后面的是端口，域名和端口之间使用 "),t("code",[_._v(":")]),_._v(" 作为分隔符。端口不是一个 URL 必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；")]),_._v(" "),t("li",[t("strong",[_._v("虚拟目录部分")]),_._v("：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；")]),_._v(" "),t("li",[t("strong",[_._v("文件名部分")]),_._v("：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；")]),_._v(" "),t("li",[t("strong",[_._v("锚部分")]),_._v("：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；")]),_._v(" "),t("li",[t("strong",[_._v("参数部分")]),_._v("：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。")])]),_._v(" "),t("h2",{attrs:{id:"_19-与缓存相关的-http-请求头有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19-与缓存相关的-http-请求头有哪些"}},[_._v("#")]),_._v(" 19. 与缓存相关的 http 请求头有哪些")]),_._v(" "),t("p",[_._v("强缓存：")]),_._v(" "),t("ol",[t("li",[_._v("Expires")]),_._v(" "),t("li",[_._v("Cache-Control")])]),_._v(" "),t("p",[_._v("协商缓存：")]),_._v(" "),t("ol",[t("li",[_._v("Etag、If-None-Match")]),_._v(" "),t("li",[_._v("Last-Modified、If-Modified-Since")])]),_._v(" "),t("h1",{attrs:{id:"https-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https-协议"}},[_._v("#")]),_._v(" HTTPS 协议")]),_._v(" "),t("h2",{attrs:{id:"_1-什么是-https-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是-https-协议"}},[_._v("#")]),_._v(" 1. 什么是 https 协议？")]),_._v(" "),t("p",[_._v("超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。"),t("u",[_._v("HTTPS经由HTTP进行通信，利用 "),t("strong",[_._v("SSL/TLS")]),_._v(" 来加密数据包")]),_._v("。"),t("strong",[_._v("HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性")]),_._v("。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210829074942420.png",alt:"image-20210829074942420"}})]),_._v(" "),t("p",[_._v("HTTP 协议采用"),t("strong",[_._v("明文传输")]),_._v("信息，"),t("u",[_._v("存在"),t("strong",[_._v("信息窃听")]),_._v("、"),t("strong",[_._v("信息篡改")]),_._v("和"),t("strong",[_._v("信息劫持")]),_._v("的风险")]),_._v("，而协议 TLS/SSL 具有"),t("strong",[_._v("身份验证")]),_._v("、"),t("strong",[_._v("信息加密")]),_._v("和"),t("strong",[_._v("完整性校验")]),_._v("的功能，可以避免此类问题发生。")]),_._v(" "),t("p",[_._v("安全层的主要职责就是"),t("strong",[_._v("对发起的HTTP请求的数据进行加密操作")]),_._v(" 和 "),t("strong",[_._v("对接收到的HTTP的内容进行解密操作")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"_2-tls-sll-的工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-tls-sll-的工作原理"}},[_._v("#")]),_._v(" 2. TLS/SLL 的工作原理")]),_._v(" "),t("p",[t("strong",[_._v("传输层安全性协议 TLS")]),_._v("（Transport Layer Security），及其前身"),t("strong",[_._v("安全套接层 SSL")]),_._v("（Secure Sockets Layer）是一种安全协议，目的是"),t("strong",[_._v("为互联网通信提供安全及数据完整性保障")]),_._v("。")]),_._v(" "),t("p",[t("u",[_._v("它是介于 TCP 和 HTTP 之间的一层安全协议")]),_._v("，不影响原有的 TCP 协议和 HTTP 协议，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造。")]),_._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210829075645043.png",alt:"image-20210829075645043"}}),_._v(" "),t("p",[_._v("TLS/SSL 的功能实现主要依赖三类基本算法："),t("strong",[_._v("散列函数hash")]),_._v("、"),t("strong",[_._v("对称加密")]),_._v("、"),t("strong",[_._v("非对称加密")]),_._v("。这三类算法的作用如下：")]),_._v(" "),t("ul",[t("li",[_._v("非对称加密实现身份认证和密钥协商")]),_._v(" "),t("li",[_._v("对称加密算法采用协商的密钥对数据加密")]),_._v(" "),t("li",[_._v("基于散列函数验证信息的完整性")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210829080901791.png",alt:"image-20210829080901791"}})]),_._v(" "),t("p",[t("strong",[_._v("散列函数 Hash")])]),_._v(" "),t("p",[_._v("常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，"),t("strong",[_._v("用于防止信息篡改并验证数据的完整性")]),_._v("。\n**特点：**在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密。")]),_._v(" "),t("p",[t("strong",[_._v("对称加密")])]),_._v(" "),t("p",[_._v("对称加密的方法是，"),t("strong",[_._v("双方使用同一个秘钥对数据进行加密和解密")]),_._v("。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210829083946412.png",alt:"image-20210829083946412"}})]),_._v(" "),t("p",[_._v("常见的有 AES-CBC、DES、3DES、AES-GCM 等，信息的加密和解密用相同的密钥，掌握密钥才能获取信息。在对称加密中，信息安全的基础是保证密钥的安全。")]),_._v(" "),t("p",[_._v("**特点：**对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。")]),_._v(" "),t("p",[t("strong",[_._v("非对称加密")])]),_._v(" "),t("p",[_._v("非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210829094338804.png",alt:"image-20210829094338804"}})]),_._v(" "),t("p",[_._v("常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。")]),_._v(" "),t("p",[_._v("**特点：**非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。")]),_._v(" "),t("p",[_._v("结合三类算法的特点，"),t("strong",[_._v("TLS/SSL 的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取")]),_._v("。")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://tyler-zx.blog.csdn.net/article/details/107591115",target:"_blank",rel:"noopener noreferrer"}},[_._v("文章推荐"),t("OutboundLink")],1)]),_._v(" "),t("h2",{attrs:{id:"_3-数字证书是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-数字证书是什么"}},[_._v("#")]),_._v(" 3. 数字证书是什么？")]),_._v(" "),t("p",[_._v("现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以"),t("strong",[_._v("使用数字证书")]),_._v("。")]),_._v(" "),t("p",[_._v("首先"),t("strong",[_._v("使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要")]),_._v("，然后让有公信力的认证中心（简称 CA ）"),t("strong",[_._v("用它的私钥对消息摘要加密，形成签名")]),_._v("。最后"),t("strong",[_._v("将原始的信息和签名合在一起，称为数字证书")]),_._v("。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。")]),_._v(" "),t("p",[_._v("这个方法最重要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210829083115050.png",alt:"image-20210829083115050"}})]),_._v(" "),t("h2",{attrs:{id:"_4-https-通信-握手-过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-https-通信-握手-过程"}},[_._v("#")]),_._v(" 4. https 通信（握手）过程")]),_._v(" "),t("p",[_._v("HTTPS的通信过程如下：")]),_._v(" "),t("ol",[t("li",[_._v("客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。")]),_._v(" "),t("li",[_._v("服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。")]),_._v(" "),t("li",[_._v("客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。")]),_._v(" "),t("li",[_._v("服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。")]),_._v(" "),t("li",[_._v("客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。")])]),_._v(" "),t("h2",{attrs:{id:"_5-https-的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-https-的特点"}},[_._v("#")]),_._v(" 5. https 的特点")]),_._v(" "),t("p",[_._v("HTTPS的"),t("strong",[_._v("优点")]),_._v("如下：")]),_._v(" "),t("ul",[t("li",[_._v("使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；")]),_._v(" "),t("li",[_._v("使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；")]),_._v(" "),t("li",[_._v("HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；")])]),_._v(" "),t("p",[_._v("HTTPS的"),t("strong",[_._v("缺点")]),_._v("如下：")]),_._v(" "),t("ul",[t("li",[_._v("HTTPS 需要做服务器和客户端双方的加密和解密处理，"),t("u",[_._v("耗费更多服务器资源，过程复杂")]),_._v("；")]),_._v(" "),t("li",[_._v("HTTPS 协议"),t("u",[_._v("握手阶段比较费时")]),_._v("，增加页面的加载时间，如非必要，没有理由牺牲用户体验；")]),_._v(" "),t("li",[t("u",[_._v("SSL 证书是收费的")]),_._v("，功能越强大的证书费用越高（个人网站，小网站没有必要一般不会用）；")]),_._v(" "),t("li",[_._v("HTTPS 连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用 https，基于大部分计算资源闲置的假设的 VPS 的平均成本会上去；")]),_._v(" "),t("li",[_._v("SSL证书需要绑定 IP，不能再同一个 IP上绑定多个域名。")])]),_._v(" "),t("blockquote",[t("p",[_._v("当然了，现在https已经趋于成熟，很多缺点是可以优化和弥补的。比如：打开速度问题完全可以通过CDN加速解决，很多IDC也在着手推出免费证书和一站式https搭建服务，不久https成本将会大大缩小!")])]),_._v(" "),t("h2",{attrs:{id:"_6-https-是如何保证安全的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-https-是如何保证安全的"}},[_._v("#")]),_._v(" 6. https 是如何保证安全的？")]),_._v(" "),t("p",[_._v("先理解两个概念")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("**对称加密：**加密和解密同用一个秘钥的方式称为 共享秘钥加密，也被叫做对称秘钥加密。")]),_._v(" "),t("blockquote",[t("p",[_._v("存在的问题：")]),_._v(" "),t("p",[_._v("对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。")])])]),_._v(" "),t("li",[t("p",[_._v("**非对称加密：**浏览器通过公钥将数据加密传输给服务端，服务端收到数据使用私钥进行解密。服务端给浏览器发送数据，则使用私钥进行加密，浏览器收到服务端发送过来的数据，使用公钥进行解密。")]),_._v(" "),t("blockquote",[t("p",[_._v("存在的问题：")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("非对称加密效率太低")]),_._v("， 这会严重影响加解密的速度，进而影响到用户打开页面的速度。")]),_._v(" "),t("li",[t("strong",[_._v("无法保证服务器发送给浏览器的数据安全")]),_._v("， 服务器的数据只能用私钥进行加密(因为如果它用公钥那么浏览器也没法解密啦)，中间人一旦拿到公钥，那么就可以对服务端传来的数据进行解密了，就这样又被破解了。")])])])])]),_._v(" "),t("p",[_._v("两个加密方式都有各自的问题，"),t("strong",[_._v("解决方案")]),_._v("如下：")]),_._v(" "),t("p",[t("strong",[_._v("结合两种加密方式，将对称加密的密钥使用非对称加密的公钥进行加密")]),_._v("，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。")]),_._v(" "),t("p",[_._v("此时又带来一个问题，中间人问题：")]),_._v(" "),t("p",[_._v("如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。")]),_._v(" "),t("p",[_._v("所以这个时候需要⼀个安全的"),t("strong",[_._v("第三方颁发证书（CA）")]),_._v("，证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。")]),_._v(" "),t("p",[_._v("但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就白买了，这个时候需要⼀个新的技术，"),t("strong",[_._v("数字签名")]),_._v("。")]),_._v(" "),t("p",[_._v("数字签名就是⽤ CA ⾃带的 HASH 算法对证书的内容进⾏ HASH 得到⼀个摘要，再⽤ CA 的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的 Hash 算法,再次⽣成消息摘要，然后⽤ CA 的公钥对数字签名解密,得到 CA 创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。")]),_._v(" "),t("h1",{attrs:{id:"http-状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-状态码"}},[_._v("#")]),_._v(" HTTP 状态码")]),_._v(" "),t("h2",{attrs:{id:"状态码类别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#状态码类别"}},[_._v("#")]),_._v(" 状态码类别")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[t("strong",[_._v("类别")])]),_._v(" "),t("th",[t("strong",[_._v("原因")])]),_._v(" "),t("th",[t("strong",[_._v("描述")])])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("1xx")]),_._v(" "),t("td",[_._v("Informational(信息性状态码)")]),_._v(" "),t("td",[_._v("接受的请求正在处理")])]),_._v(" "),t("tr",[t("td",[_._v("2xx")]),_._v(" "),t("td",[_._v("Success(成功状态码)")]),_._v(" "),t("td",[_._v("请求正常处理完毕")])]),_._v(" "),t("tr",[t("td",[_._v("3xx")]),_._v(" "),t("td",[_._v("Redirection(重定向状态码)")]),_._v(" "),t("td",[_._v("需要进行附加操作一完成请求")])]),_._v(" "),t("tr",[t("td",[_._v("4xx")]),_._v(" "),t("td",[_._v("Client Error (客户端错误状态码)")]),_._v(" "),t("td",[_._v("服务器无法处理请求")])]),_._v(" "),t("tr",[t("td",[_._v("5xx")]),_._v(" "),t("td",[_._v("Server Error(服务器错误状态码)")]),_._v(" "),t("td",[_._v("服务器处理请求出错")])])])]),_._v(" "),t("h2",{attrs:{id:"_2xx-success-成功状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2xx-success-成功状态码"}},[_._v("#")]),_._v(" 2XX (Success 成功状态码)")]),_._v(" "),t("p",[_._v("状态码 2xx 表示请求被正常处理了。")]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("200 OK")])]),_._v(" "),t("p",[_._v("200 OK表示客户端发来的请求被服务器端正常处理了。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("201 Created")])]),_._v(" "),t("p",[t("u",[_._v("该请求已成功，并因此创建了一个新的资源。")]),_._v("这通常是在POST请求，或是某些 PUT 请求之后返回的响应。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("202 Accepted")])]),_._v(" "),t("p",[t("u",[_._v("请求已经接收到，但还未响应，没有结果")]),_._v("。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("204 No Content")])]),_._v(" "),t("p",[t("u",[_._v("服务器成功处理了请求，但不需要返回任何实体内容")]),_._v("，并且希望返回更新了的元信息。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("206 Partial Content")])]),_._v(" "),t("p",[t("u",[_._v("该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。")]),_._v("类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。")])])]),_._v(" "),t("h2",{attrs:{id:"_3xx-redirection-重定向状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3xx-redirection-重定向状态码"}},[_._v("#")]),_._v(" 3XX (Redirection 重定向状态码)")]),_._v(" "),t("p",[_._v("3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。")]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("301 Moved Permanently")])]),_._v(" "),t("p",[t("u",[_._v("永久重定向")]),_._v("，该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。")]),_._v(" "),t("blockquote",[t("p",[t("strong",[_._v("使用场景：")])]),_._v(" "),t("ul",[t("li",[_._v("当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。")]),_._v(" "),t("li",[_._v("在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。")])])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("302 Found")])]),_._v(" "),t("p",[t("u",[_._v("临时重定向")]),_._v("，请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。")]),_._v(" "),t("blockquote",[t("p",[t("strong",[_._v("使用场景：")])]),_._v(" "),t("ul",[t("li",[_._v("当我们在做活动时，登录到首页自动重定向，进入活动页面。")]),_._v(" "),t("li",[_._v("未登陆的用户访问用户中心重定向到登录页面。")]),_._v(" "),t("li",[_._v("访问404页面重新定向到首页。")])])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("303 See Other")])]),_._v(" "),t("p",[_._v("该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。")]),_._v(" "),t("p",[_._v("303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。")]),_._v(" "),t("p",[_._v("303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("304 Not Modified")])]),_._v(" "),t("p",[t("u",[_._v("资源未修改，配合浏览器缓存策略使用")]),_._v("。如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("307 Temporary Redirect")])]),_._v(" "),t("p",[t("u",[_._v("307表示临时重定向。")]),_._v("该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。")]),_._v(" "),t("p",[t("u",[_._v("307 会遵守浏览器标准，不会从 POST 变成 GET。")]),_._v("但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。")])])]),_._v(" "),t("h2",{attrs:{id:"_4xx-client-error-客户端错误状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4xx-client-error-客户端错误状态码"}},[_._v("#")]),_._v(" 4XX (Client Error 客户端错误状态码)")]),_._v(" "),t("p",[_._v("4XX 的响应结果表明客户端是发生错误的原因所在。")]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("400 Bad Request")])]),_._v(" "),t("ul",[t("li",[_._v("语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。")]),_._v(" "),t("li",[_._v("请求参数有误。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("401 Unauthorized")])]),_._v(" "),t("p",[t("u",[_._v("当前请求需要用户验证。")]),_._v("该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("403 Forbidden")])]),_._v(" "),t("p",[t("u",[_._v("无权限，服务器已经理解请求，但是拒绝执行它")]),_._v("，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("404 Not Found")])]),_._v(" "),t("p",[t("u",[_._v("资源不存在")]),_._v("，请求失败，请求所希望得到的资源未被在服务器上发现。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("405 Method Not Allowed")])]),_._v(" "),t("p",[t("u",[_._v("请求行中指定的请求方法不能被用于请求相应的资源。")]),_._v("该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。")])])]),_._v(" "),t("h2",{attrs:{id:"_5xx-server-error-服务器错误状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5xx-server-error-服务器错误状态码"}},[_._v("#")]),_._v(" 5XX (Server Error 服务器错误状态码)")]),_._v(" "),t("p",[_._v("5XX 的响应结果表明服务器本身发生错误。")]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("500 Internal Server Error")])]),_._v(" "),t("p",[_._v("服务器遇到了不知道如何处理的情况。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("502 Bad Gateway")])]),_._v(" "),t("p",[t("u",[_._v("该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。")]),_._v("注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("503 Service Unavailable")])]),_._v(" "),t("p",[t("u",[_._v("服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。")]),_._v(" 如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("504 Gateway Timeout")])]),_._v(" "),t("p",[t("u",[_._v("当服务器作为网关，不能及时得到响应时返回此错误代码。")]),_._v("使用场景：代码执行时间超时，或者发生了死循环。")])])]),_._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),t("p",[t("strong",[_._v("（1）2XX 成功")])]),_._v(" "),t("ul",[t("li",[_._v("200 OK，表示从客户端发来的请求在服务器端被正确处理")]),_._v(" "),t("li",[_._v("204 No content，"),t("u",[_._v("服务器成功处理了请求，但不需要返回任何实体内容")]),_._v("，并且希望返回更新了的元信息。")]),_._v(" "),t("li",[_._v("205 Reset Content，服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。")]),_._v(" "),t("li",[_._v("206 Partial Content，进行范围请求")])]),_._v(" "),t("p",[t("strong",[_._v("（2）3XX 重定向")])]),_._v(" "),t("ul",[t("li",[_._v("301 moved permanently，永久性重定向，表示资源已被分配了新的 URL")]),_._v(" "),t("li",[_._v("302 found，临时性重定向，表示资源临时被分配了新的 URL")]),_._v(" "),t("li",[_._v("303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源")]),_._v(" "),t("li",[_._v("304 not modified，资源未修改，如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变")]),_._v(" "),t("li",[_._v("307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求")])]),_._v(" "),t("p",[t("strong",[_._v("（3）4XX 客户端错误")])]),_._v(" "),t("ul",[t("li",[_._v("400 bad request，客户端请求的语法错误，服务器无法理解")]),_._v(" "),t("li",[_._v("401 unauthorized，请求要求用户的身份认证")]),_._v(" "),t("li",[_._v("403 forbidden，无权限，表示对请求资源的访问被服务器拒绝")]),_._v(" "),t("li",[_._v("404 not found，表示在服务器上没有找到请求的资源")])]),_._v(" "),t("p",[t("strong",[_._v("（4）5XX 服务器错误")])]),_._v(" "),t("ul",[t("li",[_._v("500 internal sever error，表示服务器内部错误，无法完成请求")]),_._v(" "),t("li",[_._v("501 Not Implemented，表示服务器不支持当前请求所需要的某个功能")]),_._v(" "),t("li",[_._v("502  Bad Gateway，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应")]),_._v(" "),t("li",[_._v("503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求")])]),_._v(" "),t("h2",{attrs:{id:"同样是重定向-307-303-302的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同样是重定向-307-303-302的区别"}},[_._v("#")]),_._v(" 同样是重定向，"),t("strong",[_._v("307")]),_._v("，"),t("strong",[_._v("303")]),_._v("，"),t("strong",[_._v("302")]),_._v("的区别？")]),_._v(" "),t("p",[_._v("302是 http1.0 的协议状态码，在 http1.1 版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。")]),_._v(" "),t("h1",{attrs:{id:"dns-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dns-协议"}},[_._v("#")]),_._v(" DNS 协议")]),_._v(" "),t("h2",{attrs:{id:"_1-dns-协议是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-dns-协议是什么"}},[_._v("#")]),_._v(" 1. DNS 协议是什么")]),_._v(" "),t("p",[t("strong",[_._v("DNS（Domain Names System），域名系统")]),_._v("，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器。")]),_._v(" "),t("p",[t("strong",[_._v("简单来讲，"),t("code",[_._v("DNS")]),_._v("相当于一个翻译官，负责将域名翻译成"),t("code",[_._v("ip")]),_._v("地址")])]),_._v(" "),t("ul",[t("li",[_._v("IP 地址：一长串能够唯一地标记网络上的计算机的数字")]),_._v(" "),t("li",[_._v("域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识")])]),_._v(" "),t("h2",{attrs:{id:"_2-域名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-域名"}},[_._v("#")]),_._v(" 2. 域名")]),_._v(" "),t("p",[_._v("域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名...")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210830100621307.png",alt:"image-20210830100621307"}})]),_._v(" "),t("p",[t("strong",[_._v("例如"),t("code",[_._v("www.xxx.com")]),_._v("，"),t("code",[_._v("www")]),_._v("为三级域名、"),t("code",[_._v("xxx")]),_._v("为二级域名、"),t("code",[_._v("com")]),_._v("为顶级域名")]),_._v("，系统为用户做了兼容，域名末尾的根域名"),t("code",[_._v(".")]),_._v("一般不需要输入。")]),_._v(" "),t("p",[_._v("在域名的每一层都会有一个域名服务器，如下图：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210830100714192.png",alt:"image-20210830100714192"}})]),_._v(" "),t("p",[_._v("除此之外，还有电脑默认的本地域名服务器。")]),_._v(" "),t("h2",{attrs:{id:"_3-dns-同时使用-tcp-和-udp-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-dns-同时使用-tcp-和-udp-协议"}},[_._v("#")]),_._v(" 3. DNS 同时使用 TCP 和 UDP 协议？")]),_._v(" "),t("p",[t("strong",[_._v("DNS 占用53号端口，同时使用 TCP 和 UDP 协议。")])]),_._v(" "),t("p",[_._v("（1）在区域传输的时候使用TCP协议")]),_._v(" "),t("ul",[t("li",[_._v("辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。"),t("u",[_._v("如有变动，会执行一次区域传送，进行数据同步")]),_._v("。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。")]),_._v(" "),t("li",[_._v("TCP是一种可靠连接，保证了数据的准确性。")])]),_._v(" "),t("p",[_._v("（2）在域名解析的时候使用UDP协议。")]),_._v(" "),t("ul",[t("li",[t("u",[_._v("客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。")]),_._v("不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。")])]),_._v(" "),t("h2",{attrs:{id:"_4-查询方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-查询方式"}},[_._v("#")]),_._v(" 4. 查询方式")]),_._v(" "),t("p",[_._v("DNS 查询方式有两种：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("递归查询\n"),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210830103428599.png",alt:"image-20210830103428599"}})])]),_._v(" "),t("li",[t("p",[_._v("迭代查询")]),_._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210830103502077.png",alt:"image-20210830103502077"}})])]),_._v(" "),t("h2",{attrs:{id:"_5-域名缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-域名缓存"}},[_._v("#")]),_._v(" 5. 域名缓存")]),_._v(" "),t("p",[_._v("在域名服务器解析的时候，使用缓存保存域名和"),t("code",[_._v("IP")]),_._v("地址的映射")]),_._v(" "),t("p",[_._v("计算机中"),t("code",[_._v("DNS")]),_._v("的记录也分成了两种缓存方式：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("浏览器缓存")]),_._v("：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗")]),_._v(" "),t("li",[t("strong",[_._v("操作系统缓存")]),_._v("：操作系统的缓存其实是用户自己配置的 "),t("code",[_._v("hosts")]),_._v(" 文件")])]),_._v(" "),t("h2",{attrs:{id:"_6-dns完整的查询过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-dns完整的查询过程"}},[_._v("#")]),_._v(" 6. DNS完整的查询过程")]),_._v(" "),t("p",[_._v("解析域名的过程如下：")]),_._v(" "),t("ul",[t("li",[_._v("首先搜索"),t("strong",[_._v("浏览器的 DNS 缓存")]),_._v("，缓存中维护一张域名与 IP 地址的对应表")]),_._v(" "),t("li",[_._v("若没有命中，则继续搜索"),t("strong",[_._v("操作系统的 DNS 缓存")])]),_._v(" "),t("li",[_._v("若仍然没有命中，则操作系统将域名发送至"),t("strong",[_._v("本地域名服务器")]),_._v("，本地域名服务器采用"),t("strong",[_._v("递归查询")]),_._v("自己的 DNS 缓存，查找成功则返回结果")]),_._v(" "),t("li",[_._v("若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询\n"),t("ul",[t("li",[_._v("首先本地域名服务器向"),t("strong",[_._v("根域名服务器")]),_._v("发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器")]),_._v(" "),t("li",[_._v("本地域名服务器拿到这个"),t("strong",[_._v("顶级域名服务器")]),_._v("的地址后，就向其发起请求，获取权限域名服务器的地址")]),_._v(" "),t("li",[_._v("本地域名服务器根据"),t("strong",[_._v("权限域名服务器")]),_._v("的地址向其发起请求，最终得到该域名对应的 IP 地址")])])]),_._v(" "),t("li",[t("strong",[_._v("本地域名服务器将")]),_._v("得到的 IP 地址返回给操作系统，同时自己将 IP 地址"),t("strong",[_._v("缓存起来")])]),_._v(" "),t("li",[t("strong",[_._v("操作系统")]),_._v("将 IP 地址返回给浏览器，同时自己也将 IP 地址"),t("strong",[_._v("缓存起来")])]),_._v(" "),t("li",[_._v("至此，"),t("strong",[_._v("浏览器")]),_._v("就得到了域名对应的 IP 地址，并将 IP 地址"),t("strong",[_._v("缓存起来")])])]),_._v(" "),t("p",[_._v("流程如下图所示：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210830102928030.png",alt:"image-20210830102928030"}})]),_._v(" "),t("h1",{attrs:{id:"网络模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络模型"}},[_._v("#")]),_._v(" 网络模型")]),_._v(" "),t("h2",{attrs:{id:"_1-osi-七层模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-osi-七层模型"}},[_._v("#")]),_._v(" 1. OSI 七层模型")]),_._v(" "),t("p",[t("code",[_._v("ISO")]),_._v("为了更好的使网络应用更为普及，推出了"),t("code",[_._v("OSI")]),_._v("参考模型。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210830105310234.png",alt:"image-20210830105310234"}})]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("应用层")])]),_._v(" "),t("blockquote",[t("p",[_._v("应用层位于 OSI 参考模型的第七层，其作用是"),t("strong",[_._v("通过应用程序间的交互来完成特定的网络应用")])]),_._v(" "),t("p",[_._v("该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 "),t("code",[_._v("DNS")]),_._v("，支持万维网应用的 "),t("code",[_._v("HTTP")]),_._v(" 协议，电子邮件系统采用的 "),t("code",[_._v("SMTP")]),_._v("协议等")]),_._v(" "),t("p",[_._v("在应用层交互的数据单元我们称之为报文")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("表示层")])]),_._v(" "),t("blockquote",[t("p",[_._v("表示层的作用是"),t("strong",[_._v("使通信的应用程序能够解释交换数据的含义")]),_._v("，其位于 "),t("code",[_._v("OSI")]),_._v("参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务")]),_._v(" "),t("p",[_._v("该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("会话层")])]),_._v(" "),t("blockquote",[t("p",[_._v("会话层就是"),t("strong",[_._v("负责建立、管理和终止表示层实体之间的通信会话")])]),_._v(" "),t("p",[_._v("该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("传输层")])]),_._v(" "),t("blockquote",[t("p",[_._v("传输层的主要任务是"),t("strong",[_._v("为两台主机进程之间的通信提供服务")]),_._v("，处理数据包错误、数据包次序，以及其他一些关键传输问题")]),_._v(" "),t("p",[_._v("传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层")]),_._v(" "),t("p",[_._v("其中，主要的传输层协议是"),t("code",[_._v("TCP")]),_._v("和"),t("code",[_._v("UDP")])])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("网络层")])]),_._v(" "),t("blockquote",[t("p",[_._v("两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网")]),_._v(" "),t("p",[_._v("网络层的主要任务就是"),t("strong",[_._v("选择合适的网间路由和交换节点，确保数据按时成功传送")])]),_._v(" "),t("p",[_._v("在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层")]),_._v(" "),t("p",[_._v("在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("数据链路层")])]),_._v(" "),t("blockquote",[t("p",[_._v("数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议（可以理解为网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。）")]),_._v(" "),t("p",[_._v("在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 "),t("code",[_._v("IP")]),_._v("数据报组装成帧，在两个相邻节点间的链路上传送帧")]),_._v(" "),t("p",[_._v("每一帧的数据可以分成：报头"),t("code",[_._v("head")]),_._v("和数据"),t("code",[_._v("data")]),_._v("两部分:")]),_._v(" "),t("ul",[t("li",[_._v("head 标明数据发送者、接受者、数据类型，如 MAC地址")]),_._v(" "),t("li",[_._v("data 存储了计算机之间交互的数据")])]),_._v(" "),t("p",[_._v("通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("物理层")])]),_._v(" "),t("blockquote",[t("p",[_._v("作为"),t("code",[_._v("OSI")]),_._v(" 参考模型中最低的一层，物理层的作用是"),t("strong",[_._v("实现计算机节点之间比特流的透明传送")])]),_._v(" "),t("p",[_._v("该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）")]),_._v(" "),t("p",[_._v("该层主要是和硬件有关，与软件关系不大")])])])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210831161455362.png",alt:"image-20210831161455362"}})]),_._v(" "),t("h2",{attrs:{id:"_2-tcp-ip-五-四层协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-tcp-ip-五-四层协议"}},[_._v("#")]),_._v(" 2. TCP/IP 五/四层协议")]),_._v(" "),t("h3",{attrs:{id:"含义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#含义"}},[_._v("#")]),_._v(" 含义")]),_._v(" "),t("p",[_._v("TCP/IP，"),t("strong",[_._v("传输控制协议")]),_._v("/"),t("strong",[_._v("网际协议")]),_._v("，是指能够在多个不同网络间实现信息传输的协议簇")]),_._v(" "),t("ul",[t("li",[_._v("TCP（传输控制协议）")])]),_._v(" "),t("p",[_._v("一种面向连接的、可靠的、基于字节流的传输层通信协议")]),_._v(" "),t("ul",[t("li",[_._v("IP（网际协议）")])]),_._v(" "),t("p",[_._v("用于封包交换数据网络的协议")]),_._v(" "),t("p",[_._v("TCP/IP协议不仅仅指的是"),t("code",[_._v("TCP")]),_._v("和"),t("code",[_._v("IP")]),_._v("两个协议，而是指一个由"),t("code",[_._v("FTP")]),_._v("、"),t("code",[_._v("SMTP")]),_._v("、"),t("code",[_._v("TCP")]),_._v("、"),t("code",[_._v("UDP")]),_._v("、"),t("code",[_._v("IP")]),_._v("等协议构成的协议簇，")]),_._v(" "),t("p",[_._v("只是因为在"),t("code",[_._v("TCP/IP")]),_._v("协议中"),t("code",[_._v("TCP")]),_._v("协议和"),t("code",[_._v("IP")]),_._v("协议最具代表性，所以通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols）")]),_._v(" "),t("h3",{attrs:{id:"划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#划分"}},[_._v("#")]),_._v(" 划分")]),_._v(" "),t("p",[_._v("TCP/IP 协议族按层次分别了"),t("strong",[_._v("五层体系")]),_._v("或者"),t("strong",[_._v("四层体系")])]),_._v(" "),t("p",[_._v("五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括"),t("strong",[_._v("应用层、传输层、网络层、数据链路层和物理层")])]),_._v(" "),t("p",[_._v("五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构，包括"),t("strong",[_._v("应用层、传输层、网络层（网际互联层）、网络接口层")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210831162324175.png",alt:"image-20210831162324175"}})]),_._v(" "),t("h3",{attrs:{id:"五层体系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五层体系"}},[_._v("#")]),_._v(" 五层体系")]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("应用层")])]),_._v(" "),t("blockquote",[t("p",[t("code",[_._v("TCP/IP")]),_._v(" 模型将 "),t("code",[_._v("OSI")]),_._v("参考模型中的"),t("strong",[_._v("会话层、表示层和应用层")]),_._v("的功能"),t("strong",[_._v("合并")]),_._v("到一个应用层实现，"),t("strong",[_._v("通过不同的应用层协议为不同的应用提供服务")])]),_._v(" "),t("p",[_._v("如："),t("code",[_._v("FTP")]),_._v("、"),t("code",[_._v("Telnet")]),_._v("、"),t("code",[_._v("DNS")]),_._v("、"),t("code",[_._v("SMTP")]),_._v(" 等")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("传输层")])]),_._v(" "),t("blockquote",[t("p",[_._v("该层对应于 OSI 参考模型的传输层，"),t("strong",[_._v("为上层实体提供源端到对端主机的通信功能")])]),_._v(" "),t("p",[_._v("传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）")]),_._v(" "),t("p",[_._v("其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("网络层")])]),_._v(" "),t("blockquote",[t("p",[_._v("负责为分组网络中的不同主机提供通信服务，并通过"),t("strong",[_._v("选择合适的路由将数据传递到目标主机")])]),_._v(" "),t("p",[_._v("在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("数据链路层")])]),_._v(" "),t("blockquote",[t("p",[_._v("负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("物理层")])]),_._v(" "),t("blockquote",[t("p",[_._v("保护数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境")])])])]),_._v(" "),t("h3",{attrs:{id:"四层体系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四层体系"}},[_._v("#")]),_._v(" 四层体系")]),_._v(" "),t("p",[_._v("TCP/IP 的四层结构则如下表所示：")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("层次名称")]),_._v(" "),t("th",[_._v("单位")]),_._v(" "),t("th",[_._v("功 能")]),_._v(" "),t("th",[_._v("协 议")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("网络接口层")]),_._v(" "),t("td",[_._v("帧")]),_._v(" "),t("td",[_._v("负责实际数据的传输，对应OSI参考模型的下两层")]),_._v(" "),t("td",[_._v("HDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）")])]),_._v(" "),t("tr",[t("td",[_._v("网络层")]),_._v(" "),t("td",[_._v("数据报")]),_._v(" "),t("td",[_._v("负责网络间的寻址数据传输，对应OSI参考模型的第三层")]),_._v(" "),t("td",[_._v("IP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）")])]),_._v(" "),t("tr",[t("td",[_._v("传输层")]),_._v(" "),t("td",[_._v("报文段")]),_._v(" "),t("td",[_._v("负责提供可靠的传输服务，对应OSI参考模型的第四层")]),_._v(" "),t("td",[_._v("TCP（控制传输协议） UDP（用户数据报协议）")])]),_._v(" "),t("tr",[t("td",[_._v("应用层")]),_._v(" "),t("td"),_._v(" "),t("td",[_._v("负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层")]),_._v(" "),t("td",[_._v("FTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）")])])])]),_._v(" "),t("p",[_._v("从上图中可以看出，"),t("code",[_._v("TCP/IP")]),_._v("模型比"),t("code",[_._v("OSI")]),_._v("模型更加简洁，它把"),t("code",[_._v("应用层/表示层/会话层")]),_._v("全部整合为了"),t("code",[_._v("应用层")]),_._v("。")]),_._v(" "),t("p",[_._v("在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210831163323092.png",alt:"image-20210831163323092"}})]),_._v(" "),t("p",[_._v("在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210831163404638.png",alt:"image-20210831163404638"}})]),_._v(" "),t("h1",{attrs:{id:"tcp-与-udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-与-udp"}},[_._v("#")]),_._v(" TCP 与 UDP")]),_._v(" "),t("h2",{attrs:{id:"_1-tcp-与-udp-的概念及特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-tcp-与-udp-的概念及特点"}},[_._v("#")]),_._v(" 1. TCP 与 UDP 的概念及特点")]),_._v(" "),t("h3",{attrs:{id:"udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[_._v("#")]),_._v(" UDP")]),_._v(" "),t("p",[t("strong",[_._v("UDP（User Datagram Protocol），用户数据包协议")]),_._v("，是一个简单的"),t("strong",[_._v("面向数据报的通信协议")]),_._v("，即对应用层交下来的报文，"),t("u",[_._v("不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层")])]),_._v(" "),t("p",[_._v("也就是说无论应用层交给"),t("code",[_._v("UDP")]),_._v("多长的报文，它统统发送，"),t("u",[_._v("一次发送一个报文")])]),_._v(" "),t("p",[_._v("而对接收方，接到后直接去除首部，交给上面的应用层就完成任务")]),_._v(" "),t("p",[t("code",[_._v("UDP")]),_._v("报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210831164029786.png",alt:"image-20210831164029786"}})]),_._v(" "),t("p",[_._v("特点如下：")]),_._v(" "),t("ul",[t("li",[_._v("**面向无连接：**UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务")]),_._v(" "),t("li",[t("strong",[_._v("不可靠性：")]),_._v(" "),t("ul",[t("li",[_._v("传输途中出现丢包，UDP 也不负责重发")]),_._v(" "),t("li",[_._v("当包的到达顺序出现乱序时，UDP没有纠正的功能。")])])]),_._v(" "),t("li",[_._v("**面向报文：**并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。")]),_._v(" "),t("li",[t("strong",[_._v("支持单播、多播、广播的功能")])]),_._v(" "),t("li",[_._v("**头部开销小，传输数据报文时是很高效的。**相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。")]),_._v(" "),t("li",[t("u",[_._v("即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。")]),_._v("即使网络条件不好，也不会对发送速率进行调整。这样实现的"),t("strong",[_._v("弊端")]),_._v("就是在网络条件不好的情况下可能会导致丢包，但是"),t("strong",[_._v("优点")]),_._v("也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。")])]),_._v(" "),t("h3",{attrs:{id:"tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[_._v("#")]),_._v(" TCP")]),_._v(" "),t("p",[_._v("TCP（Transmission Control Protocol），"),t("u",[_._v("传输控制协议")]),_._v("，是一种可靠、"),t("strong",[_._v("面向字节流的通信协议")]),_._v("，把上面应用层交下来的数据看成无结构的字节流来发送。")]),_._v(" "),t("p",[t("u",[_._v("流就是指不间断的数据结构")]),_._v("，可以想象成流水形式的，发送方 TCP 会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小")]),_._v(" "),t("p",[t("code",[_._v("TCP")]),_._v("报文首部至少有20个字节，额外开销大。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210831214529610.png",alt:"image-20210831214529610"}})]),_._v(" "),t("p",[_._v("特点如下：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("面向连接")]),_._v(" "),t("ul",[t("li",[_._v("面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为"),t("u",[_._v("数据的可靠传输")]),_._v("打下了基础。")])])]),_._v(" "),t("li",[t("strong",[_._v("仅支持单播传输")]),_._v(" "),t("ul",[t("li",[_._v("每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。")])])]),_._v(" "),t("li",[t("strong",[_._v("面向字节流")]),_._v(" "),t("ul",[t("li",[_._v("TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。")])])]),_._v(" "),t("li",[t("strong",[_._v("可靠传输")]),_._v(" "),t("ul",[t("li",[_._v("对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。")])])]),_._v(" "),t("li",[t("strong",[_._v("提供拥塞控制")]),_._v(" "),t("ul",[t("li",[_._v("当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。")])])]),_._v(" "),t("li",[t("strong",[_._v("提供全双工通信")]),_._v(" "),t("ul",[t("li",[_._v("TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）")])])])]),_._v(" "),t("h2",{attrs:{id:"_2-tcp-与-udp-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-tcp-与-udp-的区别"}},[_._v("#")]),_._v(" 2. TCP 与 UDP 的区别")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th"),_._v(" "),t("th",[_._v("UDP")]),_._v(" "),t("th",[_._v("TCP")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("是否连接")]),_._v(" "),t("td",[_._v("无连接")]),_._v(" "),t("td",[_._v("面向连接")])]),_._v(" "),t("tr",[t("td",[_._v("是否可靠")]),_._v(" "),t("td",[_._v("不可靠传输，不使用流量控制和拥塞控制")]),_._v(" "),t("td",[_._v("可靠传输（数据顺序和正确性），使用流量控制和拥塞控制")])]),_._v(" "),t("tr",[t("td",[_._v("连接对象个数")]),_._v(" "),t("td",[_._v("支持一对一，一对多，多对一和多对多交互通信")]),_._v(" "),t("td",[_._v("只能是一对一通信，全双工")])]),_._v(" "),t("tr",[t("td",[_._v("传输方式")]),_._v(" "),t("td",[_._v("面向报文")]),_._v(" "),t("td",[_._v("面向字节流")])]),_._v(" "),t("tr",[t("td",[_._v("首部开销")]),_._v(" "),t("td",[_._v("首部开销小，仅8字节")]),_._v(" "),t("td",[_._v("首部最小20字节，最大60字节")])]),_._v(" "),t("tr",[t("td",[_._v("适用场景")]),_._v(" "),t("td",[_._v("适用于实时应用，例如视频会议、直播")]),_._v(" "),t("td",[_._v("适用于要求可靠传输的应用，例如文件传输")])]),_._v(" "),t("tr",[t("td",[_._v("流量控制")]),_._v(" "),t("td",[_._v("无")]),_._v(" "),t("td",[_._v("滑动窗口")])]),_._v(" "),t("tr",[t("td",[_._v("拥塞控制")]),_._v(" "),t("td",[_._v("无")]),_._v(" "),t("td",[_._v("慢开始、拥塞避免、快重传、快恢复")])])])]),_._v(" "),t("h2",{attrs:{id:"_3-tcp-和-udp-的使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-tcp-和-udp-的使用场景"}},[_._v("#")]),_._v(" 3. TCP 和 UDP 的使用场景")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("TCP应用场景：")]),_._v(" 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。")]),_._v(" "),t("li",[t("strong",[_._v("UDP应用场景：")]),_._v(" 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。")])]),_._v(" "),t("h2",{attrs:{id:"_4-udp-协议为什么不可靠"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-udp-协议为什么不可靠"}},[_._v("#")]),_._v(" 4. UDP 协议为什么不可靠？")]),_._v(" "),t("p",[_._v("UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：")]),_._v(" "),t("ul",[t("li",[_._v("**不保证消息交付：**不确认，不重传，无超时")]),_._v(" "),t("li",[_._v("**不保证交付顺序：**不设置包序号，不重排，不会发生队首阻塞")]),_._v(" "),t("li",[_._v("**不跟踪连接状态：**不必建立连接或重启状态机")]),_._v(" "),t("li",[_._v("**不进行拥塞控制：**不内置客户端或网络反馈机制")])]),_._v(" "),t("h2",{attrs:{id:"_5-tcp-的重传机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-tcp-的重传机制"}},[_._v("#")]),_._v(" 5. TCP 的重传机制")]),_._v(" "),t("p",[_._v("由于TCP的下层网络（网络层）可能出现"),t("strong",[_._v("丢失、重复或失序")]),_._v("的情况，TCP协议"),t("u",[_._v("提供可靠数据传输服务")]),_._v("。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是"),t("strong",[_._v("基于时间")]),_._v("，二是"),t("strong",[_._v("基于确认信息")]),_._v("。")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("基于时间")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("超时重传")]),_._v("，TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内（RTO）没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。")]),_._v(" "),t("li",[_._v("如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是"),t("u",[_._v("超时间隔加倍")]),_._v("。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("基于确认信息")])]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("快速重传")]),_._v("，它不以时间为驱动，而是以数据驱动重传。所以，"),t("strong",[_._v("快速重传的工作方式")]),_._v("是"),t("u",[_._v("服务端当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段")]),_._v("。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("快速重传机制只解决了一个问题")]),_._v("，就是"),t("u",[_._v("超时时间的问题")]),_._v("，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("SACK 方法")]),_._v("，选择性确认。这种方式需要在 TCP 头部「选项」字段里加一个 "),t("code",[_._v("SACK")]),_._v(" 的东西，它"),t("u",[_._v("可以将缓存的地图发送给发送方")]),_._v("，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以"),t("u",[_._v("只重传丢失的数据")]),_._v("。\n如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 "),t("code",[_._v("SACK")]),_._v(" 信息发现只有 "),t("code",[_._v("200~299")]),_._v(" 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。\n"),t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210901001535901.png",alt:"image-20210901001535901"}})])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("D-SACK")]),_._v("，其"),t("u",[_._v("主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了")]),_._v("。")]),_._v(" "),t("p",[_._v("举个例子说明 D-SACK 的作用：")]),_._v(" "),t("p",[_._v("例子1：ACK 丢包\n"),t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210901001729139.png",alt:"image-20210901001729139"}})]),_._v(" "),t("blockquote",[t("p",[_._v("ACK 丢包")]),_._v(" "),t("ul",[t("li",[_._v("「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）")]),_._v(" "),t("li",[t("strong",[_._v("于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500")]),_._v("，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 "),t("code",[_._v("D-SACK")]),_._v("。")]),_._v(" "),t("li",[_._v("这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。")])])]),_._v(" "),t("p",[_._v("例子2：网络延时")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210901002000889.png",alt:"image-20210901002000889"}})]),_._v(" "),t("blockquote",[t("p",[_._v("网络延时")]),_._v(" "),t("ul",[t("li",[_._v("数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。")]),_._v(" "),t("li",[_._v("而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；")]),_._v(" "),t("li",[t("strong",[_._v("所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。")])]),_._v(" "),t("li",[_._v("这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。")])])])])])])]),_._v(" "),t("p",[t("a",{attrs:{href:"https://www.cnblogs.com/xiaolincoding/p/12732052.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制"),t("OutboundLink")],1)]),_._v(" "),t("h2",{attrs:{id:"_6-tcp-的流量控制机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-tcp-的流量控制机制"}},[_._v("#")]),_._v(" 6. TCP 的流量控制机制")]),_._v(" "),t("p",[_._v("一般来说，"),t("strong",[_._v("流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收")]),_._v("。TCP采用大小可变的"),t("strong",[_._v("滑动窗口")]),_._v("进行流量控制，窗口大小的单位是字节。这里说的窗口大小（即TCP报文段首部中的“窗口”字段 "),t("code",[_._v("rwnd")]),_._v("）其实就是每次传输的数据大小。同时，发送方根据其对当前网络拥塞程序的估计确定一个拥塞窗口 "),t("code",[_._v("cwnd")]),_._v("，最终A发送的窗口的实际大小是"),t("code",[_._v("min(rwnd,cwnd)")]),_._v(" 值。")]),_._v(" "),t("ul",[t("li",[_._v("当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。")]),_._v(" "),t("li",[_._v("当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）")]),_._v(" "),t("li",[_._v("如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。")]),_._v(" "),t("li",[_._v("如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。")])]),_._v(" "),t("h2",{attrs:{id:"_7-tcp-的拥塞控制机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-tcp-的拥塞控制机制"}},[_._v("#")]),_._v(" 7. TCP 的拥塞控制机制")]),_._v(" "),t("p",[_._v("拥塞控制的"),t("strong",[_._v("目的")]),_._v("就是"),t("u",[_._v("避免 [发送方] 的数据填满整个网络")]),_._v("。")]),_._v(" "),t("blockquote",[t("p",[_._v("在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….")])]),_._v(" "),t("p",[t("strong",[_._v("什么是拥塞窗口，和发送窗口有什么关系？")])]),_._v(" "),t("p",[t("u",[_._v("拥塞窗口 cwnd")]),_._v("是发送方维护的一个的状态变量，它会根据"),t("u",[_._v("网络的拥塞程度动态变化的")]),_._v("。")]),_._v(" "),t("p",[_._v("我们在前面提到过发送窗口 "),t("code",[_._v("swnd")]),_._v(" 和接收窗口 "),t("code",[_._v("rwnd")]),_._v(" 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。")]),_._v(" "),t("p",[_._v("拥塞窗口 "),t("code",[_._v("cwnd")]),_._v(" 变化的规则：")]),_._v(" "),t("ul",[t("li",[_._v("只要网络中没有出现拥塞，"),t("code",[_._v("cwnd")]),_._v(" 就会增大；")]),_._v(" "),t("li",[_._v("但网络中出现了拥塞，"),t("code",[_._v("cwnd")]),_._v(" 就减少；")])]),_._v(" "),t("p",[t("strong",[_._v("那么怎么知道当前网络是否出现了拥塞呢？")])]),_._v(" "),t("p",[_._v("其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是"),t("u",[_._v("发生了超时重传，就会认为网络出现了拥塞。")])]),_._v(" "),t("p",[t("strong",[_._v("拥塞控制有哪些控制算法？")])]),_._v(" "),t("p",[_._v("拥塞控制主要是四个算法：")]),_._v(" "),t("ul",[t("li",[_._v("慢启动")]),_._v(" "),t("li",[_._v("拥塞避免")]),_._v(" "),t("li",[_._v("拥塞发生")]),_._v(" "),t("li",[_._v("快速恢复")])]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("慢启动（慢开始）")])]),_._v(" "),t("blockquote",[t("ul",[t("li",[t("p",[_._v("在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）")])]),_._v(" "),t("li",[t("p",[_._v("思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小（发包的个数是"),t("u",[_._v("指数性的增长")]),_._v("）。")])]),_._v(" "),t("li",[t("p",[_._v("为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)")]),_._v(" "),t("ul",[t("li",[_._v("当cnwd < ssthresh，使用慢开始算法")]),_._v(" "),t("li",[_._v("当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法")]),_._v(" "),t("li",[_._v("当cnwd > ssthresh，使用拥塞避免算法")])])])])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("拥塞避免")])]),_._v(" "),t("blockquote",[t("ul",[t("li",[t("p",[_._v("拥塞避免未必能够完全避免拥塞，是说"),t("u",[_._v("在拥塞避免阶段将拥塞窗口控制为按线性增长")]),_._v("，使网络不容易出现阻塞。")])]),_._v(" "),t("li",[t("p",[_._v("思路： 让拥塞窗口cwnd缓慢的增大，即"),t("u",[_._v("每当收到一个 ACK 时，cwnd 增加 1/cwnd。")])])]),_._v(" "),t("li",[t("p",[_._v("无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示：\n"),t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210901232744055.png",alt:"image-20210901232744055"}})])]),_._v(" "),t("li",[t("p",[_._v("其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。")])]),_._v(" "),t("li",[t("p",[_._v("所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。")]),_._v(" "),t("p",[_._v("就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。")]),_._v(" "),t("p",[_._v("当触发了重传机制，也就进入了「拥塞发生算法」。")])])])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("拥塞发生")])]),_._v(" "),t("p",[_._v("当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：")]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("超时重传")])]),_._v(" "),t("blockquote",[t("p",[_._v("当发生超时重传，则就会使用拥塞发生算法。"),t("code",[_._v("ssthresh")]),_._v(" 设为 "),t("code",[_._v("cwnd/2")]),_._v("，"),t("code",[_._v("cwnd")]),_._v(" 重置为 1。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210901234405229.png",alt:"image-20210901234405229"}})]),_._v(" "),t("p",[_._v("接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("快速重传")])]),_._v(" "),t("blockquote",[t("p",[_._v("当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 "),t("code",[_._v("ssthresh")]),_._v(" 和 "),t("code",[_._v("cwnd")]),_._v(" 变化如下：")]),_._v(" "),t("p",[t("code",[_._v("cwnd = cwnd/2")]),_._v("，也就是设置为原来的一半；"),t("code",[_._v("ssthresh = cwnd")]),_._v("；进入快速恢复算法")])])])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("快速恢复")])]),_._v(" "),t("blockquote",[t("p",[_._v("快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 "),t("code",[_._v("RTO")]),_._v(" 超时那么强烈。")]),_._v(" "),t("p",[_._v("正如前面所说，进入快速恢复之前，"),t("code",[_._v("cwnd")]),_._v(" 和 "),t("code",[_._v("ssthresh")]),_._v(" 已被更新了：")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("cwnd = cwnd/2")]),_._v(" ，也就是设置为原来的一半;")]),_._v(" "),t("li",[t("code",[_._v("ssthresh = cwnd")]),_._v(";")])]),_._v(" "),t("p",[_._v("然后，进入快速恢复算法如下：")]),_._v(" "),t("ul",[t("li",[_._v("拥塞窗口 "),t("code",[_._v("cwnd = ssthresh + 3")]),_._v(" （ 3 的意思是确认有 3 个数据包被收到了）；")]),_._v(" "),t("li",[_._v("重传丢失的数据包；")]),_._v(" "),t("li",[_._v("如果再收到重复的 ACK，那么 cwnd 增加 1；")]),_._v(" "),t("li",[_._v("如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210901235244076.png",alt:"image-20210901235244076"}})])])])]),_._v(" "),t("h2",{attrs:{id:"_8-tcp-的可靠传输机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-tcp-的可靠传输机制"}},[_._v("#")]),_._v(" 8. TCP 的可靠传输机制")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("**确认和重传：**接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。")])]),_._v(" "),t("li",[t("p",[_._v("**校验和：**TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("数据合理分片和排序：")])]),_._v(" "),t("blockquote",[t("p",[_._v("UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报.")]),_._v(" "),t("p",[_._v("tcp会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。")]),_._v(" "),t("p",[_._v("​\t\t应用数据被分割成 TCP 认为最适合发送的数据块。")]),_._v(" "),t("p",[_._v("​\t\tTCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。")])])]),_._v(" "),t("li",[t("p",[_._v("**流量控制：**当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。")])]),_._v(" "),t("li",[t("p",[_._v("**拥塞控制：**当网络拥塞时，减少数据的发送。")])]),_._v(" "),t("li",[t("p",[_._v("**ARQ协议：**也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。")])])]),_._v(" "),t("h3",{attrs:{id:"arq-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arq-协议"}},[_._v("#")]),_._v(" ARQ 协议")]),_._v(" "),t("p",[t("strong",[_._v("自动重传请求")]),_._v("（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。")]),_._v(" "),t("h4",{attrs:{id:"停止等待-arq-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#停止等待-arq-协议"}},[_._v("#")]),_._v(" 停止等待 ARQ 协议")]),_._v(" "),t("ul",[t("li",[_._v("停止等待协议是为了实现可靠传输的，它的基本原理就是"),t("u",[_._v("每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组")]),_._v("；")]),_._v(" "),t("li",[_._v("在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；")])]),_._v(" "),t("p",[_._v("**优点：**简单")]),_._v(" "),t("p",[_._v("**缺点：**信道利用率低，等待时间长")]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("无差错情况")])]),_._v(" "),t("blockquote",[t("p",[_._v("发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("出现差错情况（超时重传）")])]),_._v(" "),t("blockquote",[t("p",[_._v("停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为"),t("strong",[_._v("自动重传请求 ARQ")]),_._v("。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。"),t("strong",[_._v("连续 ARQ 协议")]),_._v("可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("确认丢失和确认迟到")])]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("确认丢失")])]),_._v(" "),t("blockquote",[t("p",[_._v("确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下"),t("u",[_._v("两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。")])])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("确认迟到")])]),_._v(" "),t("blockquote",[t("p",[_._v("确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。"),t("u",[_._v("处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。")])])])])])])]),_._v(" "),t("h4",{attrs:{id:"连续-arq-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连续-arq-协议"}},[_._v("#")]),_._v(" 连续 ARQ 协议")]),_._v(" "),t("p",[_._v("连续 ARQ 协议可提高信道利用率。发送方"),t("u",[_._v("维持一个发送窗口")]),_._v("，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用"),t("u",[_._v("累计确认")]),_._v("，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。")]),_._v(" "),t("p",[_._v("**优点：**信道利用率高，容易实现，即使确认丢失，也不必重传。")]),_._v(" "),t("p",[_._v("**缺点：**不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。")]),_._v(" "),t("h3",{attrs:{id:"滑动窗口和流量控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口和流量控制"}},[_._v("#")]),_._v(" 滑动窗口和流量控制")]),_._v(" "),t("p",[_._v("**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。**接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。")]),_._v(" "),t("h3",{attrs:{id:"拥塞控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞控制"}},[_._v("#")]),_._v(" 拥塞控制")]),_._v(" "),t("p",[_._v("在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是"),t("u",[_._v("为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载")]),_._v("。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。")]),_._v(" "),t("p",[_._v("为了进行拥塞控制，TCP 发送方要维持一个**拥塞窗口(cwnd)**的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。")]),_._v(" "),t("p",[_._v("TCP的拥塞控制采用了四种算法，即"),t("strong",[_._v("慢开始")]),_._v("、"),t("strong",[_._v("拥塞避免")]),_._v("、"),t("strong",[_._v("快重传")]),_._v("和"),t("strong",[_._v("快恢复")]),_._v("。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。")]),_._v(" "),t("ul",[t("li",[_._v("**慢开始：**慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。")]),_._v(" "),t("li",[_._v("**拥塞避免：**拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.")]),_._v(" "),t("li",[_._v("**快重传与快恢复：**在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。")])]),_._v(" "),t("p",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000022944999",target:"_blank",rel:"noopener noreferrer"}},[_._v("TCP 协议如何保证可靠传输"),t("OutboundLink")],1)]),_._v(" "),t("h2",{attrs:{id:"_9-tcp-的三次握手和四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-tcp-的三次握手和四次挥手"}},[_._v("#")]),_._v(" 9. TCP 的三次握手和四次挥手")]),_._v(" "),t("h3",{attrs:{id:"三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210902105038450.png",alt:"image-20210902105038450"}})]),_._v(" "),t("p",[_._v("三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器"),t("u",[_._v("总共发送3个包")]),_._v("。进行三次握手的"),t("strong",[_._v("主要作用")]),_._v("就是为了"),t("u",[_._v("确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备")]),_._v("。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。")]),_._v(" "),t("p",[_._v("刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("第一次握手")]),_._v("：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。（连接请求报文段）")])]),_._v(" "),t("blockquote",[t("p",[_._v("首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("第二次握手")]),_._v("：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为 ack 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。（应答）")])]),_._v(" "),t("blockquote",[t("p",[_._v("在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("第三次握手")]),_._v("：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。（确认报文）")])]),_._v(" "),t("blockquote",[t("p",[_._v("确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。")])]),_._v(" "),t("p",[t("strong",[_._v("那为什么要三次握手呢？两次不行吗？")])]),_._v(" "),t("ol",[t("li",[t("p",[_._v("为了确认双方的接收能力和发送能力都正常")])]),_._v(" "),t("li",[t("p",[_._v("如果是用两次握手，则会出现下面这种情况：")]),_._v(" "),t("blockquote",[t("p",[_._v("如客户端发出连接请求，但因连接请求报文"),t("strong",[_._v("丢失")]),_._v("而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，"),t("strong",[_._v("此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。")])])])])]),_._v(" "),t("p",[t("strong",[_._v("小结")])]),_._v(" "),t("ul",[t("li",[_._v("**第一次握手：**客户端向服务端发送"),t("u",[_._v("连接请求报文段")]),_._v("。该报文段中包含自身的数据通讯初始序号。请求发送后，"),t("u",[_._v("客户端便进入 SYN-SENT 状态")]),_._v("。")]),_._v(" "),t("li",[_._v("**第二次握手：**服务端收到连接请求报文段后，如果同意连接，则会发送一个"),t("u",[_._v("应答")]),_._v("，该应答中也会包含自身的数据通讯初始序号，发送完成后便"),t("u",[_._v("进入 SYN-RECEIVED 状态")]),_._v("。")]),_._v(" "),t("li",[_._v("**第三次握手：**当客户端收到连接同意的应答后，还要向服务端发送一个"),t("u",[_._v("确认报文")]),_._v("。"),t("u",[_._v("客户端")]),_._v("发完这个报文段后便进入 "),t("u",[_._v("ESTABLISHED 状")]),_._v("态，"),t("u",[_._v("服务端")]),_._v("收到这个应答后也进入 "),t("u",[_._v("ESTABLISHED 状态")]),_._v("，此时连接建立成功。")])]),_._v(" "),t("p",[_._v("TCP 三次握手的建立连接的过程就是"),t("strong",[_._v("相互确认初始序号的过程")]),_._v("，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。")]),_._v(" "),t("h3",{attrs:{id:"四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[_._v("#")]),_._v(" 四次挥手")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210902111955225.png",alt:"image-20210902111955225"}})]),_._v(" "),t("p",[_._v("刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("第一次挥手")]),_._v("： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时"),t("u",[_._v("客户端处于 FIN_WAIT1")]),_._v(" 状态。")])]),_._v(" "),t("blockquote",[t("p",[_._v("即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("第二次挥手")]),_._v("：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时"),t("u",[_._v("服务端处于 CLOSE_WAIT")]),_._v(" 状态。")])]),_._v(" "),t("blockquote",[t("p",[_._v("即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("第三次挥手")]),_._v("：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时"),t("u",[_._v("服务端处于 LAST_ACK")]),_._v(" 的状态。")])]),_._v(" "),t("blockquote",[t("p",[_._v("即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("第四次挥手")]),_._v("：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时"),t("u",[_._v("客户端处于 TIME_WAIT")]),_._v(" 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 "),t("u",[_._v("CLOSED")]),_._v(" 状态，服务端收到 ACK 报文之后，就处于关闭连接了，"),t("u",[_._v("处于 CLOSED 状态")]),_._v("。")])]),_._v(" "),t("blockquote",[t("p",[_._v("即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。")])]),_._v(" "),t("p",[t("strong",[_._v("那为什么需要四次挥手呢？")])]),_._v(" "),t("blockquote",[t("p",[_._v("因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，“你发的FIN报文我收到了”。"),t("strong",[_._v("只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手")]),_._v("。")])]),_._v(" "),t("p",[t("strong",[_._v("小结")])]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("第一次挥手")]),_._v("：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("第二次挥手")]),_._v("：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("第三次挥手")]),_._v("：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。")]),_._v(" "),t("blockquote",[t("p",[t("strong",[_._v("第二次挥手和第三次挥手不能合并的原因：")])]),_._v(" "),t("p",[_._v("客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。(CLOSE_WAIT状态的意义所在)。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("第四次挥手")]),_._v("：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（"),t("strong",[_._v("最大段生存期")]),_._v("，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。")])])]),_._v(" "),t("p",[t("strong",[_._v("TCP 使用四次挥手的原因")]),_._v("是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。")]),_._v(" "),t("p",[t("strong",[_._v("最后一次挥手中，客户端会等待一段时间再关闭的原因")]),_._v("，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭。")]),_._v(" "),t("h3",{attrs:{id:"什么是-tcp-半连接队列和全连接队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-tcp-半连接队列和全连接队列"}},[_._v("#")]),_._v(" "),t("strong",[_._v("什么是 TCP 半连接队列和全连接队列？")])]),_._v(" "),t("p",[_._v("在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：")]),_._v(" "),t("ul",[t("li",[_._v("半连接队列，也称 SYN 队列；")]),_._v(" "),t("li",[_._v("全连接队列，也称 accepet 队列；")])]),_._v(" "),t("p",[_._v("服务端收到客户端发起的 SYN 请求后，"),t("strong",[_._v("内核会把该连接存储到半连接队列")]),_._v("，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，"),t("strong",[_._v("内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。")])]),_._v(" "),t("p",[_._v("半连接队列与全连接队列")]),_._v(" "),t("p",[_._v("不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。")]),_._v(" "),t("p",[t("strong",[_._v("注意")]),_._v("，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…")]),_._v(" "),t("h3",{attrs:{id:"isn-初始化序列-是固定的吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#isn-初始化序列-是固定的吗"}},[_._v("#")]),_._v(" ISN（初始化序列）是固定的吗？")]),_._v(" "),t("p",[_._v("当一端为建立连接而发送它的 SYN 时，它为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。ISN 可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的"),t("strong",[_._v("目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释")]),_._v("。")]),_._v(" "),t("p",[_._v("三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 "),t("strong",[_._v("ISN 是动态生成的")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"三次握手过程中可以携带数据吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手过程中可以携带数据吗"}},[_._v("#")]),_._v(" 三次握手过程中可以携带数据吗？")]),_._v(" "),t("p",[_._v("其实"),t("strong",[_._v("第三次握手的时候，是可以携带数据的")]),_._v("。但是，第一次、第二次握手不可以携带数据")]),_._v(" "),t("p",[_._v("为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。")]),_._v(" "),t("p",[_._v("也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。")]),_._v(" "),t("h3",{attrs:{id:"syn-攻击是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#syn-攻击是什么"}},[_._v("#")]),_._v(" SYN 攻击是什么")]),_._v(" "),t("p",[_._v("服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，**由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。**SYN 攻击是一种典型的 DoS/DDoS 攻击。")]),_._v(" "),t("p",[_._v("检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。")]),_._v(" "),t("div",{staticClass:"language-javascript line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[_._v("netstat "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("-")]),_._v("n "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("-")]),_._v("p "),t("span",{pre:!0,attrs:{class:"token constant"}},[_._v("TCP")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" grep "),t("span",{pre:!0,attrs:{class:"token constant"}},[_._v("SYN_RECV")]),_._v("\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br")])]),t("p",[_._v("常见的防御 SYN 攻击的方法有如下几种：")]),_._v(" "),t("ul",[t("li",[_._v("缩短超时（SYN Timeout）时间")]),_._v(" "),t("li",[_._v("增加最大半连接数")]),_._v(" "),t("li",[_._v("过滤网关防护")]),_._v(" "),t("li",[_._v("SYN cookies技术")])]),_._v(" "),t("p",[t("a",{attrs:{href:"https://www.huaweicloud.com/articles/a5ade3fe6835161e23ff064dc8f5e1f9.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("三次握手，四次挥手"),t("OutboundLink")],1)]),_._v(" "),t("h2",{attrs:{id:"_10-tcp-粘包是怎么回事-如何处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-tcp-粘包是怎么回事-如何处理"}},[_._v("#")]),_._v(" 10. TCP 粘包是怎么回事，如何处理？")]),_._v(" "),t("p",[t("strong",[_._v("MTU 和 MSS 区别")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210902140205368.png",alt:"image-20210902140205368"}})]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("MTU: Maximum Transmit Unit")]),_._v("，最大传输单元。 由"),t("strong",[_._v("网络接口层（数据链路层）"),t("strong",[_._v("提供给")]),_._v("网络层")]),_._v("最大一次传输数据的大小；一般 MTU="),t("strong",[_._v("1500 Byte")]),_._v("。 假设IP层有 <= 1500 byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有> 1500 byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同。")]),_._v(" "),t("li",[t("strong",[_._v("MSS：Maximum Segment Size")]),_._v(" 。 TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和 TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。 假设 MTU= 1500 byte，那么 "),t("strong",[_._v("MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte")]),_._v("，如果应用层有 "),t("strong",[_._v("2000 byte")]),_._v(" 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。")])]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议。")]),_._v(" "),t("p",[_._v("其中跟"),t("strong",[_._v("粘包")]),_._v("关系最大的就是"),t("strong",[_._v("基于字节流")]),_._v("这个特点。")]),_._v(" "),t("p",[_._v("字节流可以理解为一个双向的通道里面流淌的数据，这个数据其实就是二进制数据（01串），这些01串"),t("strong",[_._v("没有任何边界")]),_._v("。")]),_._v(" "),t("p",[_._v("应用层传到 TCP 协议的数据，不是以"),t("strong",[_._v("消息报为单位")]),_._v("向目的主机发送，而是以"),t("strong",[_._v("字节流")]),_._v("的方式发送到下游，这些数据可能被"),t("strong",[_._v("切割和组装")]),_._v("成各种数据包，"),t("u",[_._v("接收端收到这些数据包后没有正确还原原来的消息，因此出现粘包现象")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("为什么要组装发送的数据？")])]),_._v(" "),t("blockquote",[t("p",[_._v("TCP "),t("strong",[_._v("切割")]),_._v("数据包是为了能顺利通过网络这根水管。相反，还有一个"),t("strong",[_._v("组装")]),_._v("的情况。如果前后两次 TCP 发的数据都远小于 MSS，比如就几个字节，每次都单独发送这几个字节，就比较"),t("strong",[_._v("浪费")]),_._v("网络 io 。")])]),_._v(" "),t("p",[_._v("因此要组装数据，优化的方法就是 👉 "),t("code",[_._v("TCP")]),_._v("的 "),t("strong",[_._v("Nagle 算法")]),_._v("优化，目的是为了避免发送小的数据包。")]),_._v(" "),t("p",[_._v("在 Nagle 算法开启的状态下，数据包在以下两个情况会被发送：")]),_._v(" "),t("ul",[t("li",[_._v("如果包长度达到"),t("code",[_._v("MSS")]),_._v("（或含有"),t("code",[_._v("Fin")]),_._v("包），立刻发送，否则"),t("strong",[_._v("等待")]),_._v("下一个包到来；如果下一包到来后两个包的总长度超过"),t("code",[_._v("MSS")]),_._v("的话，就会进行拆分发送；")]),_._v(" "),t("li",[_._v("等待超时（一般为"),t("code",[_._v("200ms")]),_._v("），第一个包没到"),t("code",[_._v("MSS")]),_._v("长度，但是又迟迟等不到第二个包的到来，则立即发送。")])]),_._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210902140516110.png",alt:"image-20210902140516110"}}),_._v(" "),t("ul",[t("li",[_._v("由于启动了"),t("strong",[_._v("Nagle算法")]),_._v("， msg1 小于 mss ，此时等待"),t("code",[_._v("200ms")]),_._v("内来了一个 msg2 ，msg1 + msg2 > MSS，因此把 msg2 分为 msg2(1) 和 msg2(2)，msg1 + msg2(1) 包的大小为"),t("code",[_._v("MSS")]),_._v("。此时发送出去。")]),_._v(" "),t("li",[_._v("剩余的 msg2(2) 也等到了 msg3， 同样 msg2(2) + msg3 > MSS，因此把 msg3 分为 msg3(1) 和 msg3(2)，msg2(2) + msg3(1) 作为一个包发送。")]),_._v(" "),t("li",[_._v("剩余的 msg3(2) 长度不足"),t("code",[_._v("mss")]),_._v("，同时在"),t("code",[_._v("200ms")]),_._v("内没有等到下一个包，等待超时，直接发送。")]),_._v(" "),t("li",[_._v("此时三个包虽然在图里"),t("strong",[_._v("颜色不同")]),_._v("，但是实际场景中，他们都是"),t("strong",[_._v("一整个 01 串")]),_._v("，如果处理开发者把第一个收到的 msg1 + msg2(1) 就当做是一个完整消息进行处理，就会看上去就"),t("strong",[_._v("像是两个包粘在一起")]),_._v("，就会导致"),t("strong",[_._v("粘包问题")]),_._v("。")])]),_._v(" "),t("p",[t("strong",[_._v("怎么处理粘包")])]),_._v(" "),t("p",[_._v("粘包出现的根本原因是不确定"),t("strong",[_._v("消息的边界")]),_._v('。接收端在面对**"无边无际"的二进制流'),t("strong",[_._v("的时候，根本不知道收了多少 01 才算")]),_._v("一个消息**。一不小心拿多了就说是"),t("strong",[_._v("粘包")]),_._v("。其实粘包根本不是 TCP 的问题，是使用者对于 TCP 的理解有误导致的一个问题。")]),_._v(" "),t("p",[_._v("只要在发送端每次发送消息的时候给消息"),t("strong",[_._v("带上识别消息边界的信息")]),_._v("，接收端就可以根据这些信息识别出消息的边界，从而区分出每个消息。")]),_._v(" "),t("p",[t("strong",[_._v("常见的方法有：")])]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("加入特殊标志")])]),_._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210902140732324.png",alt:"image-20210902140732324"}}),_._v(" "),t("p",[_._v("可以通过特殊的标志作为头尾，比如当收到了"),t("code",[_._v("0xfffffe")]),_._v("或者回车符，则认为收到了新消息的头，此时继续取数据，直到收到下一个头标志"),t("code",[_._v("0xfffffe")]),_._v("或者尾部标记，才认为是一个完整消息。类似的像 HTTP 协议里当使用 "),t("strong",[_._v("chunked 编码")]),_._v(" 传输时，使用若干个 chunk 组成消息，最后由一个标明长度为 0 的 chunk 结束。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("加入消息长度信息")])]),_._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210902140906041.png",alt:"image-20210902140906041"}}),_._v(" "),t("p",[_._v("这个一般配合上面的特殊标志一起使用，在收到头标志时，里面还可以带上消息长度，以此表明在这之后多少 byte 都是属于这个消息的。如果在这之后正好有符合长度的 byte，则取走，作为一个完整消息给应用层使用。在实际场景中，HTTP 中的"),t("code",[_._v("Content-Length")]),_._v("就起了类似的作用，当接收端收到的消息长度小于 Content-Length 时，说明还有些消息没收到。那接收端会一直等，直到拿够了消息或超时。")]),_._v(" "),t("p",[_._v("可能这时候会有朋友会问，采用"),t("code",[_._v("0xfffffe")]),_._v("标志位，用来标志一个数据包的开头，你就不怕你发的某个数据里正好有这个内容吗？")]),_._v(" "),t("blockquote",[t("p",[_._v("是的，"),t("strong",[_._v("怕")]),_._v("，所以一般除了这个标志位，发送端在发送时还会加入各种校验字段（"),t("code",[_._v("校验和")]),_._v("或者对整段完整数据进行 "),t("code",[_._v("CRC")]),_._v(" 之后获得的数据）放在标志位后面，在接收端拿到整段数据后校验下确保它就是发送端发来的完整数据。")])])])]),_._v(" "),t("h2",{attrs:{id:"_11-udp-会粘包吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-udp-会粘包吗"}},[_._v("#")]),_._v(" 11. UDP 会粘包吗？")]),_._v(" "),t("p",[_._v("不会。")]),_._v(" "),t("ul",[t("li",[_._v("TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是"),t("strong",[_._v("⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据")])]),_._v(" "),t("li",[_._v("UDP"),t("strong",[_._v("具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了")]),_._v("。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。")])]),_._v(" "),t("h2",{attrs:{id:"_12-为什么长度字段冗余还要加到-udp-首部中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-为什么长度字段冗余还要加到-udp-首部中"}},[_._v("#")]),_._v(" 12. 为什么长度字段冗余还要加到 UDP 首部中")]),_._v(" "),t("p",[_._v("前提：IP 头里带了总长度，正好可以用于计算 UDP 数据的长度")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/dadadaxyx/my-images/raw/master/image-20210902141727612.png",alt:"image-20210902141727612"}})]),_._v(" "),t("p",[_._v("IP 层是网络层的，而 UDP 是传输层的，到了传输层，数据包就已经不存在IP头信息了，那么此时的UDP数据会被放在 UDP 的 "),t("code",[_._v("Socket Buffer")]),_._v(" 中。当应用层来不及取这个 UDP 数据报，那么两个数据报在数据层面其实都是一堆 01 串。此时读取第一个数据报的时候，会先读取到 UDP 头部，"),t("strong",[_._v("如果这时候 UDP 头不含 UDP 长度信息，那么应用层应该取多少数据才算完整的一个数据报呢")]),_._v("？")]),_._v(" "),t("p",[_._v("因此 UDP 头的这个长度其实跟 TCP "),t("strong",[_._v("为了防止粘包而在消息体里加入的边界信息")]),_._v("是起一样的作用的。")]),_._v(" "),t("h1",{attrs:{id:"websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[_._v("#")]),_._v(" WebSocket")]),_._v(" "),t("h2",{attrs:{id:"_1-对-websocket-的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-对-websocket-的理解"}},[_._v("#")]),_._v(" 1. 对 WebSocket 的理解")]),_._v(" "),t("p",[t("strong",[_._v("概念")])]),_._v(" "),t("p",[_._v("WebSocket是HTML5提供的一种浏览器与服务器进行"),t("strong",[_._v("全双工通讯")]),_._v("的网络技术，属于"),t("u",[_._v("应用层协议")]),_._v("。它"),t("u",[_._v("基于TCP传输协议")]),_._v("，并"),t("u",[_._v("复用HTTP的握手通道")]),_._v("。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。")]),_._v(" "),t("p",[_._v("WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是："),t("strong",[_._v("服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。")])]),_._v(" "),t("p",[t("strong",[_._v("WebSocket原理")]),_._v("：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。")]),_._v(" "),t("p",[t("strong",[_._v("原理")])]),_._v(" "),t("p",[_._v("客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。")]),_._v(" "),t("p",[t("strong",[_._v("特点")])]),_._v(" "),t("ol",[t("li",[_._v("支持双向通信，实时性更强，允许数据在"),t("u",[_._v("两个方向上同时")]),_._v("传输。")]),_._v(" "),t("li",[_._v("可以发送文本，也可以发送二进制数据。相比 http/2 ，WebSocekt 更侧重于”实时通信“，而 http/2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别。")]),_._v(" "),t("li",[_._v("建立在TCP协议之上，服务端的实现比较容易。")]),_._v(" "),t("li",[_._v("数据格式比较轻量，性能开销小，通信高效。")]),_._v(" "),t("li",[_._v("没有同源限制，客户端可以与任意服务器通信。")]),_._v(" "),t("li",[_._v("协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。")]),_._v(" "),t("li",[_._v("与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。")])]),_._v(" "),t("p",[t("strong",[_._v("应用场景")])]),_._v(" "),t("p",[_._v("基于"),t("code",[_._v("websocket")]),_._v("的事实通信的特点，其存在的应用场景大概有：")]),_._v(" "),t("ul",[t("li",[_._v("弹幕")]),_._v(" "),t("li",[_._v("媒体聊天")]),_._v(" "),t("li",[_._v("协同编辑")]),_._v(" "),t("li",[_._v("基于位置的应用")]),_._v(" "),t("li",[_._v("体育实况更新")]),_._v(" "),t("li",[_._v("股票基金报价实时更新")])]),_._v(" "),t("h2",{attrs:{id:"_2-即使通讯的实现-短轮询、长轮询、sse-和-websocket-间的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-即使通讯的实现-短轮询、长轮询、sse-和-websocket-间的区别"}},[_._v("#")]),_._v(" 2. 即使通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？")]),_._v(" "),t("p",[t("strong",[_._v("短轮询和长轮询的目的都是用于实现客户端和服务器端的一个"),t("u",[_._v("即时通讯")]),_._v("。")])]),_._v(" "),t("p",[t("strong",[_._v("短轮询的基本思路："),t("strong",[_._v("浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，"),t("u",[_._v("不论是否有数据更新，都直接进行响应")]),_._v("。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的")]),_._v("优点")]),_._v("是"),t("u",[_._v("比较简单，易于理解")]),_._v("。"),t("strong",[_._v("缺点")]),_._v("是这种方式由于"),t("u",[_._v("需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源")]),_._v("。当用户增加时，服务器端的压力就会变大，这是很不合理的。")]),_._v(" "),t("p",[t("strong",[_._v("长轮询的基本思路："),t("strong",[_._v("首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，"),t("u",[_._v("服务器端不会直接进行响应，而是先将这个请求挂起")]),_._v("，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的")]),_._v("优点")]),_._v("是"),t("u",[_._v("明显减少了很多不必要的 http 请求次数，相比之下节约了资源")]),_._v("。长轮询的"),t("strong",[_._v("缺点")]),_._v("在于，"),t("u",[_._v("连接挂起也会导致资源的浪费")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("SSE 的基本思想：")]),t("u",[_._v("服务器使用"),t("strong",[_._v("流信息")]),_._v("向服务器推送信息")]),_._v("。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。S"),t("u",[_._v("SE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持")]),_._v("。它相对于前面两种方式来说，"),t("u",[_._v("不需要建立过多的 http 请求，相比之下节约了资源")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("WebSocket")]),_._v(" 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的"),t("strong",[_._v("缺点")]),_._v("是在服务器端的配置比较复杂。"),t("u",[_._v("WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("上面的四个通信协议，前三个都是基于HTTP协议的。")])]),_._v(" "),t("p",[_._v("对于这四种即使通信协议，从性能的角度来看：")]),_._v(" "),t("p",[t("strong",[_._v("WebSocket > 长连接（SEE） > 长轮询 > 短轮询")])]),_._v(" "),t("p",[_._v("但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了：")]),_._v(" "),t("p",[t("strong",[_._v("短轮询 > 长轮询 > 长连接（SEE） > WebSocket")])]),_._v(" "),t("p",[_._v("所以，还是要根据具体的使用场景来判断使用哪种方式。")])])}),[],!1,null,null,null);v.default=a.exports}}]);